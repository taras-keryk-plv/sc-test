# Copyright 2021-present Intel Corporation.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Thrift SAI interface Tunnel tests
"""

import binascii
import random

from sai_thrift.sai_headers import *

from ptf.mask import Mask

from sai_base_test import *


@group("draft")
class VxLanBaseSetup(SaiHelper):
    '''
    Basic configuration for VxLAN tunnel tests

    Args:
        ipv6 (bool): ipv6 underlay configuraton indicator
    '''

    def __init__(self, ipv6=False):
        super(VxLanBaseSetup, self).__init__()
        self.ipv6 = ipv6

        if ipv6 is True:
            self.tun_ip = "2001:0db8::10:1"
            self.lpb_ip = "2001:0db8::10:10"
            self.tun_ip_mask = "/128"
        else:
            self.tun_ip = "10.10.10.1"
            self.lpb_ip = "10.10.10.2"
            self.tun_ip_mask = "/32"

    def setUp(self):
        super(VxLanBaseSetup, self).setUp()

        self.oport = self.port24
        self.oport_dev = self.dev_port24
        self.uport = self.port25
        self.uport_dev = self.dev_port25

        self.vni = 1000
        self.vm_ip = "100.100.1.1"
        self.vm_ipv6 = "2001:0db8::1:1"
        self.customer_ip = "100.100.2.1"
        self.customer_ipv6 = "2001:0db8::2:1"
        self.inner_dmac = "00:11:11:11:11:11"
        self.customer_mac = "00:22:22:22:22:22"
        self.unbor_mac = "00:33:33:33:33:33"

        # underlay configuration
        self.uvrf = sai_thrift_create_virtual_router(self.client)

        # overlay configuraion
        self.ovrf = sai_thrift_create_virtual_router(self.client)
        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL

        # underlay loopback RIF for tunnel
        self.urif_lpb = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_LOOPBACK,
            virtual_router_id=self.uvrf)

        self.urif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.uvrf,
            port_id=self.uport)

        self.orif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.ovrf,
            port_id=self.oport)

        # encap/decap mappers
        self.encap_tunnel_map = sai_thrift_create_tunnel_map(
            self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

        self.decap_tunnel_map = sai_thrift_create_tunnel_map(
            self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

        # encap/decap mapper entries
        self.encap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
            self.client,
            tunnel_map=self.encap_tunnel_map,
            tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
            virtual_router_id_key=self.ovrf,
            vni_id_value=self.vni)

        self.decap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
            self.client,
            tunnel_map=self.encap_tunnel_map,
            tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
            virtual_router_id_value=self.ovrf,
            vni_id_key=self.vni)

        encap_maps = sai_thrift_object_list_t(count=1,
                                              idlist=[self.encap_tunnel_map])
        decap_maps = sai_thrift_object_list_t(count=1,
                                              idlist=[self.decap_tunnel_map])

        # tunnel
        self.tunnel = sai_thrift_create_tunnel(
            self.client,
            type=tunnel_type,
            encap_src_ip=sai_ipaddress(self.lpb_ip),
            encap_mappers=encap_maps,
            decap_mappers=decap_maps,
            encap_ttl_mode=ttl_mode,
            decap_ttl_mode=ttl_mode,
            underlay_interface=self.urif_lpb)

        # tunnel termination entry
        self.tunnel_term = sai_thrift_create_tunnel_term_table_entry(
            self.client,
            tunnel_type=tunnel_type,
            vr_id=self.uvrf,
            action_tunnel_id=self.tunnel,
            type=term_type,
            src_ip=sai_ipaddress(self.tun_ip),
            dst_ip=sai_ipaddress(self.lpb_ip))

        # route to customer from VM
        self.onhop = sai_thrift_create_next_hop(
            self.client, ip=sai_ipaddress(self.customer_ip),
            router_interface_id=self.orif, type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor = sai_thrift_neighbor_entry_t(
            rif_id=self.orif, ip_address=sai_ipaddress(self.customer_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor,
                                         dst_mac_address=self.customer_mac,
                                         no_host_route=True)

        self.customer_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(self.customer_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer_route,
                                      next_hop_id=self.onhop)

        self.onhop_v6 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer_ipv6),
            router_interface_id=self.orif,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif, ip_address=sai_ipaddress(self.customer_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor_v6,
                                         dst_mac_address=self.customer_mac,
                                         no_host_route=True)

        self.customer_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(self.customer_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer_v6_route,
                                      next_hop_id=self.onhop_v6)

        # tunnel nexthop for VM
        self.tunnel_nhop = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
            tunnel_id=self.tunnel,
            ip=sai_ipaddress(self.tun_ip),
            tunnel_mac=self.inner_dmac,
            tunnel_vni=self.vni)

        # routes to VM via tunnel nexthop
        self.vm_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.vm_route,
                                      next_hop_id=self.tunnel_nhop)

        self.vm_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.vm_v6_route,
                                      next_hop_id=self.tunnel_nhop)

        # route to tunnel
        self.unhop = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip),
                                                router_interface_id=self.urif,
                                                type=SAI_NEXT_HOP_TYPE_IP)

        self.unbor = sai_thrift_neighbor_entry_t(
            rif_id=self.urif, ip_address=sai_ipaddress(self.tun_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.unbor,
                                         dst_mac_address=self.unbor_mac,
                                         no_host_route=True)

        self.tunnel_route = sai_thrift_route_entry_t(
            vr_id=self.uvrf,
            destination=sai_ipprefix(self.tun_ip + self.tun_ip_mask))
        sai_thrift_create_route_entry(self.client,
                                      self.tunnel_route,
                                      next_hop_id=self.unhop)

    def runTest(self):
        self.basicTunnelTest()

    def tearDown(self):
        sai_thrift_remove_route_entry(self.client, self.tunnel_route)
        sai_thrift_remove_neighbor_entry(self.client, self.unbor)
        sai_thrift_remove_next_hop(self.client, self.unhop)
        sai_thrift_remove_route_entry(self.client, self.vm_v6_route)
        sai_thrift_remove_route_entry(self.client, self.vm_route)
        sai_thrift_remove_next_hop(self.client, self.tunnel_nhop)
        sai_thrift_remove_route_entry(self.client, self.customer_v6_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor_v6)
        sai_thrift_remove_next_hop(self.client, self.onhop_v6)
        sai_thrift_remove_route_entry(self.client, self.customer_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor)
        sai_thrift_remove_next_hop(self.client, self.onhop)
        sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                  self.tunnel_term)
        sai_thrift_remove_tunnel(self.client, self.tunnel)
        sai_thrift_remove_tunnel_map_entry(self.client,
                                           self.decap_tunnel_map_entry)
        sai_thrift_remove_tunnel_map_entry(self.client,
                                           self.encap_tunnel_map_entry)
        sai_thrift_remove_tunnel_map(self.client, self.decap_tunnel_map)
        sai_thrift_remove_tunnel_map(self.client, self.encap_tunnel_map)
        sai_thrift_remove_router_interface(self.client, self.orif)
        sai_thrift_remove_router_interface(self.client, self.urif)
        sai_thrift_remove_router_interface(self.client, self.urif_lpb)
        sai_thrift_remove_virtual_router(self.client, self.ovrf)
        sai_thrift_remove_virtual_router(self.client, self.uvrf)

        super(VxLanBaseSetup, self).tearDown()

    def basicTunnelTest(self):
        '''
        Verify if dataplane is correctly set before sending malformed packets
        '''
        print("\nbasicTunnelTest()")

        pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                eth_src=ROUTER_MAC,
                                ip_dst=self.customer_ip,
                                ip_src=self.vm_ip,
                                ip_id=108,
                                ip_ttl=63)
        inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.inner_dmac,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=64)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.inner_dmac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=self.tun_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Sending valid VxLAN%s packet" % ("v6" if self.ipv6 else "v4"))
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_packet(self, pkt, self.oport_dev)
        print("\tOK")


# # # # # # # # # # VxLAN malformed packets tests follow # # # # # # # # # #
@group("draft")
class TunnelMalformedEncapPacketsBase(VxLanBaseSetup):
    '''
    Tests regarding different cases of malformed encap packets

    Args:
        ipv6 (bool): ipv6 underlay configuraton indicator
    '''

    def __init__(self, ipv6=False):
        super(TunnelMalformedEncapPacketsBase, self).__init__(ipv6=ipv6)

    def tunnelEncapInvalidIpVersionTest(self):
        '''
        Verify if encapsulated packet with invalid version is dropped
        '''
        print("\ntunnelEncapInvalidIpVersionTest()")

        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=self.customer_mac,
                                ip_dst=self.vm_ip,
                                ip_src=self.customer_ip,
                                ip_id=108,
                                ip_ttl=64)
        pkt[IP].version = 6

        print("Sending IPv4 packet with invalid IP version")
        send_packet(self, self.oport_dev, pkt)
        verify_no_other_packets(self)
        print("\tDropped")

        pkt_v6 = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                     eth_src=self.customer_mac,
                                     ipv6_dst=self.vm_ipv6,
                                     ipv6_src=self.customer_ipv6,
                                     ipv6_hlim=64)
        pkt_v6[IPv6].version = 4

        print("Sending IPv6 packet with invalid IP version")
        send_packet(self, self.oport_dev, pkt_v6)
        verify_no_other_packets(self)
        print("\tDropped")

    def tunnelEncapInvalidIhlTest(self):
        '''
        Verify if encapsulated packet with invalid IHL value is dropped
        '''
        print("\ntunnelEncapInvalidIhlTest()")

        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=self.customer_mac,
                                ip_dst=self.vm_ip,
                                ip_src=self.customer_ip,
                                ip_id=108,
                                ip_ttl=64)

        for i in range(5):
            pkt[IP].ihl = i

            print("Sending packet with invalid IHL=%d" % pkt[IP].ihl)
            send_packet(self, self.oport_dev, pkt)
            verify_no_other_packets(self)
            print("\tDropped")

    def tunnelEncapInvalidTtlTest(self):
        '''
        Verify if encapsulated packet with invalid TTL value is dropped
        '''
        print("\ntunnelEncapInvalidTtlTest()")

        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=self.customer_mac,
                                ip_dst=self.vm_ip,
                                ip_src=self.customer_ip,
                                ip_id=108,
                                ip_ttl=0)

        print("Sending packet with invalid TTL=0")
        send_packet(self, self.oport_dev, pkt)
        verify_no_other_packets(self)
        print("\tDropped")

    def tunnelEncapInvalidChksumTest(self):
        '''
        Verify if encapsulated packet with invalid checksum is dropped
        '''
        print("\ntunnelEncapInvalidChksumTest()")

        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=self.customer_mac,
                                ip_dst=self.vm_ip,
                                ip_src=self.customer_ip,
                                ip_id=108,
                                ip_ttl=64,
                                with_udp_chksum=True)

        pkt[IP].chksum = 0xffff

        print("Sending packet with invalid checksum")
        send_packet(self, self.oport_dev, pkt)
        verify_no_other_packets(self)
        print("\tDropped")

    def tunnelEncapInvalidSrcIpTest(self):
        '''
        Verify if encapsulated packets with invalid source IP addresses
        are dropped
        '''
        print("\ntunnelEncapInvalidSrcIpTest()")

        mcast_ip = "225.1.1.1"
        lpb_ip = "127.0.0.1"

        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=self.customer_mac,
                                ip_dst=self.vm_ip,
                                ip_id=108,
                                ip_ttl=64)

        pkt[IP].src = mcast_ip

        print("Sending packet with IPv4 multicast src address")
        send_packet(self, self.oport_dev, pkt)
        verify_no_other_packets(self)
        print("\tDropped")

        pkt[IP].src = lpb_ip

        print("Sending packet with IPv4 loopback src address")
        send_packet(self, self.oport_dev, pkt)
        verify_no_other_packets(self)
        print("\tDropped")

        mcast_ipv6 = "ff02::2"

        pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                  eth_src=self.customer_mac,
                                  ipv6_dst=self.vm_ipv6,
                                  ipv6_src=mcast_ipv6,
                                  ipv6_hlim=64)

        print("Sending packet with IPv6 multicast src address")
        send_packet(self, self.oport_dev, pkt)
        verify_no_other_packets(self)
        print("\tDropped")

    def tunnelEncapInvalidIpv4MtuTest(self):
        '''
        Verify if encapsulated IPv4 packet with invalid size is dropped
        '''
        print("\ntunnelEncapInvalidIpv4MtuTest()")

        orif_mtu = sai_thrift_get_router_interface_attribute(self.client,
                                                             self.orif,
                                                             mtu=True)["mtu"]
        urif_mtu = sai_thrift_get_router_interface_attribute(self.client,
                                                             self.urif,
                                                             mtu=True)["mtu"]

        if self.ipv6 is False:
            pkt = simple_vxlan_packet(inner_frame=simple_udp_packet())
        else:
            pkt = simple_vxlanv6_packet(inner_frame=simple_udp_packet())

        mtu_offset = len(pkt) - len(simple_udp_packet())
        overlay_mtu = 200
        underlay_mtu = overlay_mtu + mtu_offset - 1

        try:
            status = sai_thrift_set_router_interface_attribute(
                self.client, self.orif, mtu=overlay_mtu)
            self.assertEqual(status, SAI_STATUS_SUCCESS)

            status = sai_thrift_set_router_interface_attribute(
                self.client, self.urif, mtu=underlay_mtu)
            self.assertEqual(status, SAI_STATUS_SUCCESS)

            # Currently v6_mtu_check in the dataplane uses ipv6 header payload
            # length field for v6 mtu check. This field does not account for
            # the 40 bytes of fixed IPv6 header fields.
            if self.ipv6 is True:
                overlay_mtu += 40

            # overlay_pkt_size < overlay_mtu < underlay_pkt_size < underlay_mtu
            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.customer_mac,
                                    ip_dst=self.vm_ip,
                                    ip_src=self.customer_ip,
                                    ip_id=108,
                                    ip_ttl=64,
                                    pktlen=overlay_mtu - 2 + 14)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.vm_ip,
                                          ip_src=self.customer_ip,
                                          ip_id=108,
                                          ip_ttl=63,
                                          pktlen=overlay_mtu - 2 + 14)
            if self.ipv6 is False:
                vxlan_pkt = Mask(
                    simple_vxlan_packet(eth_dst=self.unbor_mac,
                                        eth_src=ROUTER_MAC,
                                        ip_dst=self.tun_ip,
                                        ip_src=self.lpb_ip,
                                        ip_id=0,
                                        ip_ttl=64,
                                        ip_flags=0x2,
                                        with_udp_chksum=False,
                                        vxlan_vni=self.vni,
                                        inner_frame=inner_pkt))
            else:
                vxlan_pkt = Mask(
                    simple_vxlanv6_packet(eth_dst=self.unbor_mac,
                                          eth_src=ROUTER_MAC,
                                          ipv6_dst=self.tun_ip,
                                          ipv6_src=self.lpb_ip,
                                          ipv6_hlim=64,
                                          with_udp_chksum=False,
                                          vxlan_vni=self.vni,
                                          inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

            print("Sending packet with size lower than MTU")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, vxlan_pkt, self.uport_dev)
            print("\tOK")

            # overlay_pkt_size < overlay_mtu < underlay_pkt_size = underlay_mtu
            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.customer_mac,
                                    ip_dst=self.vm_ip,
                                    ip_src=self.customer_ip,
                                    ip_id=108,
                                    ip_ttl=64,
                                    pktlen=overlay_mtu - 1 + 14)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.vm_ip,
                                          ip_src=self.customer_ip,
                                          ip_id=108,
                                          ip_ttl=63,
                                          pktlen=overlay_mtu - 1 + 14)
            if self.ipv6 is False:
                vxlan_pkt = Mask(
                    simple_vxlan_packet(eth_dst=self.unbor_mac,
                                        eth_src=ROUTER_MAC,
                                        ip_dst=self.tun_ip,
                                        ip_src=self.lpb_ip,
                                        ip_id=0,
                                        ip_ttl=64,
                                        ip_flags=0x2,
                                        with_udp_chksum=False,
                                        vxlan_vni=self.vni,
                                        inner_frame=inner_pkt))
            else:
                vxlan_pkt = Mask(
                    simple_vxlanv6_packet(eth_dst=self.unbor_mac,
                                          eth_src=ROUTER_MAC,
                                          ipv6_dst=self.tun_ip,
                                          ipv6_src=self.lpb_ip,
                                          ipv6_hlim=64,
                                          with_udp_chksum=False,
                                          vxlan_vni=self.vni,
                                          inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

            print("Sending packet with size equal to MTU")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, vxlan_pkt, self.uport_dev)
            print("\tOK")

            # overlay_pkt_size < overlay_mtu < underlay_mtu < underlay_pkt_size
            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.customer_mac,
                                    ip_dst=self.vm_ip,
                                    ip_src=self.customer_ip,
                                    ip_id=108,
                                    ip_ttl=64,
                                    pktlen=overlay_mtu + 14)

            print("Sending packet with size bigger than MTU")
            send_packet(self, self.oport_dev, pkt)
            verify_no_other_packets(self)
            print("\tDropped")

        finally:
            sai_thrift_set_router_interface_attribute(self.client,
                                                      self.orif,
                                                      mtu=orif_mtu)

            sai_thrift_set_router_interface_attribute(self.client,
                                                      self.urif,
                                                      mtu=urif_mtu)

    def tunnelEncapInvalidHlimTest(self):
        '''
        Verify if encapsulated packets with invalid Hop limit is dropped
        '''
        print("\ntunnelEncapInvalidHlimTest()")

        pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                  eth_src=self.customer_mac,
                                  ipv6_dst=self.vm_ipv6,
                                  ipv6_src=self.customer_ipv6,
                                  ipv6_hlim=0)

        print("Sending IPv6 packet with invalid Hop limit=0")
        send_packet(self, self.oport_dev, pkt)
        verify_no_other_packets(self)
        print("\tDropped")

    def tunnelEncapInvalidIpv6MtuTest(self):
        '''
        Verify if encapsulated IPv6 packet with invalid size is dropped
        '''
        print("\ntunnelEncapInvalidIpv6MtuTest()")

        orif_mtu = sai_thrift_get_router_interface_attribute(self.client,
                                                             self.orif,
                                                             mtu=True)["mtu"]
        urif_mtu = sai_thrift_get_router_interface_attribute(self.client,
                                                             self.urif,
                                                             mtu=True)["mtu"]
        if self.ipv6 is False:
            pkt = simple_vxlan_packet(inner_frame=simple_udpv6_packet())
        else:
            pkt = simple_vxlanv6_packet(inner_frame=simple_udpv6_packet())

        mtu_offset = len(pkt) - len(simple_udpv6_packet())
        overlay_mtu = 500
        underlay_mtu = overlay_mtu + mtu_offset - 1

        try:
            status = sai_thrift_set_router_interface_attribute(
                self.client, self.orif, mtu=overlay_mtu)
            self.assertEqual(status, SAI_STATUS_SUCCESS)

            status = sai_thrift_set_router_interface_attribute(
                self.client, self.urif, mtu=underlay_mtu)
            self.assertEqual(status, SAI_STATUS_SUCCESS)

            # Currently v6_mtu_check in the dataplane uses ipv6 header payload
            # length field for v6 mtu check. This field does not account for
            # the 40 bytes of fixed IPv6 header fields.
            if self.ipv6 is True:
                overlay_mtu += 40

            # overlay_pkt_size < overlay_mtu < underlay_pkt_size < underlay_mtu
            pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.customer_mac,
                                      ipv6_dst=self.vm_ipv6,
                                      ipv6_src=self.customer_ipv6,
                                      ipv6_hlim=64,
                                      pktlen=overlay_mtu - 2 + 14)
            inner_pkt = simple_udpv6_packet(eth_dst=self.inner_dmac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_dst=self.vm_ipv6,
                                            ipv6_src=self.customer_ipv6,
                                            ipv6_hlim=63,
                                            pktlen=overlay_mtu - 2 + 14)
            if self.ipv6 is False:
                vxlan_pkt = Mask(
                    simple_vxlan_packet(eth_dst=self.unbor_mac,
                                        eth_src=ROUTER_MAC,
                                        ip_dst=self.tun_ip,
                                        ip_src=self.lpb_ip,
                                        ip_id=0,
                                        ip_ttl=64,
                                        ip_flags=0x2,
                                        with_udp_chksum=False,
                                        vxlan_vni=self.vni,
                                        inner_frame=inner_pkt))
            else:
                vxlan_pkt = Mask(
                    simple_vxlanv6_packet(eth_dst=self.unbor_mac,
                                          eth_src=ROUTER_MAC,
                                          ipv6_dst=self.tun_ip,
                                          ipv6_src=self.lpb_ip,
                                          ipv6_hlim=64,
                                          with_udp_chksum=False,
                                          vxlan_vni=self.vni,
                                          inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

            print("Sending packet with size lower than MTU")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, vxlan_pkt, self.uport_dev)
            print("\tOK")

            # overlay_pkt_size < overlay_mtu < underlay_pkt_size = underlay_mtu
            pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.customer_mac,
                                      ipv6_dst=self.vm_ipv6,
                                      ipv6_src=self.customer_ipv6,
                                      ipv6_hlim=64,
                                      pktlen=overlay_mtu - 1 + 14)
            inner_pkt = simple_udpv6_packet(eth_dst=self.inner_dmac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_dst=self.vm_ipv6,
                                            ipv6_src=self.customer_ipv6,
                                            ipv6_hlim=63,
                                            pktlen=overlay_mtu - 1 + 14)
            if self.ipv6 is False:
                vxlan_pkt = Mask(
                    simple_vxlan_packet(eth_dst=self.unbor_mac,
                                        eth_src=ROUTER_MAC,
                                        ip_dst=self.tun_ip,
                                        ip_src=self.lpb_ip,
                                        ip_id=0,
                                        ip_ttl=64,
                                        ip_flags=0x2,
                                        with_udp_chksum=False,
                                        vxlan_vni=self.vni,
                                        inner_frame=inner_pkt))
            else:
                vxlan_pkt = Mask(
                    simple_vxlanv6_packet(eth_dst=self.unbor_mac,
                                          eth_src=ROUTER_MAC,
                                          ipv6_dst=self.tun_ip,
                                          ipv6_src=self.lpb_ip,
                                          ipv6_hlim=64,
                                          with_udp_chksum=False,
                                          vxlan_vni=self.vni,
                                          inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

            print("Sending packet with size equal to MTU")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, vxlan_pkt, self.uport_dev)
            print("\tOK")

            # overlay_pkt_size < overlay_mtu < underlay_mtu < underlay_pkt_size
            pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.customer_mac,
                                      ipv6_dst=self.vm_ipv6,
                                      ipv6_src=self.customer_ipv6,
                                      ipv6_hlim=64,
                                      pktlen=overlay_mtu + 14)

            print("Sending packet with size bigger than MTU")
            send_packet(self, self.oport_dev, pkt)
            verify_no_other_packets(self)
            print("\tDropped")

        finally:
            sai_thrift_set_router_interface_attribute(self.client,
                                                      self.orif,
                                                      mtu=orif_mtu)

            sai_thrift_set_router_interface_attribute(self.client,
                                                      self.urif,
                                                      mtu=urif_mtu)


@group("draft")
class TunnelMalformedEncapPacketsIpv4UnderlayTest(
        TunnelMalformedEncapPacketsBase):
    '''
    Tests regarding different cases of malformed encap packets
    with IPv4 underlay
    '''

    def runTest(self):
        self.tunnelEncapInvalidIpVersionTest()
        self.tunnelEncapInvalidIhlTest()
        self.tunnelEncapInvalidTtlTest()
        self.tunnelEncapInvalidChksumTest()
        self.tunnelEncapInvalidSrcIpTest()
        self.tunnelEncapInvalidIpv4MtuTest()
        self.tunnelEncapInvalidHlimTest()
        self.tunnelEncapInvalidIpv6MtuTest()


@group("draft")
class TunnelMalformedEncapPacketsIpv6UnderlayTest(
        TunnelMalformedEncapPacketsBase):
    '''
    Tests regarding different cases of malformed encap packets with
    IPv6 underlay
    '''

    def __init__(self):
        super(TunnelMalformedEncapPacketsIpv6UnderlayTest, self).__init__(
            ipv6=True)

    def runTest(self):
        self.tunnelEncapInvalidIpVersionTest()
        self.tunnelEncapInvalidIhlTest()
        self.tunnelEncapInvalidTtlTest()
        self.tunnelEncapInvalidChksumTest()
        self.tunnelEncapInvalidSrcIpTest()
        self.tunnelEncapInvalidIpv4MtuTest()
        self.tunnelEncapInvalidHlimTest()
        self.tunnelEncapInvalidIpv6MtuTest()


@group("draft")
class TunnelMalformedDecapPacketsBase(VxLanBaseSetup):
    '''
    Tests regarding different cases of malformed decap packets

    Args:
        ipv6 (bool): ipv6 underlay configuraton indicator
    '''

    def __init__(self, ipv6=False):
        super(TunnelMalformedDecapPacketsBase, self).__init__(ipv6=ipv6)

    def tunnelInvalidInnerSmacTest(self):
        '''
        Verify if packets with invalid SMACs in inner ethernet header
        is dropped
        '''
        print("\ntunnelInvalidInnerSmacTest()")

        zeroed_mac = "00:00:00:00:00:00"
        bcast_mac = "ff:ff:ff:ff:ff:ff"
        mcast_mac = "01:00:5e:00:00:05"

        inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                      eth_src=zeroed_mac,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=64)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=self.tun_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Sending packet with zeroed SMAC in inner header")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

        inner_pkt[Ether].src = bcast_mac

        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=self.tun_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Sending packet with broadcast SMAC in inner header")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

        inner_pkt[Ether].src = mcast_mac

        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=self.tun_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Sending packet with multicast SMAC in inner header")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

    def tunnelInvalidInnerDmacTest(self):
        '''
        Verify if packets with invalid DMAC in inner ethernet header is dropped
        '''
        print("\ntunnelZeroedInnerDmacDropTest()")

        dst_mac = "00:00:00:00:00:00"

        inner_pkt = simple_udp_packet(eth_dst=dst_mac,
                                      eth_src=self.inner_dmac,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=64)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=self.tun_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Sending packet with zeroed DMAC in inner header")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

    def tunnelDecapInvalidInnerDmacTest(self):
        '''
        Verify if decapsulated packet with invalid DMAC in inner packet
        not equal to router MAC is dropped
        '''
        print("\ntunnelDecapInvalidInnerDmacTest()")

        non_router_mac = "00:77:66:55:44:33:22"

        inner_pkt_v4 = simple_udp_packet(eth_dst=non_router_mac,
                                         eth_src=self.inner_dmac,
                                         ip_dst=self.customer_ip,
                                         ip_src=self.vm_ip,
                                         ip_id=108,
                                         ip_ttl=64)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt_v4)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=self.tun_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt_v4)

        print("Sending VXLAN packet with invalid inner IPv4 packet DMAC")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

        inner_pkt_v6 = simple_udpv6_packet(eth_dst=non_router_mac,
                                           eth_src=self.inner_dmac,
                                           ipv6_dst=self.customer_ipv6,
                                           ipv6_src=self.vm_ipv6,
                                           ipv6_hlim=64)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt_v6)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=self.tun_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt_v6)

        print("Sending VXLAN packet with invalid inner IPv6 packet DMAC")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

    def tunnelDecapInvalidInnerIpVersionTest(self):
        '''
        Verify if decapsulated packet with invalid version in inner packet
        header is dropped
        '''
        print("\ntunnelDecapInvalidInnerIpVersionTest()")

        inner_pkt_v4 = simple_udp_packet(eth_dst=ROUTER_MAC,
                                         eth_src=self.inner_dmac,
                                         ip_dst=self.customer_ip,
                                         ip_src=self.vm_ip,
                                         ip_id=108,
                                         ip_ttl=64)

        inner_pkt_v4[IP].version = 6

        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt_v4)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=self.tun_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt_v4)

        print("Sending VXLAN packet with invalid inner IPv4 packet IP version")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

        inner_pkt_v6 = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                           eth_src=self.inner_dmac,
                                           ipv6_dst=self.customer_ipv6,
                                           ipv6_src=self.vm_ipv6,
                                           ipv6_hlim=64)

        inner_pkt_v6[IPv6].version = 4

        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt_v6)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=self.tun_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt_v6)

        print("Sending packet with invalid inner IPv6 packet IP version")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

    def tunnelDecapInvalidInnerIhlTest(self):
        '''
        Verify if decapsulated packet with invalid IHL values in inner packet
        is dropped
        '''
        print("\ntunnelDecapInvalidInnerIhlTest()")

        inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.inner_dmac,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=64)

        for i in range(5):
            inner_pkt[IP].ihl = i

            if self.ipv6 is False:
                vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                                eth_src=self.unbor_mac,
                                                ip_dst=self.lpb_ip,
                                                ip_src=self.tun_ip,
                                                ip_id=0,
                                                ip_ttl=64,
                                                ip_flags=0x2,
                                                udp_sport=11638,
                                                with_udp_chksum=False,
                                                vxlan_vni=self.vni,
                                                inner_frame=inner_pkt)
            else:
                vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                                  eth_src=self.unbor_mac,
                                                  ipv6_dst=self.lpb_ip,
                                                  ipv6_src=self.tun_ip,
                                                  ipv6_hlim=64,
                                                  udp_sport=11638,
                                                  with_udp_chksum=False,
                                                  vxlan_vni=self.vni,
                                                  inner_frame=inner_pkt)

            print("Sending VXLAN packet with invalid inner packet IHL=%d" %
                  inner_pkt[IP].ihl)
            send_packet(self, self.uport_dev, vxlan_pkt)
            verify_no_other_packets(self)
            print("\tDropped")

    def tunnelDecapInvalidInnerTtlTest(self):
        '''
        Verify if decapsulated packet with invalid TTL value in inner packet
        is dropped
        '''
        print("\ntunnelDecapInvalidInnerTtlTest()")

        inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.inner_dmac,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=0)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=self.tun_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Sending VXLAN packet with invalid inner packet TTL=0")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

    def tunnelDecapInvalidInnerChksumTest(self):
        '''
        Verify if decapsulated packet with invalid checksum in inner packet
        is dropped
        '''
        print("\ntunnelDecapInvalidInnerChksumTest()")

        inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.inner_dmac,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=64,
                                      with_udp_chksum=True)

        inner_pkt[IP].chksum = 0xffff

        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=True,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=self.tun_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Sending VXLAN packet with invalid inner packet checksum")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

    def tunnelDecapInvalidInnerSrcIpTest(self):
        '''
        Verify if decapsulated packets with invalid source IP addresses
        in inner packet are dropped
        '''
        print("\ntunnelDecapInvalidInnerSrcIpTest()")

        mcast_ip = "225.1.1.1"
        lpb_ip = "127.0.0.1"
        mcast_ipv6 = "ff02::2"
        lpb_ipv6 = "::1"

        inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.inner_dmac,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=64)

        inner_pkt[IP].src = mcast_ip

        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=self.tun_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Sending VXLAN packet with inner packet multicast src IP")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

        inner_pkt[IP].src = lpb_ip

        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=self.tun_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Sending packet with loopback src IPv4")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

        inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.inner_dmac,
                                        ipv6_dst=self.customer_ipv6,
                                        ipv6_src=self.vm_ipv6,
                                        ipv6_hlim=64)

        inner_pkt[IPv6].src = mcast_ipv6

        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=self.tun_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Sending VXLAN packet with inner IPv6 packet multicast src IP")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

        inner_pkt[IPv6].src = lpb_ipv6

        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=self.tun_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Sending IPv6 packet with loopback src IPv6")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

    def tunnelDecapInvalidInnerHlimTest(self):
        '''
        Verify if decapsulated packet with invalid Hop limit in inner packet
        is dropped
        '''
        print("\ntunnelDecapInvalidInnerHlimTest()")

        inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.inner_dmac,
                                        ipv6_dst=self.customer_ipv6,
                                        ipv6_src=self.vm_ipv6,
                                        ipv6_hlim=0)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=self.tun_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Sending VXLAN packet with invalid inner packet Hop limit=0")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

    def tunnelDecapInvalidOuterIpVersionTest(self):
        '''
        Verify if decapsulated IP packet with invalid version in outer packet
        is dropped
        '''
        print("\ntunnelDecapInvalidOuterIpVersionTest()")

        inner_pkt_v4 = simple_udp_packet(eth_dst=ROUTER_MAC,
                                         eth_src=self.inner_dmac,
                                         ip_dst=self.customer_ip,
                                         ip_src=self.vm_ip,
                                         ip_id=108,
                                         ip_ttl=64)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt_v4)
            vxlan_pkt[IP].version = 6
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=self.tun_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt_v4)
            vxlan_pkt[IPv6].version = 4

        print("Sending VXLAN packet with invalid outer IP version "
              "and inner IPv4 packet")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

        inner_pkt_v6 = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                           eth_src=self.inner_dmac,
                                           ipv6_dst=self.customer_ipv6,
                                           ipv6_src=self.vm_ipv6,
                                           ipv6_hlim=64)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt_v6)
            vxlan_pkt[IP].version = 6
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=self.tun_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt_v6)
            vxlan_pkt[IPv6].version = 4

        print("Sending VXLAN packet with invalid outer IP version "
              "and inner IPv6 packet")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

    def tunnelDecapInvalidOuterIhlTest(self):
        '''
        Verify if decapsulated packet with invalid IHL values in outer packet
        is dropped
        '''
        print("\ntunnelDecapInvalidOuterIhlTest()")

        if self.ipv6 is True:
            print("Test valid only for IPv4 underlay")
            return

        inner_pkt_v4 = simple_udp_packet(eth_dst=ROUTER_MAC,
                                         eth_src=self.inner_dmac,
                                         ip_dst=self.customer_ip,
                                         ip_src=self.vm_ip,
                                         ip_id=108,
                                         ip_ttl=64)
        vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.unbor_mac,
                                        ip_dst=self.lpb_ip,
                                        ip_src=self.tun_ip,
                                        ip_id=0,
                                        ip_ttl=64,
                                        ip_flags=0x2,
                                        udp_sport=11638,
                                        with_udp_chksum=False,
                                        vxlan_vni=self.vni,
                                        inner_frame=inner_pkt_v4)

        for i in range(5):
            vxlan_pkt[IP].ihl = i

            print("Sending VXLAN packet with invalid IHL=%d "
                  "and IPv4 inner packet" % vxlan_pkt[IP].ihl)
            send_packet(self, self.uport_dev, vxlan_pkt)
            verify_no_other_packets(self)
            print("\tDropped")

        inner_pkt_v6 = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                           eth_src=self.inner_dmac,
                                           ipv6_dst=self.customer_ipv6,
                                           ipv6_src=self.vm_ipv6,
                                           ipv6_hlim=64)
        vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.unbor_mac,
                                        ip_dst=self.lpb_ip,
                                        ip_src=self.tun_ip,
                                        ip_id=0,
                                        ip_ttl=64,
                                        ip_flags=0x2,
                                        udp_sport=11638,
                                        with_udp_chksum=False,
                                        vxlan_vni=self.vni,
                                        inner_frame=inner_pkt_v6)

        for i in range(5):
            vxlan_pkt[IP].ihl = i

            print("Sending VXLAN packet with invalid IHL=%d "
                  "and IPv6 inner packet" % vxlan_pkt[IP].ihl)
            send_packet(self, self.uport_dev, vxlan_pkt)
            verify_no_other_packets(self)
            print("\tDropped")

    def tunnelDecapInvalidOuterTtlTest(self):
        '''
        Verify if decapsulated packet with invalid TTL value in outer packet
        is dropped
        '''
        print("\ntunnelDecapInvalidOuterTtlTest()")

        if self.ipv6 is True:
            print("Test valid only for IPv4 underlay")
            return

        inner_pkt_v4 = simple_udp_packet(eth_dst=ROUTER_MAC,
                                         eth_src=self.inner_dmac,
                                         ip_dst=self.customer_ip,
                                         ip_src=self.vm_ip,
                                         ip_id=108,
                                         ip_ttl=64)
        vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.unbor_mac,
                                        ip_dst=self.lpb_ip,
                                        ip_src=self.tun_ip,
                                        ip_id=0,
                                        ip_ttl=0,
                                        ip_flags=0x2,
                                        udp_sport=11638,
                                        with_udp_chksum=False,
                                        vxlan_vni=self.vni,
                                        inner_frame=inner_pkt_v4)

        print("Sending VXLAN packet with invalid TTL=0 and IPv4 inner packet")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

        inner_pkt_v6 = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                           eth_src=self.inner_dmac,
                                           ipv6_dst=self.customer_ipv6,
                                           ipv6_src=self.vm_ipv6,
                                           ipv6_hlim=64)
        vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.unbor_mac,
                                        ip_dst=self.lpb_ip,
                                        ip_src=self.tun_ip,
                                        ip_id=0,
                                        ip_ttl=0,
                                        ip_flags=0x2,
                                        udp_sport=11638,
                                        with_udp_chksum=False,
                                        vxlan_vni=self.vni,
                                        inner_frame=inner_pkt_v6)

        print("Sending VXLAN packet with invalid TTL=0 and IPv6 inner packet")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

    def tunnelDecapInvalidOuterChksumTest(self):
        '''
        Verify if decapsulated packet with invalid checksum in outer packet
        is dropped
        '''
        print("\ntunnelDecapInvalidOuterChksumTest()")

        if self.ipv6 is True:
            print("Test valid only for IPv4 underlay")
            return

        inner_pkt_v4 = simple_udp_packet(eth_dst=ROUTER_MAC,
                                         eth_src=self.inner_dmac,
                                         ip_dst=self.customer_ip,
                                         ip_src=self.vm_ip,
                                         ip_id=108,
                                         ip_ttl=64)
        vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.unbor_mac,
                                        ip_dst=self.lpb_ip,
                                        ip_src=self.tun_ip,
                                        ip_id=0,
                                        ip_ttl=64,
                                        ip_flags=0x2,
                                        udp_sport=11638,
                                        with_udp_chksum=False,
                                        vxlan_vni=self.vni,
                                        inner_frame=inner_pkt_v4)

        vxlan_pkt[IP].chksum = 0xffff

        print("Sending VXLAN packet with invalid checksum=0 "
              "and IPv4 inner packet")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

        inner_pkt_v6 = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                           eth_src=self.inner_dmac,
                                           ipv6_dst=self.customer_ipv6,
                                           ipv6_src=self.vm_ipv6,
                                           ipv6_hlim=64)
        vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.unbor_mac,
                                        ip_dst=self.lpb_ip,
                                        ip_src=self.tun_ip,
                                        ip_id=0,
                                        ip_ttl=64,
                                        ip_flags=0x2,
                                        udp_sport=11638,
                                        with_udp_chksum=False,
                                        vxlan_vni=self.vni,
                                        inner_frame=inner_pkt_v6)

        vxlan_pkt[IP].chksum = 0xffff

        print("Sending VXLAN packet with invalid checksum=0 "
              "and IPv6 inner packet")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

    def tunnelDecapInvalidOuterSrcIpTest(self):
        '''
        Verify if decapsulated packets with invalid source IP addresses
        in outer packet are dropped
        '''
        print("\ntunnelDecapInvalidOuterSrcIpTest()")

        if self.ipv6 is False:
            mcast_ip = "225.1.1.1"
            lpb_ip = "127.0.0.1"
        else:
            mcast_ip = "ff02::2"

        inner_pkt_v4 = simple_udp_packet(eth_dst=ROUTER_MAC,
                                         eth_src=self.inner_dmac,
                                         ip_dst=self.customer_ip,
                                         ip_src=self.vm_ip,
                                         ip_id=108,
                                         ip_ttl=64)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt_v4)
            vxlan_pkt[IP].src = mcast_ip
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt_v4)
            vxlan_pkt[IPv6].src = mcast_ip

        print("Sending packet with multicast src IP and IPv4 inner packet")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

        if self.ipv6 is False:
            vxlan_pkt[IP].src = lpb_ip

            print("Sending packet with loopback src IP and IPv4 inner packet")
            send_packet(self, self.uport_dev, vxlan_pkt)
            verify_no_other_packets(self)
            print("\tDropped")

        inner_pkt_v6 = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                           eth_src=self.inner_dmac,
                                           ipv6_dst=self.customer_ipv6,
                                           ipv6_src=self.vm_ipv6,
                                           ipv6_hlim=64)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt_v6)
            vxlan_pkt[IP].src = mcast_ip
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac,
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=self.tun_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt_v6)
            vxlan_pkt[IPv6].src = mcast_ip

        print("Sending packet with multicast src IP and IPv6 inner packet")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

        if self.ipv6 is False:
            vxlan_pkt[IP].src = lpb_ip

            print("Sending packet with loopback src IP and IPv6 inner packet")
            send_packet(self, self.uport_dev, vxlan_pkt)
            verify_no_other_packets(self)
            print("\tDropped")

    def tunnelDecapInvalidOuterHlimTest(self):
        '''
        Verify if decapsulated packet with invalid Hop limit in outer packet
        is dropped
        '''
        print("\ntunnelDecapInvalidOuterHlimTest()")

        if self.ipv6 is False:
            print("Test valid only for IPv6 underlay")
            return

        inner_pkt_v4 = simple_udp_packet(eth_dst=ROUTER_MAC,
                                         eth_src=self.inner_dmac,
                                         ip_dst=self.customer_ip,
                                         ip_src=self.vm_ip,
                                         ip_id=108,
                                         ip_ttl=64)
        vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                          eth_src=self.unbor_mac,
                                          ipv6_dst=self.lpb_ip,
                                          ipv6_src=self.tun_ip,
                                          ipv6_hlim=0,
                                          udp_sport=11638,
                                          with_udp_chksum=False,
                                          vxlan_vni=self.vni,
                                          inner_frame=inner_pkt_v4)

        print("Sending VXLAN packet with invalid Hop limit "
              "and inner IPv4 packet")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

        inner_pkt_v6 = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                           eth_src=self.inner_dmac,
                                           ipv6_dst=self.customer_ipv6,
                                           ipv6_src=self.vm_ipv6,
                                           ipv6_hlim=64)
        vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                          eth_src=self.unbor_mac,
                                          ipv6_dst=self.lpb_ip,
                                          ipv6_src=self.tun_ip,
                                          ipv6_hlim=0,
                                          udp_sport=11638,
                                          with_udp_chksum=False,
                                          vxlan_vni=self.vni,
                                          inner_frame=inner_pkt_v6)

        print("Sending VXLAN packet with invalid Hop limit "
              "and inner IPv6 packet")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")


@group("draft")
class TunnelMalformedDecapPacketsIpv4UnderlayTest(
        TunnelMalformedDecapPacketsBase):
    '''
    Tests regarding different cases of malformed decap
    packets with underlay layer configured with IPv4
    '''

    def runTest(self):
        self.tunnelInvalidInnerSmacTest()
        self.tunnelInvalidInnerDmacTest()
        self.tunnelDecapInvalidInnerDmacTest()
        self.tunnelDecapInvalidInnerIpVersionTest()
        self.tunnelDecapInvalidInnerIhlTest()
        self.tunnelDecapInvalidInnerTtlTest()
        self.tunnelDecapInvalidInnerChksumTest()
        self.tunnelDecapInvalidInnerSrcIpTest()
        self.tunnelDecapInvalidInnerHlimTest()
        self.tunnelDecapInvalidOuterIpVersionTest()
        self.tunnelDecapInvalidOuterIhlTest()
        self.tunnelDecapInvalidOuterTtlTest()
        self.tunnelDecapInvalidOuterChksumTest()
        self.tunnelDecapInvalidOuterSrcIpTest()


@group("draft")
class TunnelMalformedDecapPacketsIpv6UnderlayTest(
        TunnelMalformedDecapPacketsBase):
    '''
    Tests regarding different cases of malformed decap
    packets with underlay layer configured with IPv6
    '''

    def __init__(self):
        super(TunnelMalformedDecapPacketsIpv6UnderlayTest, self).__init__(
            ipv6=True)

    def runTest(self):
        self.tunnelInvalidInnerSmacDropTest()
        self.tunnelInvalidInnerDmacTest()
        self.tunnelDecapInvalidInnerDmacTest()
        self.tunnelDecapInvalidInnerIpVersionTest()
        self.tunnelDecapInvalidInnerIhlTest()
        self.tunnelDecapInvalidInnerTtlTest()
        self.tunnelDecapInvalidInnerChksumTest()
        self.tunnelDecapInvalidInnerSrcIpTest()
        self.tunnelDecapInvalidInnerHlimTest()
        self.tunnelDecapInvalidOuterIpVersionTest()
        self.tunnelDecapInvalidOuterHlimTest()
        self.tunnelDecapInvalidOuterSrcIpTest()


# # # # # # # # # # VxLAN nexthop resolution tests follow # # # # # # # # # #
@group("draft")
class TunnelNhopResolutionBase(SaiHelper):
    '''
    Tests regarding different cases of nexthop resolution

    Args:
        ipv6 (bool): ipv6 underlay configuraton indicator
    '''

    def __init__(self, ipv6=False):
        super(TunnelNhopResolutionBase, self).__init__()
        self.ipv6 = ipv6

        if ipv6 is True:
            self.tun_ip1 = "2001:0db8::10:1"
            self.tun_ip2 = "2001:0db8::10:2"
            self.tun_ip3 = "2001:0db8::10:3"
            self.lpb_ip = "2001:0db8::10:10"
            self.tun_ip_mask = "/128"
            self.tun_ip_mask2 = "/112"
            self.tun_ip_mask3 = "/96"
        else:
            self.tun_ip1 = "10.10.10.1"
            self.tun_ip2 = "10.10.10.2"
            self.tun_ip3 = "10.10.10.3"
            self.lpb_ip = "10.10.10.10"
            self.tun_ip_mask = "/32"
            self.tun_ip_mask2 = "/24"
            self.tun_ip_mask3 = "/16"

    def setUp(self):
        super(TunnelNhopResolutionBase, self).setUp()

        self.oport = self.port24
        self.oport_dev = self.dev_port24

        self.vni = 1000
        self.vm_ip1 = "100.100.1.1"
        self.vm_ip2 = "100.100.1.2"
        self.vm_ipv61 = "2001:0db8::1:1"
        self.vm_ipv62 = "2001:0db8::1:2"
        self.customer_ip = "100.100.3.1"
        self.customer_ipv6 = "2001:0db8::2:1"
        self.inner_dmac1 = "00:11:11:11:11:11"
        self.inner_dmac2 = "00:11:11:11:11:22"
        self.inner_dmac3 = "00:11:11:11:11:33"
        self.customer_mac = "00:22:22:22:22:22"
        self.unbor_mac1 = "00:33:33:33:33:11"
        self.unbor_mac2 = "00:33:33:33:33:22"
        self.unbor_mac3 = "00:33:33:33:33:33"

        # underlay configuration
        self.uvrf = sai_thrift_create_virtual_router(self.client)

        # overlay configuraion
        self.ovrf = sai_thrift_create_virtual_router(self.client)
        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL

        # underlay loopback RIF for tunnel
        self.urif_lpb = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_LOOPBACK,
            virtual_router_id=self.uvrf)

        self.orif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.ovrf,
            port_id=self.oport)

        # encap/decap mappers
        self.encap_tunnel_map = sai_thrift_create_tunnel_map(
            self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

        self.decap_tunnel_map = sai_thrift_create_tunnel_map(
            self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

        # encap/decap mapper entries
        self.encap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
            self.client,
            tunnel_map=self.encap_tunnel_map,
            tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
            virtual_router_id_key=self.ovrf,
            vni_id_value=self.vni)

        self.decap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
            self.client,
            tunnel_map=self.encap_tunnel_map,
            tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
            virtual_router_id_value=self.ovrf,
            vni_id_key=self.vni)

        encap_maps = sai_thrift_object_list_t(count=1,
                                              idlist=[self.encap_tunnel_map])
        decap_maps = sai_thrift_object_list_t(count=1,
                                              idlist=[self.decap_tunnel_map])

        # tunnel
        self.tunnel = sai_thrift_create_tunnel(
            self.client,
            type=tunnel_type,
            encap_src_ip=sai_ipaddress(self.lpb_ip),
            encap_mappers=encap_maps,
            decap_mappers=decap_maps,
            encap_ttl_mode=ttl_mode,
            decap_ttl_mode=ttl_mode,
            underlay_interface=self.urif_lpb)

    def runTest(self):
        self.tunnelL3IntfTest()
        self.tunnelL3LagIntfTest()
        self.tunnelL3SubPortIntfTest()
        self.tunnelSviIntfTest()
        self.multiTunnelNhopTest()
        self.ecmpTunnelTest()
        self.underlayEcmpTunnelTest()

    def tearDown(self):
        sai_thrift_remove_tunnel(self.client, self.tunnel)
        sai_thrift_remove_tunnel_map_entry(
            self.client, self.decap_tunnel_map_entry)
        sai_thrift_remove_tunnel_map_entry(
            self.client, self.encap_tunnel_map_entry)
        sai_thrift_remove_tunnel_map(self.client, self.decap_tunnel_map)
        sai_thrift_remove_tunnel_map(self.client, self.encap_tunnel_map)
        sai_thrift_remove_router_interface(self.client, self.orif)
        sai_thrift_remove_router_interface(self.client, self.urif_lpb)
        sai_thrift_remove_virtual_router(self.client, self.ovrf)
        sai_thrift_remove_virtual_router(self.client, self.uvrf)

        super(TunnelNhopResolutionBase, self).tearDown()

    # Helper functions for traffic verification
    def _v4TrafficTest(self, rcv_ports, pkt_data=None):
        '''
        A helper function for checking packet forwarding

        Args:
            rcv_ports (list): a list of underlay port device numbers
            pkt_data (dict): a dictionary with necessary packets data
                             allowed keys are: dmac - destination MAC
                                               idmac - inner DMAC
                                               dst_ip - destimation IP
                                               tun_ip - tunnel IP
                                               vni - tunnel VNI
                                               vlan_no - VLAN number
        '''
        dmac = self.unbor_mac1
        idmac = self.inner_dmac1
        dst_ip = self.vm_ip1
        tun_ip = self.tun_ip1
        vni = self.vni

        vlan_enable = False
        vlan_no = 0

        if pkt_data:
            if "dmac" in pkt_data:
                dmac = pkt_data['dmac']
            if "idmac" in pkt_data:
                idmac = pkt_data['idmac']
            if "dst_ip" in pkt_data:
                dst_ip = pkt_data['dst_ip']
            if "tun_ip" in pkt_data:
                tun_ip = pkt_data['tun_ip']
            if "vni" in pkt_data:
                vni = pkt_data['vni']

            if "vlan_no" in pkt_data and pkt_data['vlan_no'] != 0:
                vlan_enable = True
                vlan_no = pkt_data['vlan_no']

        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=self.customer_mac,
                                ip_dst=dst_ip,
                                ip_src=self.customer_ip,
                                ip_id=108,
                                ip_ttl=64)
        inner_pkt = simple_udp_packet(eth_dst=idmac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=dst_ip,
                                      ip_src=self.customer_ip,
                                      ip_id=108,
                                      ip_ttl=63)
        if self.ipv6 is False:
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=dmac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=tun_ip,
                                    ip_src=self.lpb_ip,
                                    ip_id=0,
                                    dl_vlan_enable=vlan_enable,
                                    vlan_vid=vlan_no,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=vni,
                                    inner_frame=inner_pkt))
        else:
            vxlan_pkt = Mask(
                simple_vxlanv6_packet(eth_dst=dmac,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=tun_ip,
                                      ipv6_src=self.lpb_ip,
                                      dl_vlan_enable=vlan_enable,
                                      vlan_vid=vlan_no,
                                      ipv6_hlim=64,
                                      with_udp_chksum=False,
                                      vxlan_vni=vni,
                                      inner_frame=inner_pkt))
        vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

        print("Sending IPv4 packet")
        send_packet(self, self.oport_dev, pkt)
        verify_packet_any_port(self, vxlan_pkt, rcv_ports)
        print("\tOK")

    def _v6TrafficTest(self, rcv_ports, pkt_data=None):
        '''
        A helper function for checking packet forwarding

        Args:
            rcv_ports (list): a list of underlay port device numbers
            pkt_data (dict): a dictionary with necessary packets data
                             allowed keys are: dmac - destination MAC
                                               idmac - inner DMAC
                                               dst_ip - destimation IP
                                               tun_ip - tunnel IP
                                               vni - tunnel VNI
                                               vlan_no - VLAN number
        '''
        dmac = self.unbor_mac1
        idmac = self.inner_dmac1
        dst_ip = self.vm_ipv61
        tun_ip = self.tun_ip1
        vni = self.vni

        vlan_enable = False
        vlan_no = 0

        if pkt_data:
            if "dmac" in pkt_data:
                dmac = pkt_data['dmac']
            if "idmac" in pkt_data:
                idmac = pkt_data['idmac']
            if "dst_ip" in pkt_data:
                dst_ip = pkt_data['dst_ip']
            if "tun_ip" in pkt_data:
                tun_ip = pkt_data['tun_ip']
            if "vni" in pkt_data:
                vni = pkt_data['vni']

            if "vlan_no" in pkt_data and pkt_data['vlan_no'] != 0:
                vlan_enable = True
                vlan_no = pkt_data['vlan_no']

        pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                  eth_src=self.customer_mac,
                                  ipv6_dst=dst_ip,
                                  ipv6_src=self.customer_ipv6,
                                  ipv6_hlim=64)
        inner_pkt = simple_udpv6_packet(eth_dst=idmac,
                                        eth_src=ROUTER_MAC,
                                        ipv6_dst=dst_ip,
                                        ipv6_src=self.customer_ipv6,
                                        ipv6_hlim=63)
        if self.ipv6 is False:
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=dmac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=tun_ip,
                                    ip_src=self.lpb_ip,
                                    ip_id=0,
                                    dl_vlan_enable=vlan_enable,
                                    vlan_vid=vlan_no,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=vni,
                                    inner_frame=inner_pkt))
        else:
            vxlan_pkt = Mask(
                simple_vxlanv6_packet(eth_dst=dmac,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=tun_ip,
                                      ipv6_src=self.lpb_ip,
                                      dl_vlan_enable=vlan_enable,
                                      vlan_vid=vlan_no,
                                      ipv6_hlim=64,
                                      with_udp_chksum=False,
                                      vxlan_vni=vni,
                                      inner_frame=inner_pkt))
        vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

        print("Sending IPv6 packet")
        send_packet(self, self.oport_dev, pkt)
        verify_packet_any_port(self, vxlan_pkt, rcv_ports)
        print("\tOK")

    def _v4TrafficMissTest(self):
        '''
        A helper function for checking packet forwarding
        '''
        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=self.customer_mac,
                                ip_dst=self.vm_ip1,
                                ip_src=self.customer_ip,
                                ip_id=108,
                                ip_ttl=64)

        print("Sending IPv4 packet")
        send_packet(self, self.oport_dev, pkt)
        verify_no_other_packets(self)
        print("\tDropped")

    def _v6TrafficMissTest(self):
        '''
        A helper function for checking packet forwarding
        '''
        pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                  eth_src=self.customer_mac,
                                  ipv6_dst=self.vm_ipv61,
                                  ipv6_src=self.customer_ipv6,
                                  ipv6_hlim=64)

        print("Sending IPv6 packet")
        send_packet(self, self.oport_dev, pkt)
        verify_no_other_packets(self)
        print("\tDropped")

    def _v4TrafficFloodTest(self, rcv_ports):
        '''
        A helper function for checking IPv4 packet flooding

        Args:
            rcv_ports (list): a list of underlay port device numbers
        '''

        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=self.customer_mac,
                                ip_dst=self.vm_ip1,
                                ip_src=self.customer_ip,
                                ip_id=108,
                                ip_ttl=64)
        inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac1,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.vm_ip1,
                                      ip_src=self.customer_ip,
                                      ip_id=108,
                                      ip_ttl=63)
        if self.ipv6 is False:
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor_mac1,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun_ip1,
                                    ip_src=self.lpb_ip,
                                    ip_id=0,
                                    dl_vlan_enable=False,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni,
                                    inner_frame=inner_pkt))
        else:
            vxlan_pkt = Mask(
                simple_vxlanv6_packet(eth_dst=self.unbor_mac1,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=self.tun_ip1,
                                      ipv6_src=self.lpb_ip,
                                      dl_vlan_enable=False,
                                      ipv6_hlim=64,
                                      with_udp_chksum=False,
                                      vxlan_vni=self.vni,
                                      inner_frame=inner_pkt))
        vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

        print("Sending IPv4 packet")
        send_packet(self, self.oport_dev, pkt)
        verify_each_packet_on_multiple_port_lists(self, vxlan_pkt, rcv_ports)
        print("\tFlooded")

    def _v6TrafficFloodTest(self, rcv_ports):
        '''
        A helper function for checking IPv6 packet flooding

        Args:
            rcv_ports (list): a list of underlay port device numbers
        '''

        pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                  eth_src=self.customer_mac,
                                  ipv6_dst=self.vm_ipv61,
                                  ipv6_src=self.customer_ipv6,
                                  ipv6_hlim=64)
        inner_pkt = simple_udpv6_packet(eth_dst=self.inner_dmac1,
                                        eth_src=ROUTER_MAC,
                                        ipv6_dst=self.vm_ipv61,
                                        ipv6_src=self.customer_ipv6,
                                        ipv6_hlim=63)
        if self.ipv6 is False:
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor_mac1,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun_ip1,
                                    ip_src=self.lpb_ip,
                                    ip_id=0,
                                    dl_vlan_enable=False,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni,
                                    inner_frame=inner_pkt))
        else:
            vxlan_pkt = Mask(
                simple_vxlanv6_packet(eth_dst=self.unbor_mac1,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=self.tun_ip1,
                                      ipv6_src=self.lpb_ip,
                                      dl_vlan_enable=False,
                                      ipv6_hlim=64,
                                      with_udp_chksum=False,
                                      vxlan_vni=self.vni,
                                      inner_frame=inner_pkt))
        vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

        print("Sending IPv6 packet")
        send_packet(self, self.oport_dev, pkt)
        verify_each_packet_on_multiple_port_lists(self, vxlan_pkt, rcv_ports)
        print("\tFlooded")

    def _v4TrafficEcmpTest(self, pkt_params):
        '''
        A helper function for checking IPv4 ECMP traffic

        Args:
            pkt_params (dict): a dictionary with port device numbers as keys
                               and a dictionary of packet parameters as values:
                               {port: {dmac, idmac, tun_ip}}
        '''

        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=self.customer_mac,
                                ip_dst=self.vm_ip1,
                                ip_src=self.customer_ip,
                                ip_id=108,
                                ip_ttl=64)
        exp_pkts = []
        ports = list(pkt_params.keys())

        for port in pkt_params:
            inner_pkt = simple_udp_packet(eth_dst=pkt_params[port]["idmac"],
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.vm_ip1,
                                          ip_src=self.customer_ip,
                                          ip_id=108,
                                          ip_ttl=63)
            if self.ipv6 is False:
                vxlan_pkt = Mask(
                    simple_vxlan_packet(eth_dst=pkt_params[port]["dmac"],
                                        eth_src=ROUTER_MAC,
                                        ip_dst=pkt_params[port]["tun_ip"],
                                        ip_src=self.lpb_ip,
                                        ip_id=0,
                                        dl_vlan_enable=False,
                                        ip_ttl=64,
                                        ip_flags=0x2,
                                        with_udp_chksum=False,
                                        vxlan_vni=self.vni,
                                        inner_frame=inner_pkt))
            else:
                vxlan_pkt = Mask(
                    simple_vxlanv6_packet(eth_dst=pkt_params[port]["dmac"],
                                          eth_src=ROUTER_MAC,
                                          ipv6_dst=pkt_params[port]["tun_ip"],
                                          ipv6_src=self.lpb_ip,
                                          dl_vlan_enable=False,
                                          ipv6_hlim=64,
                                          with_udp_chksum=False,
                                          vxlan_vni=self.vni,
                                          inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

            exp_pkts.append(vxlan_pkt)

        print("Sending IPv4 packet")
        send_packet(self, self.oport_dev, pkt)
        verify_any_packet_any_port(self, exp_pkts, ports)
        print("\tOK")

    def _v6TrafficEcmpTest(self, pkt_params):
        '''
        A helper function for checking IPv6 ECMP traffic

        Args:
            pkt_params (dict): a dictionary with port device numbers as keys
                               and a dictionary of packet parameters as values:
                               {port: {dmac, idmac, tun_ip}}
        '''

        pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                  eth_src=self.customer_mac,
                                  ipv6_dst=self.vm_ipv61,
                                  ipv6_src=self.customer_ipv6,
                                  ipv6_hlim=64)
        exp_pkts = []
        ports = list(pkt_params.keys())

        for port in pkt_params:
            inner_pkt = simple_udpv6_packet(eth_dst=pkt_params[port]["idmac"],
                                            eth_src=ROUTER_MAC,
                                            ipv6_dst=self.vm_ipv61,
                                            ipv6_src=self.customer_ipv6,
                                            ipv6_hlim=63)
            if self.ipv6 is False:
                vxlan_pkt = Mask(
                    simple_vxlan_packet(eth_dst=pkt_params[port]["dmac"],
                                        eth_src=ROUTER_MAC,
                                        ip_dst=pkt_params[port]["tun_ip"],
                                        ip_src=self.lpb_ip,
                                        ip_id=0,
                                        dl_vlan_enable=False,
                                        ip_ttl=64,
                                        ip_flags=0x2,
                                        with_udp_chksum=False,
                                        vxlan_vni=self.vni,
                                        inner_frame=inner_pkt))
            else:
                vxlan_pkt = Mask(
                    simple_vxlanv6_packet(eth_dst=pkt_params[port]["dmac"],
                                          eth_src=ROUTER_MAC,
                                          ipv6_dst=pkt_params[port]["tun_ip"],
                                          ipv6_src=self.lpb_ip,
                                          dl_vlan_enable=False,
                                          ipv6_hlim=64,
                                          with_udp_chksum=False,
                                          vxlan_vni=self.vni,
                                          inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

            exp_pkts.append(vxlan_pkt)

        print("Sending IPv6 packet")
        send_packet(self, self.oport_dev, pkt)
        verify_any_packet_any_port(self, exp_pkts, ports)
        print("\tOK")

    # Underlay port, LAG, and subport interfaces tests
    def _sequenceTest1(self, urif, uports, vlan_no=0):
        '''
        Verify nexthop resolution for the following sequence of objects
        creation: Underlay Nexthop -> Underlay Neighbor -> Underlay Tunnel
        Route -> Overlay Tunnel Nexthop -> Overlay Customer route

        Args:
            urif (oid): underlay RIF object ID
            uports (list): a list of underlay ports
            vlan_no (int): VLAN number
        '''
        print("sequence 1")

        try:
            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            self._v4TrafficTest(uports, {"vlan_no": vlan_no})
            self._v6TrafficTest(uports, {"vlan_no": vlan_no})

        finally:
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_next_hop(self.client, unhop)

    def _sequenceTest2(self, urif, uports, vlan_no=0):
        '''
        Verify nexthop resolution for the following sequence of objects
        creation: Overlay Tunnel Nexthop -> Overlay Customer Route -> Underlay
        Nexthop -> Underlay Neighbor -> Underlay Tunnel Route

        Args:
            urif (oid): underlay RIF object ID
            uports (list): a list of underlay ports
            vlan_no (int): VLAN number
        '''
        print("sequence 2")

        try:
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            self._v4TrafficTest(uports, {"vlan_no": vlan_no})
            self._v6TrafficTest(uports, {"vlan_no": vlan_no})

        finally:
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_next_hop(self.client, unhop)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def _sequenceTest3(self, urif, uports, vlan_no=0):
        '''
        Verify nexthop resolution for the following sequence of objects
        creation: Overlay Tunnel Nexthop -> Overlay Cusotmer Route -> Underlay
        Nexthop -> Underlay Tunnel Route -> Underlay Neighbor

        Args:
            urif (oid): underlay RIF object ID
            uports (list): a list of underlay ports
            vlan_no (int): VLAN number
        '''
        print("sequence 3")

        try:
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            self._v4TrafficTest(uports, {"vlan_no": vlan_no})
            self._v6TrafficTest(uports, {"vlan_no": vlan_no})

        finally:
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_next_hop(self.client, unhop)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def _sequenceTest4(self, urif, uports, vlan_no=0):
        '''
        Verify nexthop resolution for the following sequence of objects
        creation: 4. Overlay Tunnel Nexthop -> Overlay Cusotmer Route ->
        Underlay Neighbor-> Underlay Nexthop -> Underlay Tunnel Route

        Args:
            urif (oid): underlay RIF object ID
            uports (list): a list of underlay ports
            vlan_no (int): VLAN number
        '''
        print("sequence 4")

        try:
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            self._v4TrafficTest(uports, {"vlan_no": vlan_no})
            self._v6TrafficTest(uports, {"vlan_no": vlan_no})

        finally:
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_next_hop(self.client, unhop)
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def _underlayTunnelRouteUpdateTest(self, urif_data):
        '''
        Verify nexthop resolution for underlay tunnel route update

        Args:
            urif_data (list): a list of 2 sets (underlay RIF object ID,
                              list of underlay ports, VLAN number)
        '''
        print("underlay tunnel route update")

        urif1 = urif_data[0][0]
        uports1 = urif_data[0][1]
        vlan_no1 = urif_data[0][2]
        urif2 = urif_data[1][0]
        uports2 = urif_data[1][1]
        vlan_no2 = urif_data[1][2]

        try:
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            unbor1 = sai_thrift_neighbor_entry_t(
                rif_id=urif1, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor1,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            unhop1 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip1),
                                                router_interface_id=urif1,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            print("Adding Route 1")
            tunnel_route1 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route1,
                                          next_hop_id=unhop1)

            self._v4TrafficTest(uports1, {"vlan_no": vlan_no1})
            self._v6TrafficTest(uports1, {"vlan_no": vlan_no1})

            print("Removing Route 1")
            sai_thrift_remove_route_entry(self.client, tunnel_route1)
            sai_thrift_remove_next_hop(self.client, unhop1)
            sai_thrift_remove_neighbor_entry(self.client, unbor1)

            self._v4TrafficMissTest()
            self._v6TrafficMissTest()

            unbor2 = sai_thrift_neighbor_entry_t(
                rif_id=urif2, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor2,
                                             dst_mac_address=self.unbor_mac2,
                                             no_host_route=True)

            unhop2 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip1),
                                                router_interface_id=urif2,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            print("Adding Route 2")
            tunnel_route2 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route2,
                                          next_hop_id=unhop2)

            self._v4TrafficTest(uports2, {
                "dmac": self.unbor_mac2,
                "vlan_no": vlan_no2
            })
            self._v6TrafficTest(uports2, {
                "dmac": self.unbor_mac2,
                "vlan_no": vlan_no2
            })

        finally:
            sai_thrift_remove_route_entry(self.client, tunnel_route2)
            sai_thrift_remove_next_hop(self.client, unhop2)
            sai_thrift_remove_neighbor_entry(self.client, unbor2)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def _underlayTunnelRouteUpdateDropTest(self, urif, uports, vlan_no=0):
        '''
        Verify nexthop resolution for underlay tunnel route update

        Args:
            urif (oid): underlay RIF object ID
            uports (list): a list of underlay ports
            vlan_no (int): VLAN number
        '''
        print("underlay tunnel drop route update")

        try:
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            print("Adding Drop Route")
            tunnel_route1 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route1,
                                          next_hop_id=int(SAI_NULL_OBJECT_ID))

            self._v4TrafficMissTest()
            self._v6TrafficMissTest()

            print("Removing Drop Route")
            sai_thrift_remove_route_entry(self.client, tunnel_route1)

            self._v4TrafficMissTest()
            self._v6TrafficMissTest()

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            print("Adding regular Route")
            tunnel_route2 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route2,
                                          next_hop_id=unhop)

            self._v4TrafficTest(uports, {"vlan_no": vlan_no})
            self._v6TrafficTest(uports, {"vlan_no": vlan_no})

        finally:
            sai_thrift_remove_route_entry(self.client, tunnel_route2)
            sai_thrift_remove_next_hop(self.client, unhop)
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def _underlayRouteFallbackTest(self, urif_data):
        '''
        Verify nexthop resolution for underlay tunnel route when the host route
        is removed and LPM route should be used

        Args:
            urif_data (list): a list of 2 sets (underlay RIF object ID,
                              list of underlay ports, VLAN number)
        '''
        print("underlay route fallback")

        urif1 = urif_data[0][0]
        uports1 = urif_data[0][1]
        vlan_no1 = urif_data[0][2]
        urif2 = urif_data[1][0]
        uports2 = urif_data[1][1]
        vlan_no2 = urif_data[1][2]

        try:
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            unbor1 = sai_thrift_neighbor_entry_t(
                rif_id=urif2, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor1,
                                             dst_mac_address=self.unbor_mac2,
                                             no_host_route=True)

            unhop1 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip1),
                                                router_interface_id=urif2,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            print("Creating LPM route")
            tunnel_lpm_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask2))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_lpm_route,
                                          next_hop_id=unhop1)

            unbor2 = sai_thrift_neighbor_entry_t(
                rif_id=urif1, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor2,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            unhop2 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip1),
                                                router_interface_id=urif1,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            print("Creating host route")
            tunnel_host_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_host_route,
                                          next_hop_id=unhop2)

            print("Verifying forwarding with host route")
            self._v4TrafficTest(uports1, {"vlan_no": vlan_no1})
            self._v6TrafficTest(uports1, {"vlan_no": vlan_no1})

            print("Removing host route")
            sai_thrift_remove_route_entry(self.client, tunnel_host_route)
            sai_thrift_remove_next_hop(self.client, unhop2)
            sai_thrift_remove_neighbor_entry(self.client, unbor2)

            print("Verifying forwarding with LPM route")
            self._v4TrafficTest(uports2, {
                "dmac": self.unbor_mac2,
                "vlan_no": vlan_no2
            })
            self._v6TrafficTest(uports2, {
                "dmac": self.unbor_mac2,
                "vlan_no": vlan_no2
            })

        finally:
            sai_thrift_remove_route_entry(self.client, tunnel_lpm_route)
            sai_thrift_remove_next_hop(self.client, unhop1)
            sai_thrift_remove_neighbor_entry(self.client, unbor1)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def _overlayTunnelNexthopUpdateTest(self, urif, uports, vlan_no=0):
        '''
        Verify nexthop resolution for underlay tunnel route when the overlay
        tunnel nexthop is updated

        Args:
            urif (oid): underlay RIF object ID
            uports (list): a list of underlay ports
            vlan_no (int): VLAN number
        '''
        print("overlay tunnel nexthop update")

        try:
            tunnel_nhop1 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop1)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop1)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask2))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            self._v4TrafficTest(uports, {"vlan_no": vlan_no})
            self._v6TrafficTest(uports, {"vlan_no": vlan_no})

            print("Update tunnel nexthop")
            tunnel_nhop2 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip2),
                tunnel_mac=self.inner_dmac2,
                tunnel_vni=self.vni)

            sai_thrift_set_route_entry_attribute(self.client,
                                                 vm_route,
                                                 next_hop_id=tunnel_nhop2)
            sai_thrift_set_route_entry_attribute(self.client,
                                                 vm_v6_route,
                                                 next_hop_id=tunnel_nhop2)

            self._v4TrafficTest(
                uports, {
                    "idmac": self.inner_dmac2,
                    "tun_ip": self.tun_ip2,
                    "vlan_no": vlan_no
                })
            self._v6TrafficTest(
                uports, {
                    "idmac": self.inner_dmac2,
                    "tun_ip": self.tun_ip2,
                    "vlan_no": vlan_no
                })

        finally:
            sai_thrift_remove_next_hop(self.client, tunnel_nhop2)
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_next_hop(self.client, unhop)
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop1)

    def tunnelL3IntfTest(self):
        '''
        Route resolution tests with L3 interface as underlay RIF
        '''
        print("\ntunnelL3IntfTest()")

        uport1 = self.port25
        uport1_dev = self.dev_port25
        uport2 = self.port26
        uport2_dev = self.dev_port26

        try:
            urif1 = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_PORT,
                virtual_router_id=self.uvrf,
                port_id=uport1)

            urif2 = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_PORT,
                virtual_router_id=self.uvrf,
                port_id=uport2)

            self._sequenceTest1(urif1, [uport1_dev])
            self._sequenceTest2(urif1, [uport1_dev])
            self._sequenceTest3(urif1, [uport1_dev])
            self._sequenceTest4(urif1, [uport1_dev])
            self._underlayTunnelRouteUpdateTest([[urif1, [uport1_dev], 0],
                                                 [urif2, [uport2_dev], 0]])
            self._underlayTunnelRouteUpdateDropTest(urif1, [uport1_dev])
            self._underlayRouteFallbackTest([[urif1, [uport1_dev], 0],
                                             [urif2, [uport2_dev], 0]])
            self._overlayTunnelNexthopUpdateTest(urif1, [uport1_dev])

        finally:
            sai_thrift_remove_router_interface(self.client, urif2)
            sai_thrift_remove_router_interface(self.client, urif1)

    def tunnelL3LagIntfTest(self):
        '''
        Route resolution tests with L3 LAG underlay RIF
        '''
        print("\ntunnelL3LagIntfTest()")

        urif1 = self.lag3_rif
        urif1_ports = [self.dev_port14, self.dev_port15, self.dev_port16]

        urif2 = self.lag4_rif
        urif2_ports = [self.dev_port17, self.dev_port18, self.dev_port19]

        self._sequenceTest1(urif1, urif1_ports)
        self._sequenceTest2(urif1, urif1_ports)
        self._sequenceTest3(urif1, urif1_ports)
        self._sequenceTest4(urif1, urif1_ports)
        self._underlayTunnelRouteUpdateTest([[urif1, urif1_ports, 0],
                                             [urif2, urif2_ports, 0]])
        self._underlayTunnelRouteUpdateDropTest(urif1, urif1_ports)
        self._underlayRouteFallbackTest([[urif1, urif1_ports, 0],
                                         [urif2, urif2_ports, 0]])
        self._overlayTunnelNexthopUpdateTest(urif1, urif1_ports)

    def tunnelL3SubPortIntfTest(self):
        '''
        Route resolution tests with L3 subport interface underlay RIF
        '''
        print("\ntunnelL3SubPortIntfTest()")

        uport = self.port25
        uport_dev = self.dev_port25

        vlan_no1 = 100
        vlan_no2 = 200

        try:
            urif1 = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT,
                virtual_router_id=self.uvrf,
                port_id=uport,
                outer_vlan_id=vlan_no1)

            urif2 = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT,
                virtual_router_id=self.uvrf,
                port_id=uport,
                outer_vlan_id=vlan_no2)

            self._sequenceTest1(urif1, [uport_dev], vlan_no1)
            self._sequenceTest2(urif1, [uport_dev], vlan_no1)
            self._sequenceTest3(urif1, [uport_dev], vlan_no1)
            self._sequenceTest4(urif1, [uport_dev], vlan_no1)
            self._underlayTunnelRouteUpdateTest(
                [[urif1, [uport_dev], vlan_no1],
                 [urif2, [uport_dev], vlan_no2]])
            self._underlayTunnelRouteUpdateDropTest(urif1, [uport_dev],
                                                    vlan_no1)
            self._underlayRouteFallbackTest([[urif1, [uport_dev], vlan_no1],
                                             [urif2, [uport_dev], vlan_no2]])
            self._overlayTunnelNexthopUpdateTest(urif1, [uport_dev], vlan_no1)

        finally:
            sai_thrift_remove_router_interface(self.client, urif2)
            sai_thrift_remove_router_interface(self.client, urif1)

    # SVI underlay interface tests
    def _sviSequenceTest1(self, urif, uport, port_bp, vlan_id):
        '''
        Verify nexthop resolution for the following sequence of objects
        creation: Overlay Tunnel Nexthop -> Overlay Customer Route -> Underlay
        Nexthop -> Underlay Route -> Underlay Neighbor -> Underlay MAC

        Args:
            urif (oid): underlay RIF oject ID
            uport (int): underlay port number
            port_bp (oid): underlay bridge port object ID
            vlan_id (oid): VLAN object ID
        '''
        print("SVI sequence 1")

        try:
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            mac_entry = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                               mac_address=self.unbor_mac1,
                                               bv_id=vlan_id)
            sai_thrift_create_fdb_entry(self.client,
                                        mac_entry,
                                        type=SAI_FDB_ENTRY_TYPE_STATIC,
                                        bridge_port_id=port_bp)

            self._v4TrafficTest([uport])
            self._v6TrafficTest([uport])

        finally:
            sai_thrift_remove_fdb_entry(self.client, mac_entry)
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_next_hop(self.client, unhop)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def _sviSequenceTest2(self, urif, uport, port_bp, vlan_id):
        '''
        Verify nexthop resolution for the following sequence of objects
        creation: Overlay Tunnel Nexthop -> Overlay Customer Route -> Underlay
        Neighbor -> Underlay MAC -> Underlay Nexthop -> Underlay Route

        Args:
            urif (oid): underlay RIF oject ID
            uport (int): underlay port number
            port_bp (oid): underlay bridge port object ID
            vlan_id (oid): VLAN object ID
        '''
        print("SVI sequence 2")

        try:
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            mac_entry = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                               mac_address=self.unbor_mac1,
                                               bv_id=vlan_id)
            sai_thrift_create_fdb_entry(self.client,
                                        mac_entry,
                                        type=SAI_FDB_ENTRY_TYPE_STATIC,
                                        bridge_port_id=port_bp)

            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            self._v4TrafficTest([uport])
            self._v6TrafficTest([uport])

        finally:
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_next_hop(self.client, unhop)
            sai_thrift_remove_fdb_entry(self.client, mac_entry)
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def _sviSequenceTest3(self, urif, uport, port_bp, vlan_id):
        '''
        Verify nexthop resolution for the following sequence of objects
        creation: Overlay Tunnel Nexthop -> Overlay Customer Route -> Underlay
        MAC -> Underlay Neighbor -> Underlay Nexthop -> Underlay Route

        Args:
            urif (oid): underlay RIF oject ID
            uport (int): underlay port number
            port_bp (oid): underlay bridge port object ID
            vlan_id (oid): VLAN object ID
        '''
        print("SVI sequence 3")

        try:
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            mac_entry = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                               mac_address=self.unbor_mac1,
                                               bv_id=vlan_id)
            sai_thrift_create_fdb_entry(self.client,
                                        mac_entry,
                                        type=SAI_FDB_ENTRY_TYPE_STATIC,
                                        bridge_port_id=port_bp)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            self._v4TrafficTest([uport])
            self._v6TrafficTest([uport])

        finally:
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_next_hop(self.client, unhop)
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_fdb_entry(self.client, mac_entry)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def _sviSequenceTest4(self, urif, uport, port_bp, vlan_id):
        '''
        Verify nexthop resolution for the following sequence of objects
        creation: Overlay Tunnel Nexthop -> Overlay Customer Route -> Underlay
        MAC -> Underlay Nexthop -> Underlay Route -> Underlay Neighbor

        Args:
            urif (oid): underlay RIF oject ID
            uport (int): underlay port number
            port_bp (oid): underlay bridge port object ID
            vlan_id (oid): VLAN object ID
        '''
        print("SVI sequence 4")

        try:
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            mac_entry = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                               mac_address=self.unbor_mac1,
                                               bv_id=vlan_id)
            sai_thrift_create_fdb_entry(self.client,
                                        mac_entry,
                                        type=SAI_FDB_ENTRY_TYPE_STATIC,
                                        bridge_port_id=port_bp)

            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            self._v4TrafficTest([uport])
            self._v6TrafficTest([uport])

        finally:
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_next_hop(self.client, unhop)
            sai_thrift_remove_fdb_entry(self.client, mac_entry)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def _sviSequenceTest5(self, urif, uport, port_bp, vlan_id):
        '''
        Verify nexthop resolution for the following sequence of objects
        creation: Overlay Tunnel Nexthop -> Overlay Customer Route -> Underlay
        Neighbor -> Underlay Nexthop -> Underlay Route -> Underlay MAC

        Args:
            urif (oid): underlay RIF oject ID
            uport (int): underlay port number
            port_bp (oid): underlay bridge port object ID
            vlan_id (oid): VLAN object ID
        '''
        print("SVI sequence 5")

        try:
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            mac_entry = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                               mac_address=self.unbor_mac1,
                                               bv_id=vlan_id)
            sai_thrift_create_fdb_entry(self.client,
                                        mac_entry,
                                        type=SAI_FDB_ENTRY_TYPE_STATIC,
                                        bridge_port_id=port_bp)

            self._v4TrafficTest([uport])
            self._v6TrafficTest([uport])

        finally:
            sai_thrift_remove_fdb_entry(self.client, mac_entry)
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_next_hop(self.client, unhop)
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def _sviSequenceTest6(self, urif, uport, port_bp, vlan_id):
        '''
        Verify nexthop resolution for the following sequence of objects
        creation: Underlay Nexthop -> Underlay Neighbor -> Underlay MAC ->
        Underlay Route -> Overlay Tunnel Nexthop -> Overlay Customer Route

        Args:
            urif (oid): underlay RIF oject ID
            uport (int): underlay port number
            port_bp (oid): underlay bridge port object ID
            vlan_id (oid): VLAN object ID
        '''
        print("SVI sequence 6")

        try:
            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            mac_entry = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                               mac_address=self.unbor_mac1,
                                               bv_id=vlan_id)
            sai_thrift_create_fdb_entry(self.client,
                                        mac_entry,
                                        type=SAI_FDB_ENTRY_TYPE_STATIC,
                                        bridge_port_id=port_bp)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            self._v4TrafficTest([uport])
            self._v6TrafficTest([uport])

        finally:
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_fdb_entry(self.client, mac_entry)
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_next_hop(self.client, unhop)

    def _sviSequenceTest7(self, urif, uport, port_bp, vlan_id):
        '''
        Verify nexthop resolution for the following sequence of objects
        creation: Underlay Nexthop -> Underlay MAC -> Underlay Route -> Overlay
        Tunnel Nexthop -> Overlay Customer route  -> Underlay Neighbor

        Args:
            urif (oid): underlay RIF oject ID
            uport (int): underlay port number
            port_bp (oid): underlay bridge port object ID
            vlan_id (oid): VLAN object ID
        '''
        print("SVI sequence 7")

        try:
            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            mac_entry = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                               mac_address=self.unbor_mac1,
                                               bv_id=vlan_id)
            sai_thrift_create_fdb_entry(self.client,
                                        mac_entry,
                                        type=SAI_FDB_ENTRY_TYPE_STATIC,
                                        bridge_port_id=port_bp)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            self._v4TrafficTest([uport])
            self._v6TrafficTest([uport])

        finally:
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_fdb_entry(self.client, mac_entry)
            sai_thrift_remove_next_hop(self.client, unhop)

    def _sviSequenceTest8(self, urif, uport, port_bp, vlan_id):
        '''
        Verify nexthop resolution for the following sequence of objects
        creation: Underlay Nexthop -> Underlay Neighbor -> Underlay Route ->
        Overlay Tunnel Nexthop -> Overlay Customer route -> Underlay MAC

        Args:
            urif (oid): underlay RIF oject ID
            uport (int): underlay port number
            port_bp (oid): underlay bridge port object ID
            vlan_id (oid): VLAN object ID
        '''
        print("SVI sequence 8")

        try:
            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            mac_entry = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                               mac_address=self.unbor_mac1,
                                               bv_id=vlan_id)
            sai_thrift_create_fdb_entry(self.client,
                                        mac_entry,
                                        type=SAI_FDB_ENTRY_TYPE_STATIC,
                                        bridge_port_id=port_bp)

            self._v4TrafficTest([uport])
            self._v6TrafficTest([uport])

        finally:
            sai_thrift_remove_fdb_entry(self.client, mac_entry)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_next_hop(self.client, unhop)

    def _sviSequenceTest9(self, urif, uport, port_bp, vlan_id):
        '''
        Verify nexthop resolution for the following sequence of objects
        creation: Underlay Nexthop -> Underlay Neighbor -> Underlay MAC ->
        Overlay Tunnel Nexthop -> Overlay Customer route -> Underlay Route

        Args:
            urif (oid): underlay RIF oject ID
            uport (int): underlay port number
            port_bp (oid): underlay bridge port object ID
            vlan_id (oid): VLAN object ID
        '''
        print("SVI sequence 9")

        try:
            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            mac_entry = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                               mac_address=self.unbor_mac1,
                                               bv_id=vlan_id)
            sai_thrift_create_fdb_entry(self.client,
                                        mac_entry,
                                        type=SAI_FDB_ENTRY_TYPE_STATIC,
                                        bridge_port_id=port_bp)

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            self._v4TrafficTest([uport])
            self._v6TrafficTest([uport])

        finally:
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_fdb_entry(self.client, mac_entry)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_next_hop(self.client, unhop)

    def _sviSequenceTest10(self, urif, uport, port_bp, vlan_id):
        '''
        Verify nexthop resolution for the following sequence of objects
        creation: Underlay Nexthop -> Underlay Neighbor  ->  Overlay Tunnel
        Nexthop -> Overlay Customer route -> Underlay MAC -> Underlay Route

        Args:
            urif (oid): underlay RIF oject ID
            uport (int): underlay port number
            port_bp (oid): underlay bridge port object ID
            vlan_id (oid): VLAN object ID
        '''
        print("SVI sequence 10")

        try:
            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            mac_entry = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                               mac_address=self.unbor_mac1,
                                               bv_id=vlan_id)
            sai_thrift_create_fdb_entry(self.client,
                                        mac_entry,
                                        type=SAI_FDB_ENTRY_TYPE_STATIC,
                                        bridge_port_id=port_bp)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            self._v4TrafficTest([uport])
            self._v6TrafficTest([uport])

        finally:
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_fdb_entry(self.client, mac_entry)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_next_hop(self.client, unhop)

    def _sviSequenceTest11(self, urif, uport, port_bp, vlan_id):
        '''
        Verify nexthop resolution for the following sequence of objects
        creation: Underlay Nexthop  ->  Overlay Tunnel Nexthop -> Overlay
        Customer route -> Underlay Neighbor  -> Underlay MAC -> Underlay Route

        Args:
            urif (oid): underlay RIF oject ID
            uport (int): underlay port number
            port_bp (oid): underlay bridge port object ID
            vlan_id (oid): VLAN object ID
        '''
        print("SVI sequence 11")

        try:
            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            mac_entry = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                               mac_address=self.unbor_mac1,
                                               bv_id=vlan_id)
            sai_thrift_create_fdb_entry(self.client,
                                        mac_entry,
                                        type=SAI_FDB_ENTRY_TYPE_STATIC,
                                        bridge_port_id=port_bp)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            self._v4TrafficTest([uport])
            self._v6TrafficTest([uport])

        finally:
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_fdb_entry(self.client, mac_entry)
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_next_hop(self.client, unhop)

    def _sviSequenceTest12(self, urif, uport, port_bp, vlan_id):
        '''
        Verify nexthop resolution for the following sequence of objects
        creation: Underlay Nexthop -> Underlay MAC -> Overlay Tunnel Nexthop
        -> Overlay Customer route -> Underlay Neighbor -> Underlay Route

        Args:
            urif (oid): underlay RIF oject ID
            uport (int): underlay port number
            port_bp (oid): underlay bridge port object ID
            vlan_id (oid): VLAN object ID
        '''
        print("SVI sequence 12")

        try:
            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            mac_entry = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                               mac_address=self.unbor_mac1,
                                               bv_id=vlan_id)
            sai_thrift_create_fdb_entry(self.client,
                                        mac_entry,
                                        type=SAI_FDB_ENTRY_TYPE_STATIC,
                                        bridge_port_id=port_bp)

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            self._v4TrafficTest([uport])
            self._v6TrafficTest([uport])

        finally:
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_fdb_entry(self.client, mac_entry)
            sai_thrift_remove_next_hop(self.client, unhop)

    def _sviMacMoveTest(self, urif, uport_data, vlan_id):
        '''
        Verify nexthop resolution for the following sequence of objects
        creation: Underlay Nexthop -> Underlay MAC -> Overlay Tunnel Nexthop
        -> Overlay Customer route -> Underlay Neighbor -> Underlay Route

        Args:
            urif (oid): underlay RIF object ID
            uport_data (list): a list containing 2 pairs (underlay port number,
                               underlay bridge port object ID)
            vlan_id (oid): VLAN object ID
        '''
        print("MAC move test")

        uport1 = uport_data[0][0]
        port_bp1 = uport_data[0][1]
        uport2 = uport_data[1][0]
        port_bp2 = uport_data[1][1]

        try:
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            mac_entry = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                               mac_address=self.unbor_mac1,
                                               bv_id=vlan_id)
            sai_thrift_create_fdb_entry(self.client,
                                        mac_entry,
                                        type=SAI_FDB_ENTRY_TYPE_STATIC,
                                        bridge_port_id=port_bp1)

            self._v4TrafficTest([uport1])
            self._v6TrafficTest([uport1])

            sai_thrift_set_fdb_entry_attribute(self.client,
                                               mac_entry,
                                               bridge_port_id=port_bp2)

            self._v4TrafficTest([uport2])
            self._v6TrafficTest([uport2])

        finally:
            sai_thrift_remove_fdb_entry(self.client, mac_entry)
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_next_hop(self.client, unhop)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def _sviMacFloodTest(self, urif, uports):
        '''
        Verify nexthop resolution for the following sequence of objects
        creation: Underlay Nexthop -> Underlay MAC -> Overlay Tunnel Nexthop
        -> Overlay Customer route -> Underlay Neighbor -> Underlay Route

        Args:
            urif (oid): underlay RIF object ID
            uports (list): a list of underlay port numbers
        '''
        print("MAC flood test")

        try:
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            self._v4TrafficFloodTest(uports)
            self._v6TrafficFloodTest(uports)

        finally:
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_next_hop(self.client, unhop)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def tunnelSviIntfTest(self):
        '''
        Route resolution tests with SVI underlay RIF
        '''
        print("\ntunnelSviIntfTest()")

        urif1 = self.vlan30_rif  # port20, port21 (tag), lag5=[port22, port23]
        urif1_ports = [[self.dev_port20], [self.dev_port21],
                       [self.dev_port22, self.dev_port23]]

        mac_port1 = self.dev_port20
        mac_port1_bp = self.port20_bp
        mac_port2 = self.dev_port21
        mac_port2_bp = self.port21_bp
        vlan_id = self.vlan30

        try:
            # change port21 tagging mode (set operation not supported)
            sai_thrift_remove_vlan_member(self.client, self.vlan30_member1)
            self.vlan30_member1 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=vlan_id,
                bridge_port_id=self.port21_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)

            self._sviSequenceTest1(urif1, mac_port1, mac_port1_bp, vlan_id)
            self._sviSequenceTest2(urif1, mac_port1, mac_port1_bp, vlan_id)
            self._sviSequenceTest3(urif1, mac_port1, mac_port1_bp, vlan_id)
            self._sviSequenceTest4(urif1, mac_port1, mac_port1_bp, vlan_id)
            self._sviSequenceTest5(urif1, mac_port1, mac_port1_bp, vlan_id)
            self._sviSequenceTest6(urif1, mac_port1, mac_port1_bp, vlan_id)
            self._sviSequenceTest7(urif1, mac_port1, mac_port1_bp, vlan_id)
            self._sviSequenceTest8(urif1, mac_port1, mac_port1_bp, vlan_id)
            self._sviSequenceTest9(urif1, mac_port1, mac_port1_bp, vlan_id)
            self._sviSequenceTest10(urif1, mac_port1, mac_port1_bp, vlan_id)
            self._sviSequenceTest11(urif1, mac_port1, mac_port1_bp, vlan_id)
            self._sviSequenceTest12(urif1, mac_port1, mac_port1_bp, vlan_id)
            self._sviMacMoveTest(
                urif1, [[mac_port1, mac_port1_bp], [mac_port2, mac_port2_bp]],
                vlan_id)
            self._sviMacFloodTest(urif1, urif1_ports)

            mac_entry = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                               mac_address=self.unbor_mac1,
                                               bv_id=vlan_id)
            sai_thrift_create_fdb_entry(self.client,
                                        mac_entry,
                                        type=SAI_FDB_ENTRY_TYPE_STATIC,
                                        bridge_port_id=mac_port1_bp)

            urif2 = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_VLAN,
                virtual_router_id=self.default_vrf,
                vlan_id=self.vlan10)
            self.assertNotEqual(urif2, 0)

            mac_entry2 = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                                mac_address=self.unbor_mac2,
                                                bv_id=self.vlan10)
            sai_thrift_create_fdb_entry(self.client,
                                        mac_entry2,
                                        type=SAI_FDB_ENTRY_TYPE_STATIC,
                                        bridge_port_id=self.port0_bp)

            self._underlayRouteFallbackTest([[urif1, [mac_port1], 0],
                                             [urif2, [self.dev_port0], 0]])
            self._overlayTunnelNexthopUpdateTest(urif1, [mac_port1])

        finally:
            sai_thrift_remove_fdb_entry(self.client, mac_entry2)
            sai_thrift_remove_router_interface(self.client, urif2)
            sai_thrift_remove_fdb_entry(self.client, mac_entry)

            # revert port21 tagging mode (set operation not supported)
            sai_thrift_remove_vlan_member(self.client, self.vlan30_member1)
            self.vlan30_member1 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=vlan_id,
                bridge_port_id=self.port21_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

    # Multiple nexthop tests
    def _multiNhopSequenceTest1(self, urif, uport):
        '''
        Verify multiple nexthop resolution for the following sequence
        of objects creation: Overlay Nexthop 1 -> Overlay Customer Route 1 ->
        Overlay Nexthop 2 -> Overlay Customer Route 2 - > Underlay Neighbor ->
        Underlay Nexthop -> Underlay Route

        Args:
            urif (oid): underlay RIF object ID
            uport (int): underlay port number
        '''
        print("multiple nexthops sequence 1")

        try:
            tunnel_nhop1 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route1 = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route1,
                                          next_hop_id=tunnel_nhop1)

            vm_v6_route1 = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route1,
                                          next_hop_id=tunnel_nhop1)

            tunnel_nhop2 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip2),
                tunnel_mac=self.inner_dmac2,
                tunnel_vni=self.vni)

            vm_route2 = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip2 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route2,
                                          next_hop_id=tunnel_nhop2)

            vm_v6_route2 = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv62 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route2,
                                          next_hop_id=tunnel_nhop2)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask2))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            print("Testing nexthop 1")
            self._v4TrafficTest(uport)
            self._v6TrafficTest(uport)

            print("Testing nexthop 2")
            self._v4TrafficTest(
                uport, {
                    "idmac": self.inner_dmac2,
                    "dst_ip": self.vm_ip2,
                    "tun_ip": self.tun_ip2
                })
            self._v6TrafficTest(
                uport, {
                    "idmac": self.inner_dmac2,
                    "dst_ip": self.vm_ipv62,
                    "tun_ip": self.tun_ip2
                })

        finally:
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_next_hop(self.client, unhop)
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_route_entry(self.client, vm_v6_route2)
            sai_thrift_remove_route_entry(self.client, vm_route2)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop2)
            sai_thrift_remove_route_entry(self.client, vm_v6_route1)
            sai_thrift_remove_route_entry(self.client, vm_route1)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop1)

    def _multiNhopSequenceTest2(self, urif, uport):
        '''
        Verify multiple nexthop resolution for the following sequence
        of objects creation: Overlay Nexthop 1 -> Overlay Customer Route 1 ->
        Underlay Neighbor -> Underlay Nexthop -> Underlay Route -> Overlay
        Nexthop 2 -> Overlay Customer Route 2

        Args:
            urif (oid): underlay RIF object ID
            uport (int): underlay port number
        '''
        print("multiple nexthops sequence 2")

        try:
            tunnel_nhop1 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route1 = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route1,
                                          next_hop_id=tunnel_nhop1)

            vm_v6_route1 = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route1,
                                          next_hop_id=tunnel_nhop1)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask2))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            tunnel_nhop2 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip2),
                tunnel_mac=self.inner_dmac2,
                tunnel_vni=self.vni)

            vm_route2 = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip2 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route2,
                                          next_hop_id=tunnel_nhop2)

            vm_v6_route2 = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv62 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route2,
                                          next_hop_id=tunnel_nhop2)

            print("Testing nexthop 1")
            self._v4TrafficTest(uport)
            self._v6TrafficTest(uport)

            print("Testing nexthop 2")
            self._v4TrafficTest(
                uport, {
                    "idmac": self.inner_dmac2,
                    "dst_ip": self.vm_ip2,
                    "tun_ip": self.tun_ip2
                })
            self._v6TrafficTest(
                uport, {
                    "idmac": self.inner_dmac2,
                    "dst_ip": self.vm_ipv62,
                    "tun_ip": self.tun_ip2
                })

        finally:
            sai_thrift_remove_route_entry(self.client, vm_v6_route2)
            sai_thrift_remove_route_entry(self.client, vm_route2)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop2)
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_next_hop(self.client, unhop)
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_route_entry(self.client, vm_v6_route1)
            sai_thrift_remove_route_entry(self.client, vm_route1)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop1)

    def _multiNhopSequenceTest3(self, urif, uport):
        '''
        Verify multiple nexthop resolution for the following sequence
        of objects creation: Underlay Neighbor -> Underlay Nexthop -> Underlay
        Route -> Overlay Nexthop 1 -> Overlay Route 1 -> Overlay Nexthop 2 ->
        Overlay Route 2

        Args:
            urif (oid): underlay RIF object ID
            uport (int): underlay port number
        '''
        print("multiple nexthops sequence 3")

        try:
            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask2))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            tunnel_nhop1 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route1 = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route1,
                                          next_hop_id=tunnel_nhop1)

            vm_v6_route1 = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route1,
                                          next_hop_id=tunnel_nhop1)

            tunnel_nhop2 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip2),
                tunnel_mac=self.inner_dmac2,
                tunnel_vni=self.vni)

            vm_route2 = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip2 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route2,
                                          next_hop_id=tunnel_nhop2)

            vm_v6_route2 = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv62 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route2,
                                          next_hop_id=tunnel_nhop2)

            print("Testing nexthop 1")
            self._v4TrafficTest(uport)
            self._v6TrafficTest(uport)

            print("Testing nexthop 2")
            self._v4TrafficTest(
                uport, {
                    "idmac": self.inner_dmac2,
                    "dst_ip": self.vm_ip2,
                    "tun_ip": self.tun_ip2
                })
            self._v6TrafficTest(
                uport, {
                    "idmac": self.inner_dmac2,
                    "dst_ip": self.vm_ipv62,
                    "tun_ip": self.tun_ip2
                })

        finally:
            sai_thrift_remove_route_entry(self.client, vm_v6_route2)
            sai_thrift_remove_route_entry(self.client, vm_route2)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop2)
            sai_thrift_remove_route_entry(self.client, vm_v6_route1)
            sai_thrift_remove_route_entry(self.client, vm_route1)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop1)
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_next_hop(self.client, unhop)
            sai_thrift_remove_neighbor_entry(self.client, unbor)

    def _multiNhopFallbackTest(self, urif_data):
        '''
        Verify nexthop resolution for underlay tunnel route when the
        host route is removed and LPM route should be used

        Args:
            urif_data (list): a list containing 2 pairs (underlay RIF,
                              underlay port)
        '''
        print("multiple nexthops route fallback")

        urif1 = urif_data[0][0]
        uport1 = urif_data[0][1]
        urif2 = urif_data[1][0]
        uport2 = urif_data[1][1]

        try:
            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif1, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif1,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask3))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=unhop)

            tunnel_nhop1 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route1 = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route1,
                                          next_hop_id=tunnel_nhop1)

            vm_v6_route1 = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route1,
                                          next_hop_id=tunnel_nhop1)

            tunnel_nhop2 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip2),
                tunnel_mac=self.inner_dmac2,
                tunnel_vni=self.vni)

            vm_route2 = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip2 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route2,
                                          next_hop_id=tunnel_nhop2)

            vm_v6_route2 = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv62 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route2,
                                          next_hop_id=tunnel_nhop2)

            print("Sending packets via %s LPM route" % self.tun_ip_mask3)
            print("Testing nexthop 1")
            self._v4TrafficTest(uport1)
            self._v6TrafficTest(uport1)

            print("Testing nexthop 2")
            self._v4TrafficTest(
                uport1, {
                    "idmac": self.inner_dmac2,
                    "dst_ip": self.vm_ip2,
                    "tun_ip": self.tun_ip2
                })
            self._v6TrafficTest(
                uport1, {
                    "idmac": self.inner_dmac2,
                    "dst_ip": self.vm_ipv62,
                    "tun_ip": self.tun_ip2
                })

            print("Adding %s LPM route" % self.tun_ip_mask2)
            unbor2 = sai_thrift_neighbor_entry_t(
                rif_id=urif2, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor2,
                                             dst_mac_address=self.unbor_mac2,
                                             no_host_route=True)

            unhop2 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip1),
                                                router_interface_id=urif2,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            tunnel_route2 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask2))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route2,
                                          next_hop_id=unhop2)

            print("Sending packets via %s LPM route" % self.tun_ip_mask2)
            print("Testing nexthop 1")
            self._v4TrafficTest(uport2, {"dmac": self.unbor_mac2})
            self._v6TrafficTest(uport2, {"dmac": self.unbor_mac2})

            print("Testing nexthop 2")
            self._v4TrafficTest(
                uport2, {
                    "dmac": self.unbor_mac2,
                    "idmac": self.inner_dmac2,
                    "dst_ip": self.vm_ip2,
                    "tun_ip": self.tun_ip2
                })
            self._v6TrafficTest(
                uport2, {
                    "dmac": self.unbor_mac2,
                    "idmac": self.inner_dmac2,
                    "dst_ip": self.vm_ipv62,
                    "tun_ip": self.tun_ip2
                })

            print("Removing %s LPM route" % self.tun_ip_mask2)
            sai_thrift_remove_route_entry(self.client, tunnel_route2)
            sai_thrift_remove_next_hop(self.client, unhop2)
            sai_thrift_remove_neighbor_entry(self.client, unbor2)

            print("Sending packets via %s LPM route" % self.tun_ip_mask3)
            print("Testing nexthop 1")
            self._v4TrafficTest(uport1)
            self._v6TrafficTest(uport1)

            print("Testing nexthop 2")
            self._v4TrafficTest(
                uport1, {
                    "idmac": self.inner_dmac2,
                    "dst_ip": self.vm_ip2,
                    "tun_ip": self.tun_ip2
                })
            self._v6TrafficTest(
                uport1, {
                    "idmac": self.inner_dmac2,
                    "dst_ip": self.vm_ipv62,
                    "tun_ip": self.tun_ip2
                })

            print("Adding host route")
            unbor2 = sai_thrift_neighbor_entry_t(
                rif_id=urif2, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor2,
                                             dst_mac_address=self.unbor_mac2,
                                             no_host_route=True)

            unhop2 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip1),
                                                router_interface_id=urif2,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            tunnel_host_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_host_route,
                                          next_hop_id=unhop2)

            print("Sending packets via host route")
            print("Testing nexthop 1")
            self._v4TrafficTest(uport2, {"dmac": self.unbor_mac2})
            self._v6TrafficTest(uport2, {"dmac": self.unbor_mac2})

            print("Testing nexthop 2 (not changed)")
            self._v4TrafficTest(
                uport1, {
                    "idmac": self.inner_dmac2,
                    "dst_ip": self.vm_ip2,
                    "tun_ip": self.tun_ip2
                })
            self._v6TrafficTest(
                uport1, {
                    "idmac": self.inner_dmac2,
                    "dst_ip": self.vm_ipv62,
                    "tun_ip": self.tun_ip2
                })

        finally:
            sai_thrift_remove_route_entry(self.client, tunnel_host_route)
            sai_thrift_remove_next_hop(self.client, unhop2)
            sai_thrift_remove_neighbor_entry(self.client, unbor2)
            sai_thrift_remove_route_entry(self.client, vm_v6_route2)
            sai_thrift_remove_route_entry(self.client, vm_route2)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop2)
            sai_thrift_remove_route_entry(self.client, vm_v6_route1)
            sai_thrift_remove_route_entry(self.client, vm_route1)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop1)
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_next_hop(self.client, unhop)
            sai_thrift_remove_neighbor_entry(self.client, unbor)

    def _tunnelVniNexthopTest(self, urif_data):
        '''
        This test simulates the case when a customer/provider Service is homed
        in a VNI (network) different than customers own VNI. In this case
        instead of the tunnel mapper entry, the tunnel nexthop entry provides
        the outgoing VNI ID.
        Also it tests tunnel nexthop vni update case.
        --------------------     --------------------
        | VM: 100.100.1.1  |     | VM: 200.200.2.2  |
        | TP1: 10.10.10.1  |     | TP2: 30.30.30.1  |
        |     VNI:2000     |     |     VNI:3000     |
        --------------------     --------------------
                     |                |
            -----------------------------------
            |      | p1 |          | p3 |     |
            |      ------          ------     |
            |         |              |        |
            |         |              |        |
            |         |              |        |
            |     -----------------------     |
            |     | Tunnel: 10.10.10.10 |     |
            |     -----------------------     |
            |                |                |
            |             ------              |
            |             | p0 |              |
            -----------------------------------
                            |
                   -------------------
                   | C1: 100.100.0.1 |
                   -------------------

        Args:
            urif_data (list): a list containing 2 pairs (underlay RIF,
                              underlay port)
        '''
        print("Underlay encap VNI based on tunnel nexthop rather than mapper")

        if self.ipv6 is False:
            serv_ip = "30.30.30.1"
        else:
            serv_ip = "2001:0db8::30:1"

        serv_vm_ip = "200.200.200.1"
        serv_vm_ipv6 = "2001:0db8::200:1"
        serv_vni1 = 3000
        serv_vni2 = 4000

        urif1 = urif_data[0][0]
        uport1 = urif_data[0][1]
        urif2 = urif_data[1][0]
        uport2 = urif_data[1][1]

        try:
            unbor1 = sai_thrift_neighbor_entry_t(
                rif_id=urif1, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor1,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            unhop1 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip1),
                                                router_interface_id=urif1,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            tunnel_route1 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask2))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route1,
                                          next_hop_id=unhop1)

            unbor2 = sai_thrift_neighbor_entry_t(
                rif_id=urif2, ip_address=sai_ipaddress(serv_ip))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor2,
                                             dst_mac_address=self.unbor_mac2,
                                             no_host_route=True)

            unhop2 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(serv_ip),
                                                router_interface_id=urif2,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            tunnel_route2 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(serv_ip + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route2,
                                          next_hop_id=unhop2)

            tunnel_nhop1 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            tunnel_nhop2 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(serv_ip),
                tunnel_mac=self.inner_dmac2,
                tunnel_vni=serv_vni1)

            vm_route1 = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route1,
                                          next_hop_id=tunnel_nhop1)

            vm_v6_route1 = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route1,
                                          next_hop_id=tunnel_nhop1)

            vm_route2 = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(serv_vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route2,
                                          next_hop_id=tunnel_nhop2)

            vm_v6_route2 = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(serv_vm_ipv6 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route2,
                                          next_hop_id=tunnel_nhop2)

            print("Sending packets to VM")
            self._v4TrafficTest(uport1)
            self._v6TrafficTest(uport1)

            print("Sending packets to service VM")
            self._v4TrafficTest(
                uport2, {
                    "dmac": self.unbor_mac2,
                    "idmac": self.inner_dmac2,
                    "dst_ip": serv_vm_ip,
                    "tun_ip": serv_ip,
                    "vni": serv_vni1
                })
            self._v6TrafficTest(
                uport2, {
                    "dmac": self.unbor_mac2,
                    "idmac": self.inner_dmac2,
                    "dst_ip": serv_vm_ipv6,
                    "tun_ip": serv_ip,
                    "vni": serv_vni1
                })

            print("Updating service VNI")
            sai_thrift_set_next_hop_attribute(self.client,
                                              tunnel_nhop2,
                                              tunnel_vni=serv_vni2)

            print("Sending packets to service VM")
            self._v4TrafficTest(
                uport2, {
                    "dmac": self.unbor_mac2,
                    "idmac": self.inner_dmac2,
                    "dst_ip": serv_vm_ip,
                    "tun_ip": serv_ip,
                    "vni": serv_vni2
                })
            self._v6TrafficTest(
                uport2, {
                    "dmac": self.unbor_mac2,
                    "idmac": self.inner_dmac2,
                    "dst_ip": serv_vm_ipv6,
                    "tun_ip": serv_ip,
                    "vni": serv_vni2
                })

        finally:
            sai_thrift_remove_route_entry(self.client, vm_v6_route2)
            sai_thrift_remove_route_entry(self.client, vm_route2)
            sai_thrift_remove_route_entry(self.client, vm_v6_route1)
            sai_thrift_remove_route_entry(self.client, vm_route1)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop2)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop1)
            sai_thrift_remove_route_entry(self.client, tunnel_route2)
            sai_thrift_remove_next_hop(self.client, unhop2)
            sai_thrift_remove_neighbor_entry(self.client, unbor2)
            sai_thrift_remove_route_entry(self.client, tunnel_route1)
            sai_thrift_remove_next_hop(self.client, unhop1)
            sai_thrift_remove_neighbor_entry(self.client, unbor1)

    def multiTunnelNhopTest(self):
        '''
        Nexthop resolution tests with multiple tunnel nexthops
        '''
        print("\nmultiTunnelNhopTest()")

        uport1 = self.port25
        uport1_dev = [self.dev_port25]
        uport2 = self.port26
        uport_dev2 = [self.dev_port26]

        try:
            urif1 = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_PORT,
                virtual_router_id=self.uvrf,
                port_id=uport1)

            urif2 = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_PORT,
                virtual_router_id=self.uvrf,
                port_id=uport2)

            self._multiNhopSequenceTest1(urif1, uport1_dev)
            self._multiNhopSequenceTest2(urif1, uport1_dev)
            self._multiNhopSequenceTest3(urif1, uport1_dev)
            self._multiNhopFallbackTest([[urif1, uport1_dev],
                                         [urif2, uport_dev2]])
            self._tunnelVniNexthopTest([[urif1, uport1_dev],
                                        [urif2, uport_dev2]])

        finally:
            sai_thrift_remove_router_interface(self.client, urif2)
            sai_thrift_remove_router_interface(self.client, urif1)

    # ECMP tunnel tests
    def _ecmpTunnelSequenceTest1(self, urif_data):
        '''
        Verify ECMP tunnel nexthop resolution for the following sequence
        of objects creation: Overlay Tunnel Nexthops -> Overlay ECMP
        -> Overlay ECMP Members -> Overlay Route -> Underlay Routes

        Args:
            urif_data (list): a list containing 3 pairs (underlay RIF,
                              underlay port)
        '''
        print("ECMP tunnel sequence 1")

        urif1 = urif_data[0][0]
        uport1 = urif_data[0][1]
        urif2 = urif_data[1][0]
        uport2 = urif_data[1][1]
        urif3 = urif_data[2][0]
        uport3 = urif_data[2][1]

        try:
            tunnel_nhop1 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            tunnel_nhop2 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip2),
                tunnel_mac=self.inner_dmac2,
                tunnel_vni=self.vni)

            tunnel_nhop3 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip3),
                tunnel_mac=self.inner_dmac3,
                tunnel_vni=self.vni)

            tunnel_ecmp = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            tunnel_ecmp_member1 = sai_thrift_create_next_hop_group_member(
                self.client,
                next_hop_group_id=tunnel_ecmp,
                next_hop_id=tunnel_nhop1)

            tunnel_ecmp_member2 = sai_thrift_create_next_hop_group_member(
                self.client,
                next_hop_group_id=tunnel_ecmp,
                next_hop_id=tunnel_nhop2)

            tunnel_ecmp_member3 = sai_thrift_create_next_hop_group_member(
                self.client,
                next_hop_group_id=tunnel_ecmp,
                next_hop_id=tunnel_nhop3)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_ecmp)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_ecmp)

            unhop1 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip1),
                                                router_interface_id=urif1,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            unbor1 = sai_thrift_neighbor_entry_t(
                rif_id=urif1, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor1,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            tunnel_route1 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route1,
                                          next_hop_id=unhop1)

            unhop2 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip2),
                                                router_interface_id=urif2,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            unbor2 = sai_thrift_neighbor_entry_t(
                rif_id=urif2, ip_address=sai_ipaddress(self.tun_ip2))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor2,
                                             dst_mac_address=self.unbor_mac2,
                                             no_host_route=True)

            tunnel_route2 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip2 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route2,
                                          next_hop_id=unhop2)

            unhop3 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip3),
                                                router_interface_id=urif3,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            unbor3 = sai_thrift_neighbor_entry_t(
                rif_id=urif3, ip_address=sai_ipaddress(self.tun_ip3))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor3,
                                             dst_mac_address=self.unbor_mac3,
                                             no_host_route=True)

            tunnel_route3 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip3 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route3,
                                          next_hop_id=unhop3)

            pkt_params = {
                uport1: {
                    "dmac": self.unbor_mac1,
                    "idmac": self.inner_dmac1,
                    "tun_ip": self.tun_ip1
                },
                uport2: {
                    "dmac": self.unbor_mac2,
                    "idmac": self.inner_dmac2,
                    "tun_ip": self.tun_ip2
                },
                uport3: {
                    "dmac": self.unbor_mac3,
                    "idmac": self.inner_dmac3,
                    "tun_ip": self.tun_ip3
                }
            }

            self._v4TrafficEcmpTest(pkt_params)
            self._v6TrafficEcmpTest(pkt_params)

        finally:
            sai_thrift_remove_route_entry(self.client, tunnel_route3)
            sai_thrift_remove_neighbor_entry(self.client, unbor3)
            sai_thrift_remove_next_hop(self.client, unhop3)
            sai_thrift_remove_route_entry(self.client, tunnel_route2)
            sai_thrift_remove_neighbor_entry(self.client, unbor2)
            sai_thrift_remove_next_hop(self.client, unhop2)
            sai_thrift_remove_route_entry(self.client, tunnel_route1)
            sai_thrift_remove_neighbor_entry(self.client, unbor1)
            sai_thrift_remove_next_hop(self.client, unhop1)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop_group_member(self.client,
                                                    tunnel_ecmp_member3)
            sai_thrift_remove_next_hop_group_member(self.client,
                                                    tunnel_ecmp_member2)
            sai_thrift_remove_next_hop_group_member(self.client,
                                                    tunnel_ecmp_member1)
            sai_thrift_remove_next_hop_group(self.client, tunnel_ecmp)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop3)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop2)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop1)

    def _ecmpTunnelSequenceTest2(self, urif_data):
        '''
        Verify ECMP tunnel nexthop resolution for the following sequence
        of objects creation: Overlay ECMP -> Overlay Routes ->
        Overlay Tunnel Nexthops -> Overlay ECMP Members -> Underlay Routes

        Args:
            urif_data (list): a list containing 3 pairs (underlay RIF,
                              underlay port)
        '''
        print("ECMP tunnel sequence 2")

        urif1 = urif_data[0][0]
        uport1 = urif_data[0][1]
        urif2 = urif_data[1][0]
        uport2 = urif_data[1][1]
        urif3 = urif_data[2][0]
        uport3 = urif_data[2][1]

        try:
            tunnel_ecmp = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_ecmp)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_ecmp)

            tunnel_nhop1 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            tunnel_nhop2 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip2),
                tunnel_mac=self.inner_dmac2,
                tunnel_vni=self.vni)

            tunnel_nhop3 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip3),
                tunnel_mac=self.inner_dmac3,
                tunnel_vni=self.vni)

            tunnel_ecmp_member1 = sai_thrift_create_next_hop_group_member(
                self.client,
                next_hop_group_id=tunnel_ecmp,
                next_hop_id=tunnel_nhop1)

            tunnel_ecmp_member2 = sai_thrift_create_next_hop_group_member(
                self.client,
                next_hop_group_id=tunnel_ecmp,
                next_hop_id=tunnel_nhop2)

            tunnel_ecmp_member3 = sai_thrift_create_next_hop_group_member(
                self.client,
                next_hop_group_id=tunnel_ecmp,
                next_hop_id=tunnel_nhop3)

            unhop1 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip1),
                                                router_interface_id=urif1,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            unbor1 = sai_thrift_neighbor_entry_t(
                rif_id=urif1, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor1,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            tunnel_route1 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route1,
                                          next_hop_id=unhop1)

            unhop2 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip2),
                                                router_interface_id=urif2,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            unbor2 = sai_thrift_neighbor_entry_t(
                rif_id=urif2, ip_address=sai_ipaddress(self.tun_ip2))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor2,
                                             dst_mac_address=self.unbor_mac2,
                                             no_host_route=True)

            tunnel_route2 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip2 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route2,
                                          next_hop_id=unhop2)

            unhop3 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip3),
                                                router_interface_id=urif3,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            unbor3 = sai_thrift_neighbor_entry_t(
                rif_id=urif3, ip_address=sai_ipaddress(self.tun_ip3))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor3,
                                             dst_mac_address=self.unbor_mac3,
                                             no_host_route=True)

            tunnel_route3 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip3 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route3,
                                          next_hop_id=unhop3)

            pkt_params = {
                uport1: {
                    "dmac": self.unbor_mac1,
                    "idmac": self.inner_dmac1,
                    "tun_ip": self.tun_ip1
                },
                uport2: {
                    "dmac": self.unbor_mac2,
                    "idmac": self.inner_dmac2,
                    "tun_ip": self.tun_ip2
                },
                uport3: {
                    "dmac": self.unbor_mac3,
                    "idmac": self.inner_dmac3,
                    "tun_ip": self.tun_ip3
                }
            }

            self._v4TrafficEcmpTest(pkt_params)
            self._v6TrafficEcmpTest(pkt_params)

        finally:
            sai_thrift_remove_route_entry(self.client, tunnel_route3)
            sai_thrift_remove_neighbor_entry(self.client, unbor3)
            sai_thrift_remove_next_hop(self.client, unhop3)
            sai_thrift_remove_route_entry(self.client, tunnel_route2)
            sai_thrift_remove_neighbor_entry(self.client, unbor2)
            sai_thrift_remove_next_hop(self.client, unhop2)
            sai_thrift_remove_route_entry(self.client, tunnel_route1)
            sai_thrift_remove_neighbor_entry(self.client, unbor1)
            sai_thrift_remove_next_hop(self.client, unhop1)
            sai_thrift_remove_next_hop_group_member(self.client,
                                                    tunnel_ecmp_member3)
            sai_thrift_remove_next_hop_group_member(self.client,
                                                    tunnel_ecmp_member2)
            sai_thrift_remove_next_hop_group_member(self.client,
                                                    tunnel_ecmp_member1)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop3)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop2)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop1)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop_group(self.client, tunnel_ecmp)

    def _ecmpTunnelSequenceTest3(self, urif_data):
        '''
        Verify ECMP tunnel nexthop resolution for the following sequence
        of objects creation: Overlay ECMP -> Overlay Route ->
        Underlay Routes -> Overlay Tunnel Nexthops -> Overlay ECMP Members

        Args:
            urif_data (list): a list containing 3 pairs (underlay RIF,
                              underlay port)
        '''
        print("ECMP tunnel sequence 3")

        urif1 = urif_data[0][0]
        uport1 = urif_data[0][1]
        urif2 = urif_data[1][0]
        uport2 = urif_data[1][1]
        urif3 = urif_data[2][0]
        uport3 = urif_data[2][1]

        try:
            tunnel_ecmp = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_ecmp)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_ecmp)

            unhop1 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip1),
                                                router_interface_id=urif1,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            unbor1 = sai_thrift_neighbor_entry_t(
                rif_id=urif1, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor1,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            tunnel_route1 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route1,
                                          next_hop_id=unhop1)

            unhop2 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip2),
                                                router_interface_id=urif2,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            unbor2 = sai_thrift_neighbor_entry_t(
                rif_id=urif2, ip_address=sai_ipaddress(self.tun_ip2))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor2,
                                             dst_mac_address=self.unbor_mac2,
                                             no_host_route=True)

            tunnel_route2 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip2 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route2,
                                          next_hop_id=unhop2)

            unhop3 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip3),
                                                router_interface_id=urif3,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            unbor3 = sai_thrift_neighbor_entry_t(
                rif_id=urif3, ip_address=sai_ipaddress(self.tun_ip3))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor3,
                                             dst_mac_address=self.unbor_mac3,
                                             no_host_route=True)

            tunnel_route3 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip3 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route3,
                                          next_hop_id=unhop3)

            tunnel_nhop1 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            tunnel_nhop2 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip2),
                tunnel_mac=self.inner_dmac2,
                tunnel_vni=self.vni)

            tunnel_nhop3 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip3),
                tunnel_mac=self.inner_dmac3,
                tunnel_vni=self.vni)

            tunnel_ecmp_member1 = sai_thrift_create_next_hop_group_member(
                self.client,
                next_hop_group_id=tunnel_ecmp,
                next_hop_id=tunnel_nhop1)

            tunnel_ecmp_member2 = sai_thrift_create_next_hop_group_member(
                self.client,
                next_hop_group_id=tunnel_ecmp,
                next_hop_id=tunnel_nhop2)

            tunnel_ecmp_member3 = sai_thrift_create_next_hop_group_member(
                self.client,
                next_hop_group_id=tunnel_ecmp,
                next_hop_id=tunnel_nhop3)

            pkt_params = {
                uport1: {
                    "dmac": self.unbor_mac1,
                    "idmac": self.inner_dmac1,
                    "tun_ip": self.tun_ip1
                },
                uport2: {
                    "dmac": self.unbor_mac2,
                    "idmac": self.inner_dmac2,
                    "tun_ip": self.tun_ip2
                },
                uport3: {
                    "dmac": self.unbor_mac3,
                    "idmac": self.inner_dmac3,
                    "tun_ip": self.tun_ip3
                }
            }

            self._v4TrafficEcmpTest(pkt_params)
            self._v6TrafficEcmpTest(pkt_params)

        finally:
            sai_thrift_remove_next_hop_group_member(self.client,
                                                    tunnel_ecmp_member3)
            sai_thrift_remove_next_hop_group_member(self.client,
                                                    tunnel_ecmp_member2)
            sai_thrift_remove_next_hop_group_member(self.client,
                                                    tunnel_ecmp_member1)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop3)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop2)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop1)
            sai_thrift_remove_route_entry(self.client, tunnel_route3)
            sai_thrift_remove_neighbor_entry(self.client, unbor3)
            sai_thrift_remove_next_hop(self.client, unhop3)
            sai_thrift_remove_route_entry(self.client, tunnel_route2)
            sai_thrift_remove_neighbor_entry(self.client, unbor2)
            sai_thrift_remove_next_hop(self.client, unhop2)
            sai_thrift_remove_route_entry(self.client, tunnel_route1)
            sai_thrift_remove_neighbor_entry(self.client, unbor1)
            sai_thrift_remove_next_hop(self.client, unhop1)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop_group(self.client, tunnel_ecmp)

    def _ecmpTunnelSequenceTest4(self, urif_data):
        '''
        Verify ECMP tunnel nexthop resolution for the following sequence
        of objects creation: Underlay Routes -> Overlay Tunnel
        Nexthops -> Overlay ECMP -> ECMP Members -> Overlay Route

        Args:
            urif_data (list): a list containing 3 pairs (underlay RIF,
                              underlay port)
        '''
        print("ECMP tunnel sequence 4")

        urif1 = urif_data[0][0]
        uport1 = urif_data[0][1]
        urif2 = urif_data[1][0]
        uport2 = urif_data[1][1]
        urif3 = urif_data[2][0]
        uport3 = urif_data[2][1]

        try:
            unhop1 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip1),
                                                router_interface_id=urif1,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            unbor1 = sai_thrift_neighbor_entry_t(
                rif_id=urif1, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor1,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            tunnel_route1 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route1,
                                          next_hop_id=unhop1)

            unhop2 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip2),
                                                router_interface_id=urif2,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            unbor2 = sai_thrift_neighbor_entry_t(
                rif_id=urif2, ip_address=sai_ipaddress(self.tun_ip2))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor2,
                                             dst_mac_address=self.unbor_mac2,
                                             no_host_route=True)

            tunnel_route2 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip2 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route2,
                                          next_hop_id=unhop2)

            unhop3 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip3),
                                                router_interface_id=urif3,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            unbor3 = sai_thrift_neighbor_entry_t(
                rif_id=urif3, ip_address=sai_ipaddress(self.tun_ip3))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor3,
                                             dst_mac_address=self.unbor_mac3,
                                             no_host_route=True)

            tunnel_route3 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip3 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route3,
                                          next_hop_id=unhop3)

            tunnel_nhop1 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            tunnel_nhop2 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip2),
                tunnel_mac=self.inner_dmac2,
                tunnel_vni=self.vni)

            tunnel_nhop3 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip3),
                tunnel_mac=self.inner_dmac3,
                tunnel_vni=self.vni)
            tunnel_ecmp = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            tunnel_ecmp_member1 = sai_thrift_create_next_hop_group_member(
                self.client,
                next_hop_group_id=tunnel_ecmp,
                next_hop_id=tunnel_nhop1)

            tunnel_ecmp_member2 = sai_thrift_create_next_hop_group_member(
                self.client,
                next_hop_group_id=tunnel_ecmp,
                next_hop_id=tunnel_nhop2)

            tunnel_ecmp_member3 = sai_thrift_create_next_hop_group_member(
                self.client,
                next_hop_group_id=tunnel_ecmp,
                next_hop_id=tunnel_nhop3)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_ecmp)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_ecmp)

            pkt_params = {
                uport1: {
                    "dmac": self.unbor_mac1,
                    "idmac": self.inner_dmac1,
                    "tun_ip": self.tun_ip1
                },
                uport2: {
                    "dmac": self.unbor_mac2,
                    "idmac": self.inner_dmac2,
                    "tun_ip": self.tun_ip2
                },
                uport3: {
                    "dmac": self.unbor_mac3,
                    "idmac": self.inner_dmac3,
                    "tun_ip": self.tun_ip3
                }
            }

            self._v4TrafficEcmpTest(pkt_params)
            self._v6TrafficEcmpTest(pkt_params)

        finally:
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop_group_member(self.client,
                                                    tunnel_ecmp_member3)
            sai_thrift_remove_next_hop_group_member(self.client,
                                                    tunnel_ecmp_member2)
            sai_thrift_remove_next_hop_group_member(self.client,
                                                    tunnel_ecmp_member1)
            sai_thrift_remove_next_hop_group(self.client, tunnel_ecmp)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop3)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop2)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop1)
            sai_thrift_remove_route_entry(self.client, tunnel_route3)
            sai_thrift_remove_neighbor_entry(self.client, unbor3)
            sai_thrift_remove_next_hop(self.client, unhop3)
            sai_thrift_remove_route_entry(self.client, tunnel_route2)
            sai_thrift_remove_neighbor_entry(self.client, unbor2)
            sai_thrift_remove_next_hop(self.client, unhop2)
            sai_thrift_remove_route_entry(self.client, tunnel_route1)
            sai_thrift_remove_neighbor_entry(self.client, unbor1)
            sai_thrift_remove_next_hop(self.client, unhop1)

    def _ecmpTunnelUpdateTest(self, urif_data):
        '''
        Verify ECMP tunnel nexthop resolution after ECMP gorup updates

        Args:
            urif_data (list): a list containing 3 pairs (underlay RIF,
                              underlay port)
        '''
        print("ECMP tunnel update")

        urif1 = urif_data[0][0]
        uport1 = urif_data[0][1]
        urif2 = urif_data[1][0]
        uport2 = urif_data[1][1]
        urif3 = urif_data[2][0]
        uport3 = urif_data[2][1]

        try:
            unhop1 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip1),
                                                router_interface_id=urif1,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            unbor1 = sai_thrift_neighbor_entry_t(
                rif_id=urif1, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor1,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            tunnel_route1 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route1,
                                          next_hop_id=unhop1)

            unhop2 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip2),
                                                router_interface_id=urif2,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            unbor2 = sai_thrift_neighbor_entry_t(
                rif_id=urif2, ip_address=sai_ipaddress(self.tun_ip2))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor2,
                                             dst_mac_address=self.unbor_mac2,
                                             no_host_route=True)

            tunnel_route2 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip2 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route2,
                                          next_hop_id=unhop2)

            unhop3 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip3),
                                                router_interface_id=urif3,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            unbor3 = sai_thrift_neighbor_entry_t(
                rif_id=urif3, ip_address=sai_ipaddress(self.tun_ip3))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor3,
                                             dst_mac_address=self.unbor_mac3,
                                             no_host_route=True)

            tunnel_route3 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip3 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route3,
                                          next_hop_id=unhop3)

            tunnel_nhop1 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            tunnel_nhop2 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip2),
                tunnel_mac=self.inner_dmac2,
                tunnel_vni=self.vni)

            tunnel_ecmp = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            tunnel_ecmp_member1 = sai_thrift_create_next_hop_group_member(
                self.client,
                next_hop_group_id=tunnel_ecmp,
                next_hop_id=tunnel_nhop1)

            tunnel_ecmp_member2 = sai_thrift_create_next_hop_group_member(
                self.client,
                next_hop_group_id=tunnel_ecmp,
                next_hop_id=tunnel_nhop2)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_ecmp)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_ecmp)

            print("Initial setup test")

            pkt_params = {
                uport1: {
                    "dmac": self.unbor_mac1,
                    "idmac": self.inner_dmac1,
                    "tun_ip": self.tun_ip1
                },
                uport2: {
                    "dmac": self.unbor_mac2,
                    "idmac": self.inner_dmac2,
                    "tun_ip": self.tun_ip2
                }
            }

            self._v4TrafficEcmpTest(pkt_params)
            self._v6TrafficEcmpTest(pkt_params)

            print("Removing one ECMP member - checking packet flow")
            sai_thrift_remove_next_hop_group_member(self.client,
                                                    tunnel_ecmp_member1)

            pkt_params = {
                uport2: {
                    "dmac": self.unbor_mac2,
                    "idmac": self.inner_dmac2,
                    "tun_ip": self.tun_ip2
                }
            }

            self._v4TrafficEcmpTest(pkt_params)
            self._v6TrafficEcmpTest(pkt_params)

            print("Removing all ECMP members - checking packet dropping")
            sai_thrift_remove_next_hop_group_member(self.client,
                                                    tunnel_ecmp_member2)

            self._v4TrafficMissTest()
            self._v6TrafficMissTest()

            print("Adding new ECMP member - checking packet flow")
            tunnel_nhop3 = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip3),
                tunnel_mac=self.inner_dmac3,
                tunnel_vni=self.vni)

            tunnel_ecmp_member3 = sai_thrift_create_next_hop_group_member(
                self.client,
                next_hop_group_id=tunnel_ecmp,
                next_hop_id=tunnel_nhop3)

            pkt_params = {
                uport3: {
                    "dmac": self.unbor_mac3,
                    "idmac": self.inner_dmac3,
                    "tun_ip": self.tun_ip3
                }
            }

            self._v4TrafficEcmpTest(pkt_params)
            self._v6TrafficEcmpTest(pkt_params)

        finally:
            sai_thrift_remove_next_hop_group_member(self.client,
                                                    tunnel_ecmp_member3)
            sai_thrift_remove_route_entry(self.client, tunnel_route3)
            sai_thrift_remove_neighbor_entry(self.client, unbor3)
            sai_thrift_remove_next_hop(self.client, unhop3)
            sai_thrift_remove_route_entry(self.client, tunnel_route2)
            sai_thrift_remove_neighbor_entry(self.client, unbor2)
            sai_thrift_remove_next_hop(self.client, unhop2)
            sai_thrift_remove_route_entry(self.client, tunnel_route1)
            sai_thrift_remove_neighbor_entry(self.client, unbor1)
            sai_thrift_remove_next_hop(self.client, unhop1)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop_group(self.client, tunnel_ecmp)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop3)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop2)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop1)

    def ecmpTunnelTest(self):
        '''
        Nexthop resolution tests with underlay ECMP
        '''
        print("\necmpTunnelTest()")

        uport1 = self.port25
        uport1_dev = self.dev_port25
        uport2 = self.port26
        uport_dev2 = self.dev_port26
        uport3 = self.port27
        uport_dev3 = self.dev_port27

        try:
            urif1 = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_PORT,
                virtual_router_id=self.uvrf,
                port_id=uport1)

            urif2 = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_PORT,
                virtual_router_id=self.uvrf,
                port_id=uport2)

            urif3 = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_PORT,
                virtual_router_id=self.uvrf,
                port_id=uport3)

            self._ecmpTunnelSequenceTest1([[urif1, uport1_dev],
                                           [urif2, uport_dev2],
                                           [urif3, uport_dev3]])
            self._ecmpTunnelSequenceTest2([[urif1, uport1_dev],
                                           [urif2, uport_dev2],
                                           [urif3, uport_dev3]])
            self._ecmpTunnelSequenceTest3([[urif1, uport1_dev],
                                           [urif2, uport_dev2],
                                           [urif3, uport_dev3]])
            self._ecmpTunnelSequenceTest4([[urif1, uport1_dev],
                                           [urif2, uport_dev2],
                                           [urif3, uport_dev3]])
            self._ecmpTunnelUpdateTest([[urif1, uport1_dev],
                                        [urif2, uport_dev2],
                                        [urif3, uport_dev3]])

        finally:
            sai_thrift_remove_router_interface(self.client, urif3)
            sai_thrift_remove_router_interface(self.client, urif2)
            sai_thrift_remove_router_interface(self.client, urif1)

    # Underlay ECMP tests
    def _ecmpSequenceTest1(self, uport, unhop):
        '''
        Verify nexthop resolution with underlay ECMP for the following
        sequence of objects creation: Underlay ECMP -> Underlay ECMP member ->
        Overlay Tunnel Nexthop -> Overlay Customer Route -> Underlay Route

        Args:
            uport (int): underlay port number
            unhop (oid): underlay nexthop object ID
        '''
        print("ECMP sequence 1")

        try:
            uecmp = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            uecmp_member = sai_thrift_create_next_hop_group_member(
                self.client, next_hop_group_id=uecmp, next_hop_id=unhop)

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=uecmp)

            self._v4TrafficTest([uport])
            self._v6TrafficTest([uport])

        finally:
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_next_hop_group_member(self.client, uecmp_member)
            sai_thrift_remove_next_hop_group(self.client, uecmp)

    def _ecmpSequenceTest2(self, uport, unhop):
        '''
        Verify nexthop resolution with underlay ECMP for the following
        sequence of objects creation: Overlay Tunnel Nexthop -> Overlay
        Customer Route -> Underlay ECMP -> Underlay Route -> Underlay ECMP
        member

        Args:
            uport (int): underlay port number
            unhop (oid): underlay nexthop object ID
        '''
        print("ECMP sequence 2")

        try:
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            uecmp = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=uecmp)

            uecmp_member = sai_thrift_create_next_hop_group_member(
                self.client, next_hop_group_id=uecmp, next_hop_id=unhop)

            self._v4TrafficTest([uport])
            self._v6TrafficTest([uport])

        finally:
            sai_thrift_remove_next_hop_group_member(self.client, uecmp_member)
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_next_hop_group(self.client, uecmp)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def _ecmpSequenceTest3(self, uport, unhop):
        '''
        Verify nexthop resolution with underlay ECMP for the following
        sequence of objects creation: Overlay Tunnel Nexthop -> Overlay
        Customer Route ->  Underlay ECMP -> Underlay ECMP Member -> Underlay
        Route

        Args:
            uport (int): underlay port number
            unhop (oid): underlay nexthop object ID
        '''
        print("ECMP sequence 3")

        try:
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            uecmp = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            uecmp_member = sai_thrift_create_next_hop_group_member(
                self.client, next_hop_group_id=uecmp, next_hop_id=unhop)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=uecmp)

            self._v4TrafficTest([uport])
            self._v6TrafficTest([uport])

        finally:
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_next_hop_group_member(self.client, uecmp_member)
            sai_thrift_remove_next_hop_group(self.client, uecmp)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def _ecmpSequenceTest4(self, uport, unhop):
        '''
        Verify nexthop resolution with underlay ECMP for the following
        sequence of objects creation: Underlay ECMP -> Underlay Route ->
        Overlay Tunnel Nexthop -> Overlay Customer Route -> Underlay ECMP
        Member

        Args:
            uport (int): underlay port number
            unhop (oid): underlay nexthop object ID
        '''
        print("ECMP sequence 4")

        try:
            uecmp = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=uecmp)

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            uecmp_member = sai_thrift_create_next_hop_group_member(
                self.client, next_hop_group_id=uecmp, next_hop_id=unhop)

            self._v4TrafficTest([uport])
            self._v6TrafficTest([uport])

        finally:
            sai_thrift_remove_next_hop_group_member(self.client, uecmp_member)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_next_hop_group(self.client, uecmp)

    def _ecmpSequenceTest5(self, uport, unhop):
        '''
        Verify nexthop resolution with underlay ECMP for the following
        sequence of objects creation: Overlay Tunnel Nexthop -> Underlay ECMP
        -> Underlay ECMP Member- > Underlay Route -> Overlay Customer Route

        Args:
            uport (int): underlay port number
            unhop (oid): underlay nexthop object ID
        '''
        print("ECMP sequence 5")

        try:
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            uecmp = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            uecmp_member = sai_thrift_create_next_hop_group_member(
                self.client, next_hop_group_id=uecmp, next_hop_id=unhop)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=uecmp)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            self._v4TrafficTest([uport])
            self._v6TrafficTest([uport])

        finally:
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_next_hop_group_member(self.client, uecmp_member)
            sai_thrift_remove_next_hop_group(self.client, uecmp)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def _ecmpRouteFallbackTest(self, uport, unhop):
        '''
        Verify nexthop resolution with underlay ECMP for route fallback case

        Args:
            uport (int): underlay port number
            unhop (oid): underlay nexthop object ID
        '''
        print("underlay ECMP fallback")

        uport2 = self.port26
        uport2_dev = self.dev_port26
        uport3 = self.port27
        uport3_dev = self.dev_port27

        try:
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            uecmp1 = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            uecmp1_member = sai_thrift_create_next_hop_group_member(
                self.client, next_hop_group_id=uecmp1, next_hop_id=unhop)

            tunnel_route1 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask3))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route1,
                                          next_hop_id=uecmp1)

            print("Sending packets via %s LPM ECMP route" % self.tun_ip_mask3)
            self._v4TrafficTest([uport])
            self._v6TrafficTest([uport])

            print("Adding %s LPM ECMP route" % self.tun_ip_mask2)
            urif2 = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_PORT,
                virtual_router_id=self.uvrf,
                port_id=uport2)

            unhop2 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip1),
                                                router_interface_id=urif2,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            unbor2 = sai_thrift_neighbor_entry_t(
                rif_id=urif2, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor2,
                                             dst_mac_address=self.unbor_mac2,
                                             no_host_route=True)

            uecmp2 = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            uecmp2_member = sai_thrift_create_next_hop_group_member(
                self.client, next_hop_group_id=uecmp2, next_hop_id=unhop2)

            tunnel_route2 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask2))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route2,
                                          next_hop_id=uecmp2)

            print("Sending packets via %s LPM ECMP route" % self.tun_ip_mask2)
            self._v4TrafficTest([uport2_dev], {"dmac": self.unbor_mac2})
            self._v6TrafficTest([uport2_dev], {"dmac": self.unbor_mac2})

            print("Removing %s LPM ECMP route" % self.tun_ip_mask2)
            sai_thrift_remove_route_entry(self.client, tunnel_route2)

            print("Sending packets via %s LPM ECMP route" % self.tun_ip_mask3)
            self._v4TrafficTest([uport])
            self._v6TrafficTest([uport])

            print("Adding regular %s route" % self.tun_ip_mask2)
            tunnel_route2 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask2))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route2,
                                          next_hop_id=unhop2)

            print("Sending packets via regular %s route" % self.tun_ip_mask2)
            self._v4TrafficTest([uport2_dev], {"dmac": self.unbor_mac2})
            self._v6TrafficTest([uport2_dev], {"dmac": self.unbor_mac2})

            print("Adding host ECMP route")
            urif3 = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_PORT,
                virtual_router_id=self.uvrf,
                port_id=uport3)

            unhop3 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip1),
                                                router_interface_id=urif3,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            unbor3 = sai_thrift_neighbor_entry_t(
                rif_id=urif3, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor3,
                                             dst_mac_address=self.unbor_mac3,
                                             no_host_route=True)

            uecmp3 = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            uecmp3_member = sai_thrift_create_next_hop_group_member(
                self.client, next_hop_group_id=uecmp3, next_hop_id=unhop3)

            tunnel_route3 = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route3,
                                          next_hop_id=uecmp3)

            print("Sending packets via host ECMP route")
            self._v4TrafficTest([uport3_dev], {"dmac": self.unbor_mac3})
            self._v6TrafficTest([uport3_dev], {"dmac": self.unbor_mac3})

        finally:
            sai_thrift_remove_route_entry(self.client, tunnel_route3)
            sai_thrift_remove_next_hop_group_member(self.client, uecmp3_member)
            sai_thrift_remove_next_hop_group(self.client, uecmp3)
            sai_thrift_remove_neighbor_entry(self.client, unbor3)
            sai_thrift_remove_next_hop(self.client, unhop3)
            sai_thrift_remove_router_interface(self.client, urif3)
            sai_thrift_remove_route_entry(self.client, tunnel_route2)
            sai_thrift_remove_next_hop_group_member(self.client, uecmp2_member)
            sai_thrift_remove_next_hop_group(self.client, uecmp2)
            sai_thrift_remove_neighbor_entry(self.client, unbor2)
            sai_thrift_remove_next_hop(self.client, unhop2)
            sai_thrift_remove_router_interface(self.client, urif2)
            sai_thrift_remove_route_entry(self.client, tunnel_route1)
            sai_thrift_remove_next_hop_group_member(self.client, uecmp1_member)
            sai_thrift_remove_next_hop_group(self.client, uecmp1)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def _ecmpUpdateTest(self, uport, unhop):
        '''
        Verify nexthop resolution for underlay ECMP update

        Args:
            uport (int): underlay port number
            unhop (oid): underlay nexthop object ID
        '''
        print("underlay ECMP update")

        uport2 = self.port26
        uport2_dev = self.dev_port26
        uport3 = self.port27
        uport3_dev = self.dev_port27

        try:
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(self.tun_ip1),
                tunnel_mac=self.inner_dmac1,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip1 + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv61 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=tunnel_nhop)

            uecmp = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            uecmp_member1 = sai_thrift_create_next_hop_group_member(
                self.client, next_hop_group_id=uecmp, next_hop_id=unhop)

            urif2 = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_PORT,
                virtual_router_id=self.uvrf,
                port_id=uport2)

            unhop2 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip1),
                                                router_interface_id=urif2,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            unbor2 = sai_thrift_neighbor_entry_t(
                rif_id=urif2, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor2,
                                             dst_mac_address=self.unbor_mac2,
                                             no_host_route=True)

            uecmp_member2 = sai_thrift_create_next_hop_group_member(
                self.client, next_hop_group_id=uecmp, next_hop_id=unhop2)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=uecmp)

            pkt_params = {
                uport: {
                    "dmac": self.unbor_mac1,
                    "idmac": self.inner_dmac1,
                    "tun_ip": self.tun_ip1
                },
                uport2_dev: {
                    "dmac": self.unbor_mac2,
                    "idmac": self.inner_dmac1,
                    "tun_ip": self.tun_ip1
                }
            }

            self._v4TrafficEcmpTest(pkt_params)
            self._v6TrafficEcmpTest(pkt_params)

            print("Removing one ECMP member - checking packet flow")
            sai_thrift_remove_next_hop_group_member(self.client, uecmp_member1)

            pkt_params = {
                uport2_dev: {
                    "dmac": self.unbor_mac2,
                    "idmac": self.inner_dmac1,
                    "tun_ip": self.tun_ip1
                }
            }

            self._v4TrafficEcmpTest(pkt_params)
            self._v6TrafficEcmpTest(pkt_params)

            print("Removing all ECMP members - checking packet dropping")
            sai_thrift_remove_next_hop_group_member(self.client, uecmp_member2)

            self._v4TrafficMissTest()
            self._v6TrafficMissTest()

            print("Adding new ECMP member - checking packet flow")
            urif3 = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_PORT,
                virtual_router_id=self.uvrf,
                port_id=uport3)

            unhop3 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip1),
                                                router_interface_id=urif3,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            unbor3 = sai_thrift_neighbor_entry_t(
                rif_id=urif3, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor3,
                                             dst_mac_address=self.unbor_mac3,
                                             no_host_route=True)

            uecmp_member3 = sai_thrift_create_next_hop_group_member(
                self.client, next_hop_group_id=uecmp, next_hop_id=unhop3)

            pkt_params = {
                uport3_dev: {
                    "dmac": self.unbor_mac3,
                    "idmac": self.inner_dmac1,
                    "tun_ip": self.tun_ip1
                }
            }

            self._v4TrafficEcmpTest(pkt_params)
            self._v6TrafficEcmpTest(pkt_params)

        finally:
            sai_thrift_remove_next_hop_group_member(self.client, uecmp_member3)
            sai_thrift_remove_neighbor_entry(self.client, unbor3)
            sai_thrift_remove_next_hop(self.client, unhop3)
            sai_thrift_remove_router_interface(self.client, urif3)
            sai_thrift_remove_route_entry(self.client, tunnel_route)
            sai_thrift_remove_neighbor_entry(self.client, unbor2)
            sai_thrift_remove_next_hop(self.client, unhop2)
            sai_thrift_remove_router_interface(self.client, urif2)
            sai_thrift_remove_next_hop_group(self.client, uecmp)
            sai_thrift_remove_route_entry(self.client, vm_v6_route)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def underlayEcmpTunnelTest(self):
        '''
        Verify tunnel underlay nexthop resolution with underlay ECMP
        '''
        print("\nunderlayEcmpTunnelTest()")

        uport = self.port25
        uport_dev = self.dev_port25

        try:
            urif = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_PORT,
                virtual_router_id=self.uvrf,
                port_id=uport)

            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(self.tun_ip1),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(self.tun_ip1))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=self.unbor_mac1,
                                             no_host_route=True)

            self._ecmpSequenceTest1(uport_dev, unhop)
            self._ecmpSequenceTest2(uport_dev, unhop)
            self._ecmpSequenceTest3(uport_dev, unhop)
            self._ecmpSequenceTest4(uport_dev, unhop)
            self._ecmpSequenceTest5(uport_dev, unhop)
            self._ecmpRouteFallbackTest(uport_dev, unhop)
            self._ecmpUpdateTest(uport_dev, unhop)

        finally:
            sai_thrift_remove_neighbor_entry(self.client, unbor)
            sai_thrift_remove_next_hop(self.client, unhop)
            sai_thrift_remove_router_interface(self.client, urif)


@group("draft")
class TunnelNhopResolutionIpv4UnderlayTest(TunnelNhopResolutionBase):
    '''
    Tests regarding different cases of nexthop resolution cases with
    IPv4 underlay
    '''

    def runTest(self):
        self.tunnelL3IntfTest()
        self.tunnelL3LagIntfTest()
        self.tunnelL3SubPortIntfTest()
        self.tunnelSviIntfTest()
        self.multiTunnelNhopTest()
        self.ecmpTunnelTest()
        self.underlayEcmpTunnelTest()


@group("draft")
class TunnelNhopResolutionIpv6UnderlayTest(TunnelNhopResolutionBase):
    '''
    Tests regarding different cases of nexthop resolution cases with
    IPv6 underlay
    '''

    def __init__(self):
        super(TunnelNhopResolutionIpv6UnderlayTest, self).__init__(ipv6=True)

    def runTest(self):
        self.tunnelL3IntfTest()
        self.tunnelL3LagIntfTest()
        self.tunnelL3SubPortIntfTest()
        self.tunnelSviIntfTest()
        self.multiTunnelNhopTest()
        self.ecmpTunnelTest()
        self.underlayEcmpTunnelTest()


# # # # # # # # VxLAN multiple tunnel forwarding tests follow # # # # # # # #
@group("draft")
class VxlanMultiTunnelBase(SaiHelper):
    '''
    Base configuration for multiple tunnel forwarding tests

    Args:
        ipv6 (bool): ipv6 underlay configuraton indicator
        multiple_ovrf (bool): multiple overlay VRFs indicator
    '''

    def __init__(self, ipv6=False, multiple_ovrf=False):
        super(VxlanMultiTunnelBase, self).__init__()
        self.ipv6 = ipv6
        self.multiple_ovrf = multiple_ovrf

        if self.ipv6 is True:
            self.tun1_ip = "2001:0db8::10:1"
            self.tun2_ip = "2001:0db8::20:1"
            self.lpb1_ip = "2001:0db8::10:10"
            self.lpb2_ip = "2001:0db8::20:20"
            self.tun_ip_mask = "/128"
        else:
            self.tun1_ip = "10.10.10.1"
            self.tun2_ip = "20.20.20.1"
            self.lpb1_ip = "10.10.10.10"
            self.lpb2_ip = "20.20.20.20"
            self.tun_ip_mask = "/32"

    def setUp(self):
        super(VxlanMultiTunnelBase, self).setUp()

        self.oport = self.port24
        self.oport_dev = self.dev_port24
        if self.multiple_ovrf is True:
            self.oport2 = self.port25
            self.oport2_dev = self.dev_port25
        self.uport1 = self.port26
        self.uport1_dev = self.dev_port26
        self.uport2 = self.port27
        self.uport2_dev = self.dev_port27

        self.vni1 = 1000
        self.vni2 = 2000
        self.vm1_ip = "100.100.1.1"
        self.vm1_ipv6 = "2001:0db8::100:1"
        self.vm2_ip = "200.200.1.1"
        self.vm2_ipv6 = "2001:0db8::200:1"
        self.customer1_ip = "100.100.2.1"
        self.customer1_ipv6 = "2001:0db8::100:2"
        self.customer2_ip = "200.200.2.1"
        self.customer2_ipv6 = "2001:0db8::200:2"
        self.inner_dmac = "00:11:11:11:11:11"
        self.customer1_mac = "00:22:22:22:22:11"
        self.customer2_mac = "00:22:22:22:22:22"
        self.unbor1_mac = "00:33:33:33:33:11"
        self.unbor2_mac = "00:33:33:33:33:22"
        self.vxlan_global_mac = "00:aa:aa:aa:aa:aa"

        sai_thrift_set_switch_attribute(
            self.client, vxlan_default_router_mac=self.vxlan_global_mac)

        # underlay configuration
        self.uvrf1 = sai_thrift_create_virtual_router(self.client)
        self.uvrf2 = sai_thrift_create_virtual_router(self.client)

        # overlay configuraion
        self.ovrf = sai_thrift_create_virtual_router(self.client)
        if self.multiple_ovrf is True:
            self.ovrf2 = sai_thrift_create_virtual_router(self.client)

        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2MP
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL

        self.orif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.ovrf,
            port_id=self.oport)

        if self.multiple_ovrf is True:
            self.orif2 = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_PORT,
                virtual_router_id=self.ovrf2,
                port_id=self.oport2)

        # underlay loopback RIFs for tunnels
        self.urif1_lpb = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_LOOPBACK,
            virtual_router_id=self.uvrf1)
        self.urif2_lpb = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_LOOPBACK,
            virtual_router_id=self.uvrf2)

        # route to tunnel 1
        self.urif1 = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.uvrf1,
            port_id=self.uport1)

        self.unhop1 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.tun1_ip),
            router_interface_id=self.urif1,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.unbor1 = sai_thrift_neighbor_entry_t(
            rif_id=self.urif1, ip_address=sai_ipaddress(self.tun1_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.unbor1,
                                         dst_mac_address=self.unbor1_mac,
                                         no_host_route=True)

        self.tunnel1_route = sai_thrift_route_entry_t(
            vr_id=self.uvrf1,
            destination=sai_ipprefix(self.tun1_ip + self.tun_ip_mask))
        sai_thrift_create_route_entry(self.client,
                                      self.tunnel1_route,
                                      next_hop_id=self.unhop1)

        # route to tunnel 2
        self.urif2 = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.uvrf2,
            port_id=self.uport2)

        self.unhop2 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.tun2_ip),
            router_interface_id=self.urif2,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.unbor2 = sai_thrift_neighbor_entry_t(
            rif_id=self.urif2, ip_address=sai_ipaddress(self.tun2_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.unbor2,
                                         dst_mac_address=self.unbor2_mac,
                                         no_host_route=True)

        self.tunnel2_route = sai_thrift_route_entry_t(
            vr_id=self.uvrf2,
            destination=sai_ipprefix(self.tun2_ip + self.tun_ip_mask))
        sai_thrift_create_route_entry(self.client,
                                      self.tunnel2_route,
                                      next_hop_id=self.unhop2)

        # encap/decap mappers
        self.encap_tunnel_map = sai_thrift_create_tunnel_map(
            self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

        self.decap_tunnel_map = sai_thrift_create_tunnel_map(
            self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

        # encap/decap mapper entries
        self.encap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
            self.client,
            tunnel_map=self.encap_tunnel_map,
            tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
            virtual_router_id_key=self.ovrf,
            vni_id_value=self.vni1)

        self.decap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
            self.client,
            tunnel_map=self.encap_tunnel_map,
            tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
            virtual_router_id_value=self.ovrf,
            vni_id_key=self.vni1)

        encap_maps = sai_thrift_object_list_t(count=1,
                                              idlist=[self.encap_tunnel_map])
        decap_maps = sai_thrift_object_list_t(count=1,
                                              idlist=[self.decap_tunnel_map])

        if self.multiple_ovrf is True:
            self.encap_tunnel_map_entry2 = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=self.encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
                virtual_router_id_key=self.ovrf2,
                vni_id_value=self.vni2)

            self.decap_tunnel_map_entry2 = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=self.encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
                virtual_router_id_value=self.ovrf2,
                vni_id_key=self.vni2)

            encap_maps2 = sai_thrift_object_list_t(
                count=1, idlist=[self.encap_tunnel_map])
            decap_maps2 = sai_thrift_object_list_t(
                count=1, idlist=[self.decap_tunnel_map])

        # tunnels
        self.tunnel1 = sai_thrift_create_tunnel(
            self.client,
            type=tunnel_type,
            encap_src_ip=sai_ipaddress(self.lpb1_ip),
            encap_mappers=encap_maps,
            decap_mappers=decap_maps,
            encap_ttl_mode=ttl_mode,
            decap_ttl_mode=ttl_mode,
            underlay_interface=self.urif1_lpb)

        self.tunnel2 = sai_thrift_create_tunnel(
            self.client,
            type=tunnel_type,
            encap_src_ip=sai_ipaddress(self.lpb2_ip),
            encap_mappers=encap_maps
            if not self.multiple_ovrf else encap_maps2,
            decap_mappers=decap_maps
            if not self.multiple_ovrf else decap_maps2,
            encap_ttl_mode=ttl_mode,
            decap_ttl_mode=ttl_mode,
            underlay_interface=self.urif2_lpb)

        # tunnel termination entries
        self.tunnel1_term = sai_thrift_create_tunnel_term_table_entry(
            self.client,
            tunnel_type=tunnel_type,
            vr_id=self.uvrf1,
            action_tunnel_id=self.tunnel1,
            type=term_type,
            dst_ip=sai_ipaddress(self.lpb1_ip))

        self.tunnel2_term = sai_thrift_create_tunnel_term_table_entry(
            self.client,
            tunnel_type=tunnel_type,
            vr_id=self.uvrf2,
            action_tunnel_id=self.tunnel2,
            type=term_type,
            dst_ip=sai_ipaddress(self.lpb2_ip))

        # tunnel nexthop for VM 1
        # uses global vxlan dmac
        self.tunnel_nhop = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
            tunnel_id=self.tunnel1,
            ip=sai_ipaddress(self.tun1_ip),
            tunnel_vni=self.vni1)

        # routes to VM via tunnel nexthop
        self.vm1_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf, destination=sai_ipprefix(self.vm1_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.vm1_route,
                                      next_hop_id=self.tunnel_nhop)

        self.vm1_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf, destination=sai_ipprefix(self.vm1_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.vm1_v6_route,
                                      next_hop_id=self.tunnel_nhop)

        # tunnel nexthop for VM 2
        self.tunnel2_nhop = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
            tunnel_id=self.tunnel2,
            ip=sai_ipaddress(self.tun2_ip),
            tunnel_mac=self.inner_dmac,
            tunnel_vni=self.vni2)

        # routes to VM via tunnel nexthop
        self.vm2_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf if not self.multiple_ovrf else self.ovrf2,
            destination=sai_ipprefix(self.vm2_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.vm2_route,
                                      next_hop_id=self.tunnel2_nhop)

        self.vm2_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf if not self.multiple_ovrf else self.ovrf2,
            destination=sai_ipprefix(self.vm2_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.vm2_v6_route,
                                      next_hop_id=self.tunnel2_nhop)

        # routes to customer from VM
        self.onhop1 = sai_thrift_create_next_hop(
            self.client, ip=sai_ipaddress(self.customer1_ip),
            router_interface_id=self.orif, type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor1 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif, ip_address=sai_ipaddress(self.customer1_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor1,
                                         dst_mac_address=self.vxlan_global_mac,
                                         no_host_route=True)

        self.customer1_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(self.customer1_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer1_route,
                                      next_hop_id=self.onhop1)

        self.onhop1_v6 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer1_ipv6),
            router_interface_id=self.orif,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor1_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif, ip_address=sai_ipaddress(self.customer1_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor1_v6,
                                         dst_mac_address=self.vxlan_global_mac,
                                         no_host_route=True)

        self.customer1_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(self.customer1_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer1_v6_route,
                                      next_hop_id=self.onhop1_v6)

        self.onhop2 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer2_ip),
            router_interface_id=self.orif
            if not self.multiple_ovrf else self.orif2,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor2 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif if not self.multiple_ovrf else self.orif2,
            ip_address=sai_ipaddress(self.customer2_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor2,
                                         dst_mac_address=self.customer2_mac,
                                         no_host_route=True)

        self.customer2_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf if not self.multiple_ovrf else self.ovrf2,
            destination=sai_ipprefix(self.customer2_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer2_route,
                                      next_hop_id=self.onhop2)

        self.onhop2_v6 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer2_ipv6),
            router_interface_id=self.orif
            if not self.multiple_ovrf else self.orif2,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor2_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif if not self.multiple_ovrf else self.orif2,
            ip_address=sai_ipaddress(self.customer2_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor2_v6,
                                         dst_mac_address=self.customer2_mac,
                                         no_host_route=True)

        self.customer2_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf if not self.multiple_ovrf else self.ovrf2,
            destination=sai_ipprefix(self.customer2_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer2_v6_route,
                                      next_hop_id=self.onhop2_v6)

    def tearDown(self):
        sai_thrift_remove_route_entry(self.client, self.customer2_v6_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor2_v6)
        sai_thrift_remove_next_hop(self.client, self.onhop2_v6)
        sai_thrift_remove_route_entry(self.client, self.customer2_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor2)
        sai_thrift_remove_next_hop(self.client, self.onhop2)
        sai_thrift_remove_route_entry(self.client, self.customer1_v6_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor1_v6)
        sai_thrift_remove_next_hop(self.client, self.onhop1_v6)
        sai_thrift_remove_route_entry(self.client, self.customer1_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor1)
        sai_thrift_remove_next_hop(self.client, self.onhop1)
        sai_thrift_remove_route_entry(self.client, self.vm2_v6_route)
        sai_thrift_remove_route_entry(self.client, self.vm2_route)
        sai_thrift_remove_next_hop(self.client, self.tunnel2_nhop)
        sai_thrift_remove_route_entry(self.client, self.vm1_v6_route)
        sai_thrift_remove_route_entry(self.client, self.vm1_route)
        sai_thrift_remove_next_hop(self.client, self.tunnel_nhop)
        sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                  self.tunnel2_term)
        sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                  self.tunnel1_term)
        sai_thrift_remove_tunnel(self.client, self.tunnel2)
        sai_thrift_remove_tunnel(self.client, self.tunnel1)
        if self.multiple_ovrf is True:
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               self.decap_tunnel_map_entry2)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               self.encap_tunnel_map_entry2)
        sai_thrift_remove_tunnel_map_entry(self.client,
                                           self.decap_tunnel_map_entry)
        sai_thrift_remove_tunnel_map_entry(self.client,
                                           self.encap_tunnel_map_entry)
        sai_thrift_remove_tunnel_map(self.client, self.decap_tunnel_map)
        sai_thrift_remove_tunnel_map(self.client, self.encap_tunnel_map)
        sai_thrift_remove_route_entry(self.client, self.tunnel2_route)
        sai_thrift_remove_neighbor_entry(self.client, self.unbor2)
        sai_thrift_remove_next_hop(self.client, self.unhop2)
        sai_thrift_remove_router_interface(self.client, self.urif2)
        sai_thrift_remove_route_entry(self.client, self.tunnel1_route)
        sai_thrift_remove_neighbor_entry(self.client, self.unbor1)
        sai_thrift_remove_next_hop(self.client, self.unhop1)
        sai_thrift_remove_router_interface(self.client, self.urif1)
        sai_thrift_remove_router_interface(self.client, self.urif2_lpb)
        sai_thrift_remove_router_interface(self.client, self.urif1_lpb)
        if self.multiple_ovrf is True:
            sai_thrift_remove_router_interface(self.client, self.orif2)
        sai_thrift_remove_router_interface(self.client, self.orif)
        if self.multiple_ovrf is True:
            sai_thrift_remove_virtual_router(self.client, self.ovrf2)
        sai_thrift_remove_virtual_router(self.client, self.ovrf)
        sai_thrift_remove_virtual_router(self.client, self.uvrf2)
        sai_thrift_remove_virtual_router(self.client, self.uvrf1)

        sai_thrift_set_switch_attribute(
            self.client, vxlan_default_router_mac="00:00:00:00:00:00")

        super(VxlanMultiTunnelBase, self).tearDown()

    def multipleTunnelIpv4Test(self):
        '''
        Verify multi tunnel forwarding with single overlay VRF andmultiple
        underlay VRFs with IPv4 overlay packet
        '''
        print("\nmultipleTunnelIpv4Test()")

        # Tunnel 1
        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=self.customer1_mac,
                                ip_dst=self.vm1_ip,
                                ip_src=self.customer1_ip,
                                ip_id=108,
                                ip_ttl=64)
        inner_pkt = simple_udp_packet(eth_dst=self.vxlan_global_mac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.vm1_ip,
                                      ip_src=self.customer1_ip,
                                      ip_id=108,
                                      ip_ttl=63)
        if self.ipv6 is False:
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor1_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun1_ip,
                                    ip_src=self.lpb1_ip,
                                    ip_id=0,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni1,
                                    inner_frame=inner_pkt))
        else:
            vxlan_pkt = Mask(
                simple_vxlanv6_packet(eth_dst=self.unbor1_mac,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=self.tun1_ip,
                                      ipv6_src=self.lpb1_ip,
                                      ipv6_hlim=64,
                                      with_udp_chksum=False,
                                      vxlan_vni=self.vni1,
                                      inner_frame=inner_pkt))
        vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

        print("Sending IPv4 packet from Access port %d to VxLAN port %d" %
              (self.oport_dev, self.uport1_dev))
        send_packet(self, self.oport_dev, pkt)
        verify_packet(self, vxlan_pkt, self.uport1_dev)
        print("\tOK")

        pkt = simple_udp_packet(eth_dst=self.vxlan_global_mac,
                                eth_src=ROUTER_MAC,
                                ip_dst=self.customer1_ip,
                                ip_src=self.vm1_ip,
                                ip_id=108,
                                ip_ttl=63)
        inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.vxlan_global_mac,
                                      ip_dst=self.customer1_ip,
                                      ip_src=self.vm1_ip,
                                      ip_id=108,
                                      ip_ttl=64)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor1_mac,
                                            ip_dst=self.lpb1_ip,
                                            ip_src=self.tun1_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni1,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor1_mac,
                                              ipv6_dst=self.lpb1_ip,
                                              ipv6_src=self.tun1_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni1,
                                              inner_frame=inner_pkt)

        print("Sending IPv4 packet from VxLAN port %d to Access port %d" %
              (self.uport1_dev, self.oport_dev))
        send_packet(self, self.uport1_dev, vxlan_pkt)
        verify_packet(self, pkt, self.oport_dev)
        print("\tOK")

        # Tunnel 2
        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=self.customer2_mac,
                                ip_dst=self.vm2_ip,
                                ip_src=self.customer2_ip,
                                ip_id=108,
                                ip_ttl=64)
        inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.vm2_ip,
                                      ip_src=self.customer2_ip,
                                      ip_id=108,
                                      ip_ttl=63)
        if self.ipv6 is False:
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor2_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun2_ip,
                                    ip_src=self.lpb2_ip,
                                    ip_id=0,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni2,
                                    inner_frame=inner_pkt))
        else:
            vxlan_pkt = Mask(
                simple_vxlanv6_packet(eth_dst=self.unbor2_mac,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=self.tun2_ip,
                                      ipv6_src=self.lpb2_ip,
                                      ipv6_hlim=64,
                                      with_udp_chksum=False,
                                      vxlan_vni=self.vni2,
                                      inner_frame=inner_pkt))
        vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

        print("Sending IPv4 packet from Access port %d to VxLAN port %d" %
              ((self.oport_dev if not self.multiple_ovrf else self.oport2_dev),
               self.uport2_dev))
        if self.multiple_ovrf is False:
            send_packet(self, self.oport_dev, pkt)
        else:
            send_packet(self, self.oport2_dev, pkt)
        verify_packet(self, vxlan_pkt, self.uport2_dev)
        print("\tOK")

        pkt = simple_udp_packet(eth_dst=self.customer2_mac,
                                eth_src=ROUTER_MAC,
                                ip_dst=self.customer2_ip,
                                ip_src=self.vm2_ip,
                                ip_id=108,
                                ip_ttl=63)
        inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.inner_dmac,
                                      ip_dst=self.customer2_ip,
                                      ip_src=self.vm2_ip,
                                      ip_id=108,
                                      ip_ttl=64)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(
                eth_dst=ROUTER_MAC,
                eth_src=self.unbor1_mac,
                ip_dst=self.lpb2_ip,
                ip_src=self.tun2_ip,
                ip_id=0,
                ip_ttl=64,
                ip_flags=0x2,
                udp_sport=11638,
                with_udp_chksum=False,
                vxlan_vni=self.vni1 if not self.multiple_ovrf else self.vni2,
                inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(
                eth_dst=ROUTER_MAC,
                eth_src=self.unbor1_mac,
                ipv6_dst=self.lpb2_ip,
                ipv6_src=self.tun2_ip,
                ipv6_hlim=64,
                udp_sport=11638,
                with_udp_chksum=False,
                vxlan_vni=self.vni1 if not self.multiple_ovrf else self.vni2,
                inner_frame=inner_pkt)

        print("Sending IPv4 packet from VxLAN port %d to Access port %d" %
              (self.uport2_dev,
               self.oport_dev if not self.multiple_ovrf else self.oport2_dev))
        send_packet(self, self.uport2_dev, vxlan_pkt)
        if self.multiple_ovrf is False:
            verify_packet(self, pkt, self.oport_dev)
        else:
            verify_packet(self, pkt, self.oport2_dev)
        print("\tOK")

    def multipleTunnelIpv6Test(self):
        '''
        Verify multi tunnel forwarding with single overlay VRF andmultiple
        underlay VRFs with IPv6 overlay packet
        '''
        print("\nmultipleTunnelIpv6Test()")

        # Tunnel 1
        pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                  eth_src=self.customer1_mac,
                                  ipv6_dst=self.vm1_ipv6,
                                  ipv6_src=self.customer1_ipv6,
                                  ipv6_hlim=64)
        inner_pkt = simple_udpv6_packet(eth_dst=self.vxlan_global_mac,
                                        eth_src=ROUTER_MAC,
                                        ipv6_dst=self.vm1_ipv6,
                                        ipv6_src=self.customer1_ipv6,
                                        ipv6_hlim=63)
        if self.ipv6 is False:
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor1_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun1_ip,
                                    ip_src=self.lpb1_ip,
                                    ip_id=0,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni1,
                                    inner_frame=inner_pkt))
        else:
            vxlan_pkt = Mask(
                simple_vxlanv6_packet(eth_dst=self.unbor1_mac,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=self.tun1_ip,
                                      ipv6_src=self.lpb1_ip,
                                      ipv6_hlim=64,
                                      with_udp_chksum=False,
                                      vxlan_vni=self.vni1,
                                      inner_frame=inner_pkt))
        vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

        print("Sending IPv6 packet from Access port %d to VxLAN port %d" %
              (self.oport_dev, self.uport1_dev))
        send_packet(self, self.oport_dev, pkt)
        verify_packet(self, vxlan_pkt, self.uport1_dev)
        print("\tOK")

        inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.vxlan_global_mac,
                                        ipv6_dst=self.customer1_ipv6,
                                        ipv6_src=self.vm1_ipv6,
                                        ipv6_hlim=64)
        pkt = simple_udpv6_packet(eth_dst=self.vxlan_global_mac,
                                  eth_src=ROUTER_MAC,
                                  ipv6_dst=self.customer1_ipv6,
                                  ipv6_src=self.vm1_ipv6,
                                  ipv6_hlim=63)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor1_mac,
                                            ip_dst=self.lpb1_ip,
                                            ip_src=self.tun1_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni1,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor1_mac,
                                              ipv6_dst=self.lpb1_ip,
                                              ipv6_src=self.tun1_ip,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni1,
                                              inner_frame=inner_pkt)

        print("Sending IPv6 packet from VxLAN port %d to Access port %d" %
              (self.uport1_dev, self.oport_dev))
        send_packet(self, self.uport1_dev, vxlan_pkt)
        verify_packet(self, pkt, self.oport_dev)
        print("\tOK")

        # Tunnel 2
        pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                  eth_src=self.customer2_mac,
                                  ipv6_dst=self.vm2_ipv6,
                                  ipv6_src=self.customer2_ipv6,
                                  ipv6_hlim=64)
        inner_pkt = simple_udpv6_packet(eth_dst=self.inner_dmac,
                                        eth_src=ROUTER_MAC,
                                        ipv6_dst=self.vm2_ipv6,
                                        ipv6_src=self.customer2_ipv6,
                                        ipv6_hlim=63)
        if self.ipv6 is False:
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor2_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun2_ip,
                                    ip_src=self.lpb2_ip,
                                    ip_id=0,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni2,
                                    inner_frame=inner_pkt))
        else:
            vxlan_pkt = Mask(
                simple_vxlanv6_packet(eth_dst=self.unbor2_mac,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=self.tun2_ip,
                                      ipv6_src=self.lpb2_ip,
                                      ipv6_hlim=64,
                                      with_udp_chksum=False,
                                      vxlan_vni=self.vni2,
                                      inner_frame=inner_pkt))
        vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

        print("Sending IPv6 packet from Access port %d to VxLAN port %d" %
              (self.oport_dev if not self.multiple_ovrf else self.oport2_dev,
               self.uport2_dev))
        if self.multiple_ovrf is False:
            send_packet(self, self.oport_dev, pkt)
        else:
            send_packet(self, self.oport2_dev, pkt)
        verify_packet(self, vxlan_pkt, self.uport2_dev)
        print("\tOK")

        pkt = simple_udpv6_packet(eth_dst=self.customer2_mac,
                                  eth_src=ROUTER_MAC,
                                  ipv6_dst=self.customer2_ipv6,
                                  ipv6_src=self.vm2_ipv6,
                                  ipv6_hlim=63)
        inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.inner_dmac,
                                        ipv6_dst=self.customer2_ipv6,
                                        ipv6_src=self.vm2_ipv6,
                                        ipv6_hlim=64)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(
                eth_dst=ROUTER_MAC,
                eth_src=self.unbor1_mac,
                ip_dst=self.lpb2_ip,
                ip_src=self.tun2_ip,
                ip_id=0,
                ip_ttl=64,
                ip_flags=0x2,
                udp_sport=11638,
                with_udp_chksum=False,
                vxlan_vni=self.vni1 if not self.multiple_ovrf else self.vni2,
                inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(
                eth_dst=ROUTER_MAC,
                eth_src=self.unbor1_mac,
                ipv6_dst=self.lpb2_ip,
                ipv6_src=self.tun2_ip,
                ipv6_hlim=64,
                udp_sport=11638,
                with_udp_chksum=False,
                vxlan_vni=self.vni1 if not self.multiple_ovrf else self.vni2,
                inner_frame=inner_pkt)

        print("Sending IPv6 packet from VxLAN port %d to Access port %d" %
              (self.uport2_dev,
               self.oport_dev if not self.multiple_ovrf else self.oport2_dev))
        send_packet(self, self.uport2_dev, vxlan_pkt)
        if self.multiple_ovrf is False:
            verify_packet(self, pkt, self.oport_dev)
        else:
            verify_packet(self, pkt, self.oport2_dev)
        print("\tOK")


@group("draft")
class SingleOvrfMultiTunnelIpv4UnderlayTest(VxlanMultiTunnelBase):
    '''
    This class tests multiple tunnel configuration with single overlay VRF
    IPv4 underlay layer
    '''

    def runTest(self):
        self.multipleTunnelIpv4Test()
        self.multipleTunnelIpv6Test()


@group("draft")
class MultipleOvrfMultiTunnelIpv4UnderlayTest(VxlanMultiTunnelBase):
    '''
    This class tests multiple tunnel configuration with multiple overlay VRF
    IPv4 underlay layer
    '''

    def __init__(self):
        super(MultipleOvrfMultiTunnelIpv4UnderlayTest, self).__init__(
            multiple_ovrf=True)

    def runTest(self):
        self.multipleTunnelIpv4Test()
        self.multipleTunnelIpv6Test()


@group("draft")
class SingleOvrfMultiTunnelIpv6UnderlayTest(VxlanMultiTunnelBase):
    '''
    This class tests multiple tunnel configuration with single overlay VRF
    IPv6 underlay layer
    '''

    def __init__(self):
        super(SingleOvrfMultiTunnelIpv6UnderlayTest, self).__init__(
            ipv6=True)

    def runTest(self):
        self.multipleTunnelIpv4Test()
        self.multipleTunnelIpv6Test()


@group("draft")
class MultipleOvrfMultiTunnelIpv6UnderlayTest(VxlanMultiTunnelBase):
    '''
    This class tests multiple tunnel configuration with multiple overlay VRF
    IPv6 underlay layer
    '''

    def __init__(self):
        super(MultipleOvrfMultiTunnelIpv6UnderlayTest, self).__init__(
            ipv6=True, multiple_ovrf=True)

    def runTest(self):
        self.multipleTunnelIpv4Test()
        self.multipleTunnelIpv6Test()


# # # # # # # # # # # # Tunnel attributes tests follow # # # # # # # # # # # #
@group("draft")
class TunnelAttributesTest(SaiHelper):
    '''
    Tunnel-related attributes tests
    '''

    def setUp(self):
        super(TunnelAttributesTest, self).setUp()

        self.oport = self.port24
        self.oport_dev = self.dev_port24
        self.uport = self.port25
        self.uport_dev = self.dev_port25

        self.vni = 1000
        self.tun_ip = "10.10.10.1"
        self.tun_ipv6 = "2001:0db8::10:1"
        self.lpb_ip = "10.10.10.2"
        self.lpb_ipv6 = "2001:0db8::10:10"
        self.vm_ip = "100.100.1.1"
        self.vm_ipv6 = "2001:0db8::100:1"
        self.customer_ip = "100.100.2.1"
        self.customer_ipv6 = "2001:0db8::100:2"
        self.customer2_ip = "100.200.3.4"
        self.inner_dmac = "00:11:11:11:11:11"
        self.customer_mac = "00:22:22:22:22:22"
        self.customer2_mac = "00:22:22:22:22:55"
        self.unbor_mac = "00:33:33:33:33:33"
        self.ovlan_no = 50

        # underlay configuration
        self.uvrf = sai_thrift_create_virtual_router(self.client)

        # overlay configuraion
        self.ovrf = sai_thrift_create_virtual_router(self.client)

        # underlay loopback RIF for tunnel
        self.urif_lpb = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_LOOPBACK,
            virtual_router_id=self.uvrf)

        self.orif_lpb = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_LOOPBACK,
            virtual_router_id=self.ovrf)

        self.urif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.uvrf,
            port_id=self.uport)

        # route to tunnel
        self.unhop = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip),
                                                router_interface_id=self.urif,
                                                type=SAI_NEXT_HOP_TYPE_IP)

        self.unhop_v6 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.tun_ipv6),
            router_interface_id=self.urif,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.unbor = sai_thrift_neighbor_entry_t(
            rif_id=self.urif, ip_address=sai_ipaddress(self.tun_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.unbor,
                                         dst_mac_address=self.unbor_mac,
                                         no_host_route=True)

        self.unbor_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.urif, ip_address=sai_ipaddress(self.tun_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.unbor_v6,
                                         dst_mac_address=self.unbor_mac,
                                         no_host_route=True)

        self.tunnel_route = sai_thrift_route_entry_t(
            vr_id=self.uvrf, destination=sai_ipprefix(self.tun_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.tunnel_route,
                                      next_hop_id=self.unhop)

        self.tunnel_route_v6 = sai_thrift_route_entry_t(
            vr_id=self.uvrf, destination=sai_ipprefix(self.tun_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.tunnel_route_v6,
                                      next_hop_id=self.unhop_v6)

        self.orif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.ovrf,
            port_id=self.oport)

        # route to customer from VM
        self.onhop = sai_thrift_create_next_hop(
            self.client, ip=sai_ipaddress(self.customer_ip),
            router_interface_id=self.orif, type=SAI_NEXT_HOP_TYPE_IP)

        self.onhop_v6 = sai_thrift_create_next_hop(
            self.client, ip=sai_ipaddress(self.customer_ipv6),
            router_interface_id=self.orif, type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor = sai_thrift_neighbor_entry_t(
            rif_id=self.orif, ip_address=sai_ipaddress(self.customer_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor,
                                         dst_mac_address=self.customer_mac,
                                         no_host_route=True)

        self.onbor_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif, ip_address=sai_ipaddress(self.customer_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor_v6,
                                         dst_mac_address=self.customer_mac,
                                         no_host_route=True)

        self.customer_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(self.customer_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer_route,
                                      next_hop_id=self.onhop)

        self.customer_route_v6 = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(self.customer_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer_route_v6,
                                      next_hop_id=self.onhop_v6)

    def runTest(self):
        self.encapTtlPipeModeVxlanTest()
        self.encapTtlPipeModeIpInIpTest()
        self.encapTtlPipeModeIpv6InIpv6Test()
        self.decapTtlPipeModeVxlanTest()
        self.decapTtlPipeModeIpInIpTest()
        self.decapTtlPipeModeIpv6InIpv6Test()
        self.encapDscpUniformModeVxlanTest()
        self.encapDscpUniformModeIpv4InIpv4Test()
        self.encapDscpUniformModeIpv6InIpv6Test()
        self.decapDscpUniformModeVxlanTest()
        self.decapDscpUniformModeIpv4InIpv4Test()
        self.decapDscpUniformModeIpv6InIpv6Test()
        self.tunnelTermDstIpTest()
        self.tunnelTermVrIdTest()
        self.tunnelDualEncapMapperTest()
        self.tunnelDualDecapMapperTest()
        self.tunnelPeerModeTest()

    def tearDown(self):
        sai_thrift_remove_route_entry(self.client, self.tunnel_route)
        sai_thrift_remove_route_entry(self.client, self.tunnel_route_v6)
        sai_thrift_remove_neighbor_entry(self.client, self.unbor)
        sai_thrift_remove_neighbor_entry(self.client, self.unbor_v6)
        sai_thrift_remove_next_hop(self.client, self.unhop)
        sai_thrift_remove_next_hop(self.client, self.unhop_v6)
        sai_thrift_remove_route_entry(self.client, self.customer_route)
        sai_thrift_remove_route_entry(self.client, self.customer_route_v6)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor_v6)
        sai_thrift_remove_next_hop(self.client, self.onhop)
        sai_thrift_remove_next_hop(self.client, self.onhop_v6)
        sai_thrift_remove_router_interface(self.client, self.orif)
        sai_thrift_remove_router_interface(self.client, self.urif)
        sai_thrift_remove_router_interface(self.client, self.orif_lpb)
        sai_thrift_remove_router_interface(self.client, self.urif_lpb)
        sai_thrift_remove_virtual_router(self.client, self.ovrf)
        sai_thrift_remove_virtual_router(self.client, self.uvrf)

        super(TunnelAttributesTest, self).tearDown()

    def encapTtlPipeModeVxlanTest(self):
        '''
        Verify if TTL value is properly set according to
        SAI_TUNNEL_ATTR_ENCAP_TTL_VAL attribute in VXLAN packets
        '''
        print("\nencapTtlPipeModeVxlanTest()")

        ttl_val = 20
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P

        try:
            encap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

            decap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

            encap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
                virtual_router_id_key=self.ovrf,
                vni_id_value=self.vni)

            decap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
                virtual_router_id_value=self.ovrf,
                vni_id_key=self.vni)

            encap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[encap_tunnel_map])
            decap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[decap_tunnel_map])

            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                encap_mappers=encap_maps,
                decap_mappers=decap_maps,
                encap_ttl_mode=ttl_mode,
                encap_ttl_val=ttl_val,
                underlay_interface=self.urif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.customer_mac,
                                    ip_dst=self.vm_ip,
                                    ip_src=self.customer_ip,
                                    ip_id=108,
                                    ip_ttl=64)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.vm_ip,
                                          ip_src=self.customer_ip,
                                          ip_id=108,
                                          ip_ttl=63)
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun_ip,
                                    ip_src=self.lpb_ip,
                                    ip_id=0,
                                    ip_ttl=ttl_val,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni,
                                    inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

            print("Sending IPv4 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, vxlan_pkt, self.uport_dev)
            print("\tOK")

            print("Modifying encap TTL value")
            ttl_val = 32
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            encap_ttl_val=ttl_val)
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun_ip,
                                    ip_src=self.lpb_ip,
                                    ip_id=0,
                                    ip_ttl=ttl_val,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni,
                                    inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

            print("Sending IPv4 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, vxlan_pkt, self.uport_dev)
            print("\tOK")

        finally:
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               decap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               encap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map(self.client, decap_tunnel_map)
            sai_thrift_remove_tunnel_map(self.client, encap_tunnel_map)

    def encapTtlPipeModeIpInIpTest(self):
        '''
        Verify if TTL value is properly set according to
        SAI_TUNNEL_ATTR_ENCAP_TTL_VAL attribute in IP-in-IP packets
        '''
        print("\nencapTtlPipeModeIpInIpTest()")

        ttl_val = 20
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                encap_ttl_mode=ttl_mode,
                encap_ttl_val=ttl_val,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip),
                src_ip=sai_ipaddress(self.tun_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.customer_mac,
                                    ip_dst=self.vm_ip,
                                    ip_src=self.customer_ip,
                                    ip_id=108,
                                    ip_ttl=64)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.vm_ip,
                                          ip_src=self.customer_ip,
                                          ip_id=108,
                                          ip_ttl=63)
            ipip_pkt = simple_ipv4ip_packet(eth_dst=self.unbor_mac,
                                            eth_src=ROUTER_MAC,
                                            ip_id=0,
                                            ip_dst=self.tun_ip,
                                            ip_src=self.lpb_ip,
                                            ip_ttl=ttl_val,
                                            inner_frame=inner_pkt['IP'])

            print("Sending IPv4 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt, self.uport_dev)
            print("\tOK")

        finally:
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)

    def encapTtlPipeModeIpv6InIpv6Test(self):
        '''
        Verify if TTL value is properly set according to
        SAI_TUNNEL_ATTR_ENCAP_TTL_VAL attribute in IPv6-in-IPv6 packets
        '''
        print("\nencapTtlPipeModeIpv6InIpv6Test()")

        ttl_val = 20
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ipv6),
                encap_ttl_mode=ttl_mode,
                encap_ttl_val=ttl_val,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ipv6),
                src_ip=sai_ipaddress(self.tun_ipv6))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ipv6),
                tunnel_mac=self.inner_dmac)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv6 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.customer_mac,
                                      ipv6_dst=self.vm_ipv6,
                                      ipv6_src=self.customer_ipv6,
                                      ipv6_hlim=64)
            inner_pkt = simple_udpv6_packet(eth_dst=self.inner_dmac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_dst=self.vm_ipv6,
                                            ipv6_src=self.customer_ipv6,
                                            ipv6_hlim=63)
            ipip_pkt = simple_ipv6ip_packet(eth_dst=self.unbor_mac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_src=self.lpb_ipv6,
                                            ipv6_dst=self.tun_ipv6,
                                            ipv6_hlim=ttl_val,
                                            inner_frame=inner_pkt['IPv6'])

            print("Sending IPv6 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt, self.uport_dev)
            print("\tOK")

        finally:
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)

    def decapTtlPipeModeVxlanTest(self):
        '''
        Verify if TTL value is properly set according to the inner packet,
        when using pipe mode in VXLAN packets
        '''
        print("\ndecapTtlPipeModeVxlanTest()")

        ttl_val = 20
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P

        try:
            encap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

            decap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

            encap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
                virtual_router_id_key=self.ovrf,
                vni_id_value=self.vni)

            decap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
                virtual_router_id_value=self.ovrf,
                vni_id_key=self.vni)

            encap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[encap_tunnel_map])
            decap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[decap_tunnel_map])

            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                encap_mappers=encap_maps,
                decap_mappers=decap_maps,
                decap_ttl_mode=ttl_mode,
                underlay_interface=self.urif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.customer_ip,
                                    ip_src=self.vm_ip,
                                    ip_id=108,
                                    ip_ttl=ttl_val - 1)
            inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.customer_ip,
                                          ip_src=self.vm_ip,
                                          ip_id=108,
                                          ip_ttl=ttl_val)
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)

            print("Sending VxLan packet")
            send_packet(self, self.uport_dev, vxlan_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

        finally:
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               decap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               encap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map(self.client, decap_tunnel_map)
            sai_thrift_remove_tunnel_map(self.client, encap_tunnel_map)

    def decapTtlPipeModeIpInIpTest(self):
        '''
        Verify if TTL value is properly set according to the inner packet,
        when using pipe mode in IP-in-IP packets
        '''
        print("\ndecapTtlPipeModeIpInIpTest()")

        ttl_val = 20
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                decap_ttl_mode=ttl_mode,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.customer_ip,
                                    ip_src=self.vm_ip,
                                    ip_id=108,
                                    ip_ttl=ttl_val - 1)
            inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                          eth_src=self.inner_dmac,
                                          ip_dst=self.customer_ip,
                                          ip_src=self.vm_ip,
                                          ip_id=108,
                                          ip_ttl=ttl_val)
            ipip_pkt = simple_ipv4ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            inner_frame=inner_pkt['IP'])

            print("Sending IPv4 packet")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

        finally:
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)

    def decapTtlPipeModeIpv6InIpv6Test(self):
        '''
        Verify if TTL value is properly set according to the inner packet,
        when using pipe mode in IPv6-in-IPv6 packets
        '''
        print("\ndecapTtlPipeModeIpv6InIpv6Test()")

        ttl_val = 20
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ipv6),
                decap_ttl_mode=ttl_mode,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ipv6))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ipv6),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv6 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udpv6_packet(eth_dst=self.customer_mac,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=self.customer_ipv6,
                                      ipv6_src=self.vm_ipv6,
                                      ipv6_hlim=ttl_val - 1)
            inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.inner_dmac,
                                            ipv6_dst=self.customer_ipv6,
                                            ipv6_src=self.vm_ipv6,
                                            ipv6_hlim=ttl_val)
            ipip_pkt = simple_ipv6ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ipv6_dst=self.lpb_ipv6,
                                            ipv6_src=self.tun_ipv6,
                                            ipv6_hlim=64,
                                            inner_frame=inner_pkt['IPv6'])

            print("Sending IPv6 packet")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

        finally:
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)

    def encapDscpUniformModeVxlanTest(self):
        '''
        Verify if DSCP value is properly set in VXLAN packets, according
        to the received DSCP value
        '''
        print("\nencapDscpUniformModeVxlanTest()")

        orig_dscp_val = 18
        rewrite_dscp_val = 20
        map_tc = 2
        tunnel_dscp_val = 10
        dscp_mode = SAI_TUNNEL_DSCP_MODE_UNIFORM_MODEL
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P
        qos_map_exists = False

        try:
            encap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

            decap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

            encap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
                virtual_router_id_key=self.ovrf,
                vni_id_value=self.vni)

            decap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
                virtual_router_id_value=self.ovrf,
                vni_id_key=self.vni)

            encap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[encap_tunnel_map])
            decap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[decap_tunnel_map])

            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                encap_mappers=encap_maps,
                decap_mappers=decap_maps,
                encap_ttl_mode=ttl_mode,
                encap_dscp_mode=dscp_mode,
                encap_dscp_val=tunnel_dscp_val,
                underlay_interface=self.urif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.customer_mac,
                                    ip_dst=self.vm_ip,
                                    ip_src=self.customer_ip,
                                    ip_id=108,
                                    ip_dscp=orig_dscp_val,
                                    ip_ttl=64)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.vm_ip,
                                          ip_src=self.customer_ip,
                                          ip_id=108,
                                          ip_dscp=orig_dscp_val,
                                          ip_ttl=63)
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun_ip,
                                    ip_src=self.lpb_ip,
                                    ip_id=0,
                                    ip_dscp=orig_dscp_val,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni,
                                    inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

            print("Sending IPv4 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, vxlan_pkt, self.uport_dev)
            print("\tOK")

            print("Modifying encap DSCP value")
            tunnel_dscp_val = 12
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            encap_dscp_val=tunnel_dscp_val)
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun_ip,
                                    ip_src=self.lpb_ip,
                                    ip_id=0,
                                    ip_dscp=orig_dscp_val,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni,
                                    inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

            print("Sending IPv4 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, vxlan_pkt, self.uport_dev)
            print("\tOK")

            print("Define qos maps to map orig_dscp_val to rewrite_dscp_val")
            dscp_to_tc_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(dscp=orig_dscp_val),
                    value=sai_thrift_qos_map_params_t(tc=map_tc))])
            dscp_to_tc_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_DSCP_TO_TC,
                map_to_value_list=dscp_to_tc_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.oport,
                qos_dscp_to_tc_map=dscp_to_tc_map_id)
            tc_to_dscp_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(
                        tc=map_tc, color=SAI_PACKET_COLOR_GREEN),
                    value=sai_thrift_qos_map_params_t(dscp=rewrite_dscp_val))])
            tc_to_dscp_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
                map_to_value_list=tc_to_dscp_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.uport,
                qos_tc_and_color_to_dscp_map=tc_to_dscp_map_id)
            qos_map_exists = True

            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.customer_mac,
                                    ip_dst=self.vm_ip,
                                    ip_src=self.customer_ip,
                                    ip_id=108,
                                    ip_dscp=orig_dscp_val,
                                    ip_ttl=64)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.vm_ip,
                                          ip_src=self.customer_ip,
                                          ip_id=108,
                                          ip_dscp=rewrite_dscp_val,
                                          ip_ttl=63)
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun_ip,
                                    ip_src=self.lpb_ip,
                                    ip_id=0,
                                    ip_dscp=rewrite_dscp_val,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni,
                                    inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

            print("Sending IPv4 packet subject to dscp rewrite")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, vxlan_pkt, self.uport_dev)
            print("\tOK")

        finally:
            if qos_map_exists:
                sai_thrift_set_port_attribute(
                    self.client,
                    self.oport,
                    qos_dscp_to_tc_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, dscp_to_tc_map_id)
                sai_thrift_set_port_attribute(
                    self.client,
                    self.uport,
                    qos_tc_and_color_to_dscp_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, tc_to_dscp_map_id)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               decap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               encap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map(self.client, decap_tunnel_map)
            sai_thrift_remove_tunnel_map(self.client, encap_tunnel_map)

    def encapDscpUniformModeIpv4InIpv4Test(self):
        '''
        Verify if DSCP value is properly set in VXLAN packets, according
        to the received DSCP value
        '''
        print("\nencapDscpUniformModeIpv4InIpv4Test()")

        orig_dscp_val = 18
        rewrite_dscp_val = 20
        map_tc = 2
        tunnel_dscp_val = 10
        dscp_mode = SAI_TUNNEL_DSCP_MODE_UNIFORM_MODEL
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P
        qos_map_exists = False

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                encap_ttl_mode=ttl_mode,
                encap_dscp_mode=dscp_mode,
                encap_dscp_val=tunnel_dscp_val,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip),
                src_ip=sai_ipaddress(self.tun_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.customer_mac,
                                    ip_dst=self.vm_ip,
                                    ip_src=self.customer_ip,
                                    ip_id=108,
                                    ip_dscp=orig_dscp_val,
                                    ip_ttl=64)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.vm_ip,
                                          ip_src=self.customer_ip,
                                          ip_id=108,
                                          ip_dscp=orig_dscp_val,
                                          ip_ttl=63)
            ipip_pkt = simple_ipv4ip_packet(eth_dst=self.unbor_mac,
                                            eth_src=ROUTER_MAC,
                                            ip_id=0,
                                            ip_dst=self.tun_ip,
                                            ip_src=self.lpb_ip,
                                            ip_dscp=orig_dscp_val,
                                            ip_ttl=64,
                                            inner_frame=inner_pkt['IP'])

            print("Sending IPv4 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt, self.uport_dev)
            print("\tOK")

            print("Define qos maps to map orig_dscp_val to rewrite_dscp_val")
            dscp_to_tc_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(dscp=orig_dscp_val),
                    value=sai_thrift_qos_map_params_t(tc=map_tc))])
            dscp_to_tc_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_DSCP_TO_TC,
                map_to_value_list=dscp_to_tc_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.oport,
                qos_dscp_to_tc_map=dscp_to_tc_map_id)
            tc_to_dscp_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(
                        tc=map_tc, color=SAI_PACKET_COLOR_GREEN),
                    value=sai_thrift_qos_map_params_t(dscp=rewrite_dscp_val))])
            tc_to_dscp_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
                map_to_value_list=tc_to_dscp_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.uport,
                qos_tc_and_color_to_dscp_map=tc_to_dscp_map_id)
            qos_map_exists = True

            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.customer_mac,
                                    ip_dst=self.vm_ip,
                                    ip_src=self.customer_ip,
                                    ip_id=108,
                                    ip_dscp=orig_dscp_val,
                                    ip_ttl=64)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.vm_ip,
                                          ip_src=self.customer_ip,
                                          ip_id=108,
                                          ip_dscp=rewrite_dscp_val,
                                          ip_ttl=63)
            ipip_pkt = simple_ipv4ip_packet(eth_dst=self.unbor_mac,
                                            eth_src=ROUTER_MAC,
                                            ip_id=0,
                                            ip_dst=self.tun_ip,
                                            ip_src=self.lpb_ip,
                                            ip_dscp=rewrite_dscp_val,
                                            ip_ttl=64,
                                            inner_frame=inner_pkt['IP'])

            print("Sending IPv4 packet subject to dscp rewrite")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt, self.uport_dev)
            print("\tOK")

        finally:
            if qos_map_exists:
                sai_thrift_set_port_attribute(
                    self.client,
                    self.oport,
                    qos_dscp_to_tc_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, dscp_to_tc_map_id)
                sai_thrift_set_port_attribute(
                    self.client,
                    self.uport,
                    qos_tc_and_color_to_dscp_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, tc_to_dscp_map_id)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)

    def encapDscpUniformModeIpv6InIpv6Test(self):
        '''
        Verify if DSCP value is properly set in VXLAN packets, according
        to the received DSCP value
        '''
        print("\nencapDscpUniformModeIpv6InIpv6Test()")

        orig_dscp_val = 18
        rewrite_dscp_val = 20
        map_tc = 2
        tunnel_dscp_val = 10
        dscp_mode = SAI_TUNNEL_DSCP_MODE_UNIFORM_MODEL
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P
        qos_map_exists = False

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ipv6),
                encap_ttl_mode=ttl_mode,
                encap_dscp_mode=dscp_mode,
                encap_dscp_val=tunnel_dscp_val,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ipv6),
                src_ip=sai_ipaddress(self.tun_ipv6))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ipv6),
                tunnel_mac=self.inner_dmac)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv6 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.customer_mac,
                                      ipv6_dst=self.vm_ipv6,
                                      ipv6_src=self.customer_ipv6,
                                      ipv6_dscp=orig_dscp_val,
                                      ipv6_hlim=64)
            inner_pkt = simple_udpv6_packet(eth_dst=self.inner_dmac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_dst=self.vm_ipv6,
                                            ipv6_src=self.customer_ipv6,
                                            ipv6_dscp=orig_dscp_val,
                                            ipv6_hlim=63)
            ipip_pkt = simple_ipv6ip_packet(eth_dst=self.unbor_mac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_src=self.lpb_ipv6,
                                            ipv6_dst=self.tun_ipv6,
                                            ipv6_dscp=orig_dscp_val,
                                            ipv6_hlim=64,
                                            inner_frame=inner_pkt['IPv6'])

            print("Sending IPv6 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt, self.uport_dev)
            print("\tOK")

            print("Define qos maps to map orig_dscp_val to rewrite_dscp_val")
            dscp_to_tc_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(dscp=orig_dscp_val),
                    value=sai_thrift_qos_map_params_t(tc=map_tc))])
            dscp_to_tc_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_DSCP_TO_TC,
                map_to_value_list=dscp_to_tc_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.oport,
                qos_dscp_to_tc_map=dscp_to_tc_map_id)
            tc_to_dscp_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(
                        tc=map_tc, color=SAI_PACKET_COLOR_GREEN),
                    value=sai_thrift_qos_map_params_t(dscp=rewrite_dscp_val))])
            tc_to_dscp_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
                map_to_value_list=tc_to_dscp_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.uport,
                qos_tc_and_color_to_dscp_map=tc_to_dscp_map_id)
            qos_map_exists = True

            pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.customer_mac,
                                      ipv6_dst=self.vm_ipv6,
                                      ipv6_src=self.customer_ipv6,
                                      ipv6_dscp=orig_dscp_val,
                                      ipv6_hlim=64)
            inner_pkt = simple_udpv6_packet(eth_dst=self.inner_dmac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_dst=self.vm_ipv6,
                                            ipv6_src=self.customer_ipv6,
                                            ipv6_dscp=rewrite_dscp_val,
                                            ipv6_hlim=63)
            ipip_pkt = simple_ipv6ip_packet(eth_dst=self.unbor_mac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_src=self.lpb_ipv6,
                                            ipv6_dst=self.tun_ipv6,
                                            ipv6_dscp=rewrite_dscp_val,
                                            ipv6_hlim=64,
                                            inner_frame=inner_pkt['IPv6'])

            print("Sending IPv6 packet subject to dscp rewrite")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt, self.uport_dev)
            print("\tOK")

        finally:
            if qos_map_exists:
                sai_thrift_set_port_attribute(
                    self.client,
                    self.oport,
                    qos_dscp_to_tc_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, dscp_to_tc_map_id)
                sai_thrift_set_port_attribute(
                    self.client,
                    self.uport,
                    qos_tc_and_color_to_dscp_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, tc_to_dscp_map_id)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)

    def decapDscpUniformModeVxlanTest(self):
        '''
        Verify if DSCP value is properly set according to the outer packet,
        when using uniform mode in VXLAN packets
        '''
        print("\ndecapDscpUniformModeVxlanTest()")

        tunnel_dscp_val = 10
        inner_dscp_val = 18
        rewrite_dscp_val = 20
        map_tc = 2
        dscp_mode = SAI_TUNNEL_DSCP_MODE_UNIFORM_MODEL
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P
        qos_map_exists = False

        try:
            encap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

            decap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

            encap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
                virtual_router_id_key=self.ovrf,
                vni_id_value=self.vni)

            decap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
                virtual_router_id_value=self.ovrf,
                vni_id_key=self.vni)

            encap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[encap_tunnel_map])
            decap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[decap_tunnel_map])

            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                encap_mappers=encap_maps,
                decap_mappers=decap_maps,
                decap_ttl_mode=ttl_mode,
                decap_dscp_mode=dscp_mode,
                underlay_interface=self.urif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.customer_ip,
                                    ip_src=self.vm_ip,
                                    ip_id=108,
                                    ip_dscp=tunnel_dscp_val,
                                    ip_ttl=62)
            inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.customer_ip,
                                          ip_src=self.vm_ip,
                                          ip_id=108,
                                          ip_dscp=inner_dscp_val,
                                          ip_ttl=63)
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_dscp=tunnel_dscp_val,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)

            print("Sending VxLan packet")
            send_packet(self, self.uport_dev, vxlan_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

            print("Define qos maps to map tunnel_dscp_val to rewrite_dscp_val")
            dscp_to_tc_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(dscp=tunnel_dscp_val),
                    value=sai_thrift_qos_map_params_t(tc=map_tc))])
            dscp_to_tc_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_DSCP_TO_TC,
                map_to_value_list=dscp_to_tc_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.uport,
                qos_dscp_to_tc_map=dscp_to_tc_map_id)
            tc_to_dscp_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(
                        tc=map_tc, color=SAI_PACKET_COLOR_GREEN),
                    value=sai_thrift_qos_map_params_t(dscp=rewrite_dscp_val))])
            tc_to_dscp_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
                map_to_value_list=tc_to_dscp_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.oport,
                qos_tc_and_color_to_dscp_map=tc_to_dscp_map_id)
            qos_map_exists = True

            pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.customer_ip,
                                    ip_src=self.vm_ip,
                                    ip_id=108,
                                    ip_dscp=rewrite_dscp_val,
                                    ip_ttl=62)
            inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.customer_ip,
                                          ip_src=self.vm_ip,
                                          ip_id=108,
                                          ip_dscp=inner_dscp_val,
                                          ip_ttl=63)
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_dscp=tunnel_dscp_val,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)

            print("Sending VxLan packet subject to dscp rewrite")
            send_packet(self, self.uport_dev, vxlan_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

        finally:
            if qos_map_exists:
                sai_thrift_set_port_attribute(
                    self.client,
                    self.uport,
                    qos_dscp_to_tc_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, dscp_to_tc_map_id)
                sai_thrift_set_port_attribute(
                    self.client,
                    self.oport,
                    qos_tc_and_color_to_dscp_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, tc_to_dscp_map_id)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               decap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               encap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map(self.client, decap_tunnel_map)
            sai_thrift_remove_tunnel_map(self.client, encap_tunnel_map)

    def decapDscpUniformModeIpv4InIpv4Test(self):
        '''
        Verify if DSCP value is properly set according to the outer packet,
        when using uniform mode in IP-in-IP packets
        '''
        print("\ndecapDscpUniformModeIpv4InIpv4Test()")

        tunnel_dscp_val = 10
        inner_dscp_val = 18
        rewrite_dscp_val = 20
        map_tc = 2
        dscp_mode = SAI_TUNNEL_DSCP_MODE_UNIFORM_MODEL
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P
        qos_map_exists = False

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                decap_ttl_mode=ttl_mode,
                decap_dscp_mode=dscp_mode,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.customer_ip,
                                    ip_src=self.vm_ip,
                                    ip_id=108,
                                    ip_dscp=tunnel_dscp_val,
                                    ip_ttl=62)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.customer_ip,
                                          ip_src=self.vm_ip,
                                          ip_id=108,
                                          ip_dscp=inner_dscp_val,
                                          ip_ttl=63)
            ipip_pkt = simple_ipv4ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_dscp=tunnel_dscp_val,
                                            ip_ttl=64,
                                            inner_frame=inner_pkt['IP'])

            print("Sending IPv4 packet")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

            print("Define qos maps to map tunnel_dscp_val to rewrite_dscp_val")
            dscp_to_tc_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(dscp=tunnel_dscp_val),
                    value=sai_thrift_qos_map_params_t(tc=map_tc))])
            dscp_to_tc_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_DSCP_TO_TC,
                map_to_value_list=dscp_to_tc_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.uport,
                qos_dscp_to_tc_map=dscp_to_tc_map_id)
            tc_to_dscp_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(
                        tc=map_tc, color=SAI_PACKET_COLOR_GREEN),
                    value=sai_thrift_qos_map_params_t(dscp=rewrite_dscp_val))])
            tc_to_dscp_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
                map_to_value_list=tc_to_dscp_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.oport,
                qos_tc_and_color_to_dscp_map=tc_to_dscp_map_id)
            qos_map_exists = True

            pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.customer_ip,
                                    ip_src=self.vm_ip,
                                    ip_id=108,
                                    ip_dscp=rewrite_dscp_val,
                                    ip_ttl=62)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.customer_ip,
                                          ip_src=self.vm_ip,
                                          ip_id=108,
                                          ip_dscp=inner_dscp_val,
                                          ip_ttl=63)
            ipip_pkt = simple_ipv4ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_dscp=tunnel_dscp_val,
                                            ip_ttl=64,
                                            inner_frame=inner_pkt['IP'])

            print("Sending IPv4 packet subject to dscp rewrite")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

        finally:
            if qos_map_exists:
                sai_thrift_set_port_attribute(
                    self.client,
                    self.uport,
                    qos_dscp_to_tc_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, dscp_to_tc_map_id)
                sai_thrift_set_port_attribute(
                    self.client,
                    self.oport,
                    qos_tc_and_color_to_dscp_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, tc_to_dscp_map_id)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)

    def decapDscpUniformModeIpv6InIpv6Test(self):
        '''
        Verify if DSCP value is properly set according to the outer packet,
        when using uniform mode in IPv6-in-IPv6 packets
        '''
        print("\ndecapDscpUniformModeIpv6InIpv6Test()")

        tunnel_dscp_val = 10
        inner_dscp_val = 18
        rewrite_dscp_val = 20
        map_tc = 2
        dscp_mode = SAI_TUNNEL_DSCP_MODE_UNIFORM_MODEL
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P
        qos_map_exists = False

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ipv6),
                decap_ttl_mode=ttl_mode,
                decap_dscp_mode=dscp_mode,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ipv6))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ipv6),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv6 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udpv6_packet(eth_dst=self.customer_mac,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=self.customer_ipv6,
                                      ipv6_src=self.vm_ipv6,
                                      ipv6_dscp=tunnel_dscp_val,
                                      ipv6_hlim=62)
            inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.inner_dmac,
                                            ipv6_dst=self.customer_ipv6,
                                            ipv6_src=self.vm_ipv6,
                                            ipv6_dscp=inner_dscp_val,
                                            ipv6_hlim=63)
            ipip_pkt = simple_ipv6ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ipv6_dst=self.lpb_ipv6,
                                            ipv6_src=self.tun_ipv6,
                                            ipv6_dscp=tunnel_dscp_val,
                                            ipv6_hlim=64,
                                            inner_frame=inner_pkt['IPv6'])

            print("Sending IPv6 packet")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

            print("Define qos maps to map tunnel_dscp_val to rewrite_dscp_val")
            dscp_to_tc_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(dscp=tunnel_dscp_val),
                    value=sai_thrift_qos_map_params_t(tc=map_tc))])
            dscp_to_tc_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_DSCP_TO_TC,
                map_to_value_list=dscp_to_tc_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.uport,
                qos_dscp_to_tc_map=dscp_to_tc_map_id)
            tc_to_dscp_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(
                        tc=map_tc, color=SAI_PACKET_COLOR_GREEN),
                    value=sai_thrift_qos_map_params_t(dscp=rewrite_dscp_val))])
            tc_to_dscp_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
                map_to_value_list=tc_to_dscp_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.oport,
                qos_tc_and_color_to_dscp_map=tc_to_dscp_map_id)
            qos_map_exists = True

            pkt = simple_udpv6_packet(eth_dst=self.customer_mac,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=self.customer_ipv6,
                                      ipv6_src=self.vm_ipv6,
                                      ipv6_dscp=rewrite_dscp_val,
                                      ipv6_hlim=62)
            inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.inner_dmac,
                                            ipv6_dst=self.customer_ipv6,
                                            ipv6_src=self.vm_ipv6,
                                            ipv6_dscp=inner_dscp_val,
                                            ipv6_hlim=63)
            ipip_pkt = simple_ipv6ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ipv6_dst=self.lpb_ipv6,
                                            ipv6_src=self.tun_ipv6,
                                            ipv6_dscp=tunnel_dscp_val,
                                            ipv6_hlim=64,
                                            inner_frame=inner_pkt['IPv6'])

            print("Sending IPv6 packet subject to dscp rewrite")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

        finally:
            if qos_map_exists:
                sai_thrift_set_port_attribute(
                    self.client,
                    self.uport,
                    qos_dscp_to_tc_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, dscp_to_tc_map_id)
                sai_thrift_set_port_attribute(
                    self.client,
                    self.oport,
                    qos_tc_and_color_to_dscp_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, tc_to_dscp_map_id)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)

    def tunnelTermDstIpTest(self):
        '''
        Verify if only tunneled packets with destination IP set as
        SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_DST_IP are de-encapsulated
        '''
        print("\ntunnelTermDstIpTest()")

        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
        test_ip = "200.200.200.1"

        try:
            encap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

            decap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

            encap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
                virtual_router_id_key=self.ovrf,
                vni_id_value=self.vni)

            decap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
                virtual_router_id_value=self.ovrf,
                vni_id_key=self.vni)

            encap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[encap_tunnel_map])
            decap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[decap_tunnel_map])

            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                encap_mappers=encap_maps,
                decap_mappers=decap_maps,
                encap_ttl_mode=ttl_mode,
                decap_ttl_mode=ttl_mode,
                underlay_interface=self.urif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.customer_ip,
                                    ip_src=self.vm_ip,
                                    ip_id=108,
                                    ip_ttl=63)
            inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                          eth_src=self.inner_dmac,
                                          ip_dst=self.customer_ip,
                                          ip_src=self.vm_ip,
                                          ip_id=108,
                                          ip_ttl=64)
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)

            print("Sending VxLan packet with proper dst IP")
            send_packet(self, self.uport_dev, vxlan_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

            vxlan_pkt[IP].dst = test_ip

            print("Sending VxLan packet with improper dst IP")
            send_packet(self, self.uport_dev, vxlan_pkt)
            verify_no_other_packets(self)
            print("\tDropped")

        finally:
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               decap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               encap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map(self.client, decap_tunnel_map)
            sai_thrift_remove_tunnel_map(self.client, encap_tunnel_map)

    def tunnelTermVrIdTest(self):
        '''
        Verify if only tunneled packets coming in on VRF set as
        SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_VR_ID are de-encapsulated
        '''
        print("\ntunnelTermVrIdTest()")

        test_uport = self.port26
        test_uport_dev = self.dev_port26

        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL

        try:
            test_uvrf = sai_thrift_create_virtual_router(self.client)

            test_urif = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_PORT,
                virtual_router_id=test_uvrf,
                port_id=test_uport)

            encap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

            decap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

            encap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
                virtual_router_id_key=self.ovrf,
                vni_id_value=self.vni)

            decap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
                virtual_router_id_value=self.ovrf,
                vni_id_key=self.vni)

            encap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[encap_tunnel_map])
            decap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[decap_tunnel_map])

            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                encap_mappers=encap_maps,
                decap_mappers=decap_maps,
                encap_ttl_mode=ttl_mode,
                decap_ttl_mode=ttl_mode,
                underlay_interface=self.urif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.customer_ip,
                                    ip_src=self.vm_ip,
                                    ip_id=108,
                                    ip_ttl=63)
            inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                          eth_src=self.inner_dmac,
                                          ip_dst=self.customer_ip,
                                          ip_src=self.vm_ip,
                                          ip_id=108,
                                          ip_ttl=64)
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)

            print("Sending VxLan packet to proper VRF")
            send_packet(self, self.uport_dev, vxlan_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

            print("Sending VxLan packet to improper VRF")
            send_packet(self, test_uport_dev, vxlan_pkt)
            verify_no_other_packets(self)
            print("\tDropped")

        finally:
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               decap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               encap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map(self.client, decap_tunnel_map)
            sai_thrift_remove_tunnel_map(self.client, encap_tunnel_map)
            sai_thrift_remove_router_interface(self.client, test_urif)
            sai_thrift_remove_virtual_router(self.client, test_uvrf)

    def tunnelDualEncapMapperTest(self):
        '''
        Verify that tunneled packets are still transmitted when the tunnel
        is defined with two encap mappers (VRF_TO_VNI and VLAN_TO_VNI)
        '''
        print("\ntunnelDualEncapMapperTest()")

        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL

        try:
            encap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

            encap_tunnel_map_2 = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VLAN_ID_TO_VNI)

            decap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

            encap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
                virtual_router_id_key=self.ovrf,
                vni_id_value=self.vni)

            decap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=decap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
                virtual_router_id_value=self.ovrf,
                vni_id_key=self.vni)

            encap_maps = sai_thrift_object_list_t(count=2,
                                                  idlist=[encap_tunnel_map,
                                                          encap_tunnel_map_2])
            decap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[decap_tunnel_map])

            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                encap_mappers=encap_maps,
                decap_mappers=decap_maps,
                encap_ttl_mode=ttl_mode,
                decap_ttl_mode=ttl_mode,
                underlay_interface=self.urif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.customer_mac,
                                    ip_dst=self.vm_ip,
                                    ip_src=self.customer_ip,
                                    ip_id=108,
                                    ip_ttl=64)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.vm_ip,
                                          ip_src=self.customer_ip,
                                          ip_id=108,
                                          ip_ttl=63)
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun_ip,
                                    ip_src=self.lpb_ip,
                                    ip_id=0,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni,
                                    inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

            print("Sending IPv4 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, vxlan_pkt, self.uport_dev)
            print("\tOK")

        finally:
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               decap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               encap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map(self.client, decap_tunnel_map)
            sai_thrift_remove_tunnel_map(self.client, encap_tunnel_map)
            sai_thrift_remove_tunnel_map(self.client, encap_tunnel_map_2)

    def tunnelDualDecapMapperTest(self):
        '''
        Verify that tunneled packets are still received when the tunnel
        is defined with two decap mappers (VNI_TO_VRF and VNI_TO_VLAN)
        '''
        print("\ntunnelDualDecapMapperTest()")

        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL

        ovlan = sai_thrift_create_vlan(self.client, vlan_id=self.ovlan_no)
        orif_vlan = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_VLAN,
            virtual_router_id=self.ovrf,
            vlan_id=ovlan)
        ovlan_member = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=ovlan,
            bridge_port_id=self.port21_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)
        mac2_entry = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.customer2_mac,
            bv_id=ovlan)
        sai_thrift_create_fdb_entry(self.client,
                                    mac2_entry,
                                    type=SAI_FDB_ENTRY_TYPE_STATIC,
                                    bridge_port_id=self.port21_bp)

        decap_tunnel_map_entry_vrf_exists = False
        decap_tunnel_map_entry_vlan_exists = False

        try:
            encap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

            decap_tunnel_map_vrf = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

            decap_tunnel_map_vlan = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VLAN_ID)

            encap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
                virtual_router_id_key=self.ovrf,
                vni_id_value=self.vni)

            decap_tunnel_map_entry_vrf = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=decap_tunnel_map_vrf,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
                virtual_router_id_value=self.ovrf,
                vni_id_key=self.vni)
            decap_tunnel_map_entry_vrf_exists = True

            encap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[encap_tunnel_map])
            decap_maps = sai_thrift_object_list_t(
                count=2,
                idlist=[decap_tunnel_map_vrf,
                        decap_tunnel_map_vlan])

            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                encap_mappers=encap_maps,
                decap_mappers=decap_maps,
                encap_ttl_mode=ttl_mode,
                decap_ttl_mode=ttl_mode,
                underlay_interface=self.urif_lpb)
            self.assertNotEqual(
                tunnel, 0, "Failed to create tunnel with dual decap mappers")

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            l3_pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                       eth_src=ROUTER_MAC,
                                       ip_dst=self.customer_ip,
                                       ip_src=self.vm_ip,
                                       ip_id=108,
                                       ip_ttl=63)
            l3_inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                             eth_src=self.inner_dmac,
                                             ip_dst=self.customer_ip,
                                             ip_src=self.vm_ip,
                                             ip_id=108,
                                             ip_ttl=64)
            l3_vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                               eth_src=self.unbor_mac,
                                               ip_dst=self.lpb_ip,
                                               ip_src=self.tun_ip,
                                               ip_id=0,
                                               ip_ttl=64,
                                               ip_flags=0x2,
                                               udp_sport=11638,
                                               with_udp_chksum=False,
                                               vxlan_vni=self.vni,
                                               inner_frame=l3_inner_pkt)

            pkt_len = 104
            dec = 4
            l2_pkt = simple_udp_packet(eth_dst=self.customer2_mac,
                                       eth_src=self.inner_dmac,
                                       dl_vlan_enable=True,
                                       vlan_vid=self.ovlan_no,
                                       ip_dst=self.customer2_ip,
                                       ip_src=self.vm_ip,
                                       ip_id=108,
                                       ip_ttl=64,
                                       pktlen=pkt_len)
            l2_inner_pkt = simple_udp_packet(eth_dst=self.customer2_mac,
                                             eth_src=self.inner_dmac,
                                             ip_dst=self.customer2_ip,
                                             ip_src=self.vm_ip,
                                             ip_id=108,
                                             ip_ttl=64,
                                             pktlen=pkt_len - dec)
            l2_vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                               eth_src=self.unbor_mac,
                                               ip_dst=self.lpb_ip,
                                               ip_src=self.tun_ip,
                                               ip_id=0,
                                               ip_ttl=64,
                                               ip_flags=0x2,
                                               udp_sport=11638,
                                               with_udp_chksum=False,
                                               vxlan_vni=self.vni,
                                               inner_frame=l2_inner_pkt)

            print("Sending VxLan packet to tunnel with dual decap mappers")
            send_packet(self, self.uport_dev, l3_vxlan_pkt)
            verify_packet(self, l3_pkt, self.oport_dev)
            print("\tOK")

            print("Create overlapping decap tunnel_mapper_entry for vlan "
                  "with same vni")
            decap_tunnel_map_entry_vlan = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=decap_tunnel_map_vlan,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VLAN_ID,
                vlan_id_value=self.ovlan_no,
                vni_id_key=self.vni)
            decap_tunnel_map_entry_vlan_exists = True

            print("Sending L3 VxLan packet with overlapping "
                  "decap mapper entries")
            send_packet(self, self.uport_dev, l3_vxlan_pkt)
            verify_packet(self, l3_pkt, self.oport_dev)
            print("\tOK")

            print("Sending L2 VxLan packet with overlapping "
                  "decap mapper entries, should not be forwarded")
            send_packet(self, self.uport_dev, l2_vxlan_pkt)
            verify_no_other_packets(self)
            print("\tDropped")

            print("Delete overlapping decap tunnel_mapper_entry for vlan")
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               decap_tunnel_map_entry_vlan)
            decap_tunnel_map_entry_vlan_exists = False

            print("Sending L3 VxLan packet after deleting overlapping "
                  "decap mapper entry for vlan")
            send_packet(self, self.uport_dev, l3_vxlan_pkt)
            verify_packet(self, l3_pkt, self.oport_dev)
            print("\tOK")

            print("Delete decap tunnel_mapper_entry for vrf, then "
                  "replace with decap tunnel_mapper_entry for vlan")
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               decap_tunnel_map_entry_vrf)
            decap_tunnel_map_entry_vrf_exists = False

            decap_tunnel_map_entry_vlan = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=decap_tunnel_map_vlan,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VLAN_ID,
                vlan_id_value=self.ovlan_no,
                vni_id_key=self.vni)
            decap_tunnel_map_entry_vlan_exists = True

            print("Sending L2 VxLan packet with single decap mapper entry "
                  "for vlan")
            send_packet(self, self.uport_dev, l2_vxlan_pkt)
            verify_packet(self, l2_pkt, self.dev_port21)
            print("\tOK")

            print("Sending L3 VxLan packet with single decap mapper entry "
                  "for vlan, should still be routed due to rif in same vrf")
            send_packet(self, self.uport_dev, l3_vxlan_pkt)
            verify_packet(self, l3_pkt, self.oport_dev)
            print("\tOK")

            print("Create overlapping decap tunnel_mapper_entry for vrf "
                  "with same vni")
            decap_tunnel_map_entry_vrf = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=decap_tunnel_map_vrf,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
                virtual_router_id_value=self.ovrf,
                vni_id_key=self.vni)
            decap_tunnel_map_entry_vrf_exists = True

            print("Sending L3 VxLan packet with overlapping "
                  "decap mapper entries")
            send_packet(self, self.uport_dev, l3_vxlan_pkt)
            verify_packet(self, l3_pkt, self.oport_dev)
            print("\tOK")

            print("Sending L2 VxLan packet with overlapping "
                  "decap mapper entries, should not be forwarded")
            send_packet(self, self.uport_dev, l2_vxlan_pkt)
            verify_no_other_packets(self)
            print("\tDropped")

            print("Delete overlapping decap tunnel_mapper_entry for vrf")
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               decap_tunnel_map_entry_vrf)
            decap_tunnel_map_entry_vrf_exists = False

            print("Sending L3 VxLan packet after deleting overlapping "
                  "decap mapper entry for vrf")
            send_packet(self, self.uport_dev, l3_vxlan_pkt)
            verify_packet(self, l3_pkt, self.oport_dev)
            print("\tOK")

            print("Sending L2 VxLan packet after deleting overlapping "
                  "decap mapper entry for vrf")
            send_packet(self, self.uport_dev, l2_vxlan_pkt)
            verify_packet(self, l2_pkt, self.dev_port21)
            print("\tOK")

        finally:
            if tunnel:
                sai_thrift_remove_route_entry(self.client, vm_route)
                sai_thrift_remove_next_hop(self.client, tunnel_nhop)
                sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                          tunnel_term)
                sai_thrift_remove_tunnel(self.client, tunnel)
            if decap_tunnel_map_entry_vrf_exists:
                sai_thrift_remove_tunnel_map_entry(self.client,
                                                   decap_tunnel_map_entry_vrf)
            if decap_tunnel_map_entry_vlan_exists:
                sai_thrift_remove_tunnel_map_entry(self.client,
                                                   decap_tunnel_map_entry_vlan)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               encap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map(self.client, decap_tunnel_map_vrf)
            sai_thrift_remove_tunnel_map(self.client, decap_tunnel_map_vlan)
            sai_thrift_remove_tunnel_map(self.client, encap_tunnel_map)
            sai_thrift_remove_fdb_entry(self.client, mac2_entry)
            sai_thrift_remove_vlan_member(self.client, ovlan_member)
            sai_thrift_remove_router_interface(self.client, orif_vlan)
            sai_thrift_remove_vlan(self.client, ovlan)

    def tunnelPeerModeTest(self):
        '''
        Verify that tunneled packets are still received when the tunnel
        is defined with peer mode P2MP
        '''
        print("\ntunnelPeerModeTest()")

        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL

        try:
            encap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

            decap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

            encap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
                virtual_router_id_key=self.ovrf,
                vni_id_value=self.vni)

            decap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
                virtual_router_id_value=self.ovrf,
                vni_id_key=self.vni)

            encap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[encap_tunnel_map])
            decap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[decap_tunnel_map])
            peer_mode = SAI_TUNNEL_PEER_MODE_P2MP

            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                encap_mappers=encap_maps,
                decap_mappers=decap_maps,
                encap_ttl_mode=ttl_mode,
                decap_ttl_mode=ttl_mode,
                peer_mode=peer_mode,
                underlay_interface=self.urif_lpb)
            self.assertNotEqual(tunnel, 0,
                                "Failed to create tunnel with peer mode %s"
                                % peer_mode)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.customer_ip,
                                    ip_src=self.vm_ip,
                                    ip_id=108,
                                    ip_ttl=63)
            inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                          eth_src=self.inner_dmac,
                                          ip_dst=self.customer_ip,
                                          ip_src=self.vm_ip,
                                          ip_id=108,
                                          ip_ttl=64)
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)

            print("Sending VxLan packet to tunnel with peer mode P2MP")
            send_packet(self, self.uport_dev, vxlan_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

        finally:
            if tunnel:
                sai_thrift_remove_route_entry(self.client, vm_route)
                sai_thrift_remove_next_hop(self.client, tunnel_nhop)
                sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                          tunnel_term)
                sai_thrift_remove_tunnel(self.client, tunnel)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               decap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               encap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map(self.client, decap_tunnel_map)
            sai_thrift_remove_tunnel_map(self.client, encap_tunnel_map)


@group("draft")
class TunnelTtlModeTest(SaiHelper):
    '''
    Tests of the ttl_mode, focusing mostly on the uniform mode.
    Note that the pipe ttl_mode is covered in more detail in
    TunnelAttributesTest.
    '''

    def setUp(self):
        super(TunnelTtlModeTest, self).setUp()

        self.oport = self.port24
        self.oport_dev = self.dev_port24
        self.uport = self.port25
        self.uport_dev = self.dev_port25

        self.vni = 1000
        self.tun_ip = "10.10.10.1"
        self.tun_ipv6 = "2001:0db8::10:1"
        self.lpb_ip = "10.10.10.2"
        self.lpb_ipv6 = "2001:0db8::10:10"
        self.vm_ip = "100.100.1.1"
        self.vm_ipv6 = "2001:0db8::100:1"
        self.customer_ip = "100.100.2.1"
        self.customer_ipv6 = "2001:0db8::100:2"
        self.inner_dmac = "00:11:11:11:11:11"
        self.customer_mac = "00:22:22:22:22:22"
        self.unbor_mac = "00:33:33:33:33:33"

        # underlay configuration
        self.uvrf = sai_thrift_create_virtual_router(self.client)

        # overlay configuraion
        self.ovrf = sai_thrift_create_virtual_router(self.client)

        # underlay loopback RIF for tunnel
        self.urif_lpb = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_LOOPBACK,
            virtual_router_id=self.uvrf)

        self.orif_lpb = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_LOOPBACK,
            virtual_router_id=self.ovrf)

        self.urif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.uvrf,
            port_id=self.uport)

        # route to tunnel
        self.unhop = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip),
                                                router_interface_id=self.urif,
                                                type=SAI_NEXT_HOP_TYPE_IP)

        self.unhop_v6 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.tun_ipv6),
            router_interface_id=self.urif,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.unbor = sai_thrift_neighbor_entry_t(
            rif_id=self.urif, ip_address=sai_ipaddress(self.tun_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.unbor,
                                         dst_mac_address=self.unbor_mac,
                                         no_host_route=True)

        self.unbor_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.urif, ip_address=sai_ipaddress(self.tun_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.unbor_v6,
                                         dst_mac_address=self.unbor_mac,
                                         no_host_route=True)

        self.tunnel_route = sai_thrift_route_entry_t(
            vr_id=self.uvrf, destination=sai_ipprefix(self.tun_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.tunnel_route,
                                      next_hop_id=self.unhop)

        self.tunnel_route_v6 = sai_thrift_route_entry_t(
            vr_id=self.uvrf, destination=sai_ipprefix(self.tun_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.tunnel_route_v6,
                                      next_hop_id=self.unhop_v6)

        self.orif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.ovrf,
            port_id=self.oport)

        # route to customer from VM
        self.onhop = sai_thrift_create_next_hop(
            self.client, ip=sai_ipaddress(self.customer_ip),
            router_interface_id=self.orif, type=SAI_NEXT_HOP_TYPE_IP)

        self.onhop_v6 = sai_thrift_create_next_hop(
            self.client, ip=sai_ipaddress(self.customer_ipv6),
            router_interface_id=self.orif, type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor = sai_thrift_neighbor_entry_t(
            rif_id=self.orif, ip_address=sai_ipaddress(self.customer_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor,
                                         dst_mac_address=self.customer_mac,
                                         no_host_route=True)

        self.onbor_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif, ip_address=sai_ipaddress(self.customer_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor_v6,
                                         dst_mac_address=self.customer_mac,
                                         no_host_route=True)

        self.customer_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(self.customer_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer_route,
                                      next_hop_id=self.onhop)

        self.customer_route_v6 = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(self.customer_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer_route_v6,
                                      next_hop_id=self.onhop_v6)

    def runTest(self):
        self.encapTtlUniformModeVxlanTest()
        self.encapTtlUniformModeIpv4InIpv4Test()
        self.encapTtlUniformModeIpv4InIpv6Test()
        self.encapTtlUniformModeIpv6InIpv4Test()
        self.encapTtlUniformModeIpv6InIpv6Test()
        self.decapTtlUniformModeVxlanTest()
        self.decapTtlUniformModeIpv4InIpv4Test()
        self.decapTtlUniformModeIpv4InIpv6Test()
        self.decapTtlUniformModeIpv6InIpv4Test()
        self.decapTtlUniformModeIpv6InIpv6Test()

    def tearDown(self):
        sai_thrift_remove_route_entry(self.client, self.tunnel_route)
        sai_thrift_remove_route_entry(self.client, self.tunnel_route_v6)
        sai_thrift_remove_neighbor_entry(self.client, self.unbor)
        sai_thrift_remove_neighbor_entry(self.client, self.unbor_v6)
        sai_thrift_remove_next_hop(self.client, self.unhop)
        sai_thrift_remove_next_hop(self.client, self.unhop_v6)
        sai_thrift_remove_route_entry(self.client, self.customer_route)
        sai_thrift_remove_route_entry(self.client, self.customer_route_v6)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor_v6)
        sai_thrift_remove_next_hop(self.client, self.onhop)
        sai_thrift_remove_next_hop(self.client, self.onhop_v6)
        sai_thrift_remove_router_interface(self.client, self.orif)
        sai_thrift_remove_router_interface(self.client, self.urif)
        sai_thrift_remove_router_interface(self.client, self.orif_lpb)
        sai_thrift_remove_router_interface(self.client, self.urif_lpb)
        sai_thrift_remove_virtual_router(self.client, self.ovrf)
        sai_thrift_remove_virtual_router(self.client, self.uvrf)

        super(TunnelTtlModeTest, self).tearDown()

    def encapTtlUniformModeVxlanTest(self):
        '''
        Verify if TTL value is properly set in VXLAN packets, according
        to the received TTL value
        '''
        print("\nencapTtlUniformModeVxlanTest()")

        ttl_val = 20
        ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P

        try:
            encap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

            decap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

            encap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
                virtual_router_id_key=self.ovrf,
                vni_id_value=self.vni)

            decap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
                virtual_router_id_value=self.ovrf,
                vni_id_key=self.vni)

            encap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[encap_tunnel_map])
            decap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[decap_tunnel_map])

            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                encap_mappers=encap_maps,
                decap_mappers=decap_maps,
                encap_ttl_mode=ttl_mode,
                encap_ttl_val=ttl_val,
                underlay_interface=self.urif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.customer_mac,
                                    ip_dst=self.vm_ip,
                                    ip_src=self.customer_ip,
                                    ip_id=108,
                                    ip_ttl=51)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.vm_ip,
                                          ip_src=self.customer_ip,
                                          ip_id=108,
                                          ip_ttl=50)
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun_ip,
                                    ip_src=self.lpb_ip,
                                    ip_id=0,
                                    ip_ttl=50,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni,
                                    inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

            print("Sending IPv4 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, vxlan_pkt, self.uport_dev)
            print("\tOK")

            print("Modifying ttl_mode to pipe")
            ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            encap_ttl_mode=ttl_mode)
            vxlan_pkt_2 = Mask(
                simple_vxlan_packet(eth_dst=self.unbor_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun_ip,
                                    ip_src=self.lpb_ip,
                                    ip_id=0,
                                    ip_ttl=ttl_val,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni,
                                    inner_frame=inner_pkt))
            vxlan_pkt_2.set_do_not_care_scapy(UDP, 'sport')

            print("Sending IPv4 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, vxlan_pkt_2, self.uport_dev)
            print("\tOK")

            print("Modifying ttl_mode back to uniform")
            ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            encap_ttl_mode=ttl_mode)

            print("Sending IPv4 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, vxlan_pkt, self.uport_dev)
            print("\tOK")

        finally:
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               decap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               encap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map(self.client, decap_tunnel_map)
            sai_thrift_remove_tunnel_map(self.client, encap_tunnel_map)

    def encapTtlUniformModeIpv4InIpv4Test(self):
        '''
        Verify if TTL value is properly set in IPv4-in-IPv4 packets, according
        to the received TTL value
        '''
        print("\nencapTtlUniformModeIpv4InIpv4Test()")

        ttl_val = 20
        ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                encap_ttl_mode=ttl_mode,
                encap_ttl_val=ttl_val,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip),
                src_ip=sai_ipaddress(self.tun_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.customer_mac,
                                    ip_dst=self.vm_ip,
                                    ip_src=self.customer_ip,
                                    ip_id=108,
                                    ip_ttl=51)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.vm_ip,
                                          ip_src=self.customer_ip,
                                          ip_id=108,
                                          ip_ttl=50)
            ipip_pkt = simple_ipv4ip_packet(eth_dst=self.unbor_mac,
                                            eth_src=ROUTER_MAC,
                                            ip_id=0,
                                            ip_dst=self.tun_ip,
                                            ip_src=self.lpb_ip,
                                            ip_ttl=50,
                                            inner_frame=inner_pkt['IP'])

            print("Sending IPv4 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt, self.uport_dev)
            print("\tOK")

            print("Modifying ttl_mode to pipe")
            ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            encap_ttl_mode=ttl_mode)

            ipip_pkt_2 = simple_ipv4ip_packet(eth_dst=self.unbor_mac,
                                              eth_src=ROUTER_MAC,
                                              ip_id=0,
                                              ip_dst=self.tun_ip,
                                              ip_src=self.lpb_ip,
                                              ip_ttl=ttl_val,
                                              inner_frame=inner_pkt['IP'])

            print("Sending IPv4 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt_2, self.uport_dev)
            print("\tOK")

            print("Modifying ttl_mode back to uniform")
            ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            encap_ttl_mode=ttl_mode)

            print("Sending IPv4 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt, self.uport_dev)
            print("\tOK")

        finally:
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)

    def encapTtlUniformModeIpv4InIpv6Test(self):
        '''
        Verify if TTL value is properly set in IPv4-in-IPv6 packets, according
        to the received TTL value
        '''
        print("\nencapTtlUniformModeIpv4InIpv6Test()")

        ttl_val = 20
        ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ipv6),
                encap_ttl_mode=ttl_mode,
                encap_ttl_val=ttl_val,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ipv6),
                src_ip=sai_ipaddress(self.tun_ipv6))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ipv6),
                tunnel_mac=self.inner_dmac)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.customer_mac,
                                    ip_dst=self.vm_ip,
                                    ip_src=self.customer_ip,
                                    ip_id=108,
                                    ip_ttl=51)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.vm_ip,
                                          ip_src=self.customer_ip,
                                          ip_id=108,
                                          ip_ttl=50)
            ipip_pkt = simple_ipv6ip_packet(eth_dst=self.unbor_mac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_src=self.lpb_ipv6,
                                            ipv6_dst=self.tun_ipv6,
                                            ipv6_hlim=50,
                                            inner_frame=inner_pkt['IP'])

            print("Sending IPv4 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt, self.uport_dev)
            print("\tOK")

            print("Modifying ttl_mode to pipe")
            ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            encap_ttl_mode=ttl_mode)

            ipip_pkt_2 = simple_ipv6ip_packet(eth_dst=self.unbor_mac,
                                              eth_src=ROUTER_MAC,
                                              ipv6_src=self.lpb_ipv6,
                                              ipv6_dst=self.tun_ipv6,
                                              ipv6_hlim=ttl_val,
                                              inner_frame=inner_pkt['IP'])

            print("Sending IPv4 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt_2, self.uport_dev)
            print("\tOK")

            print("Modifying ttl_mode back to uniform")
            ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            encap_ttl_mode=ttl_mode)

            print("Sending IPv4 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt, self.uport_dev)
            print("\tOK")

        finally:
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)

    def encapTtlUniformModeIpv6InIpv4Test(self):
        '''
        Verify if TTL value is properly set in IPv6-in-IPv4 packets, according
        to the received TTL value
        '''
        print("\nencapTtlUniformModeIpv6InIpv4Test()")

        ttl_val = 20
        ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                encap_ttl_mode=ttl_mode,
                encap_ttl_val=ttl_val,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip),
                src_ip=sai_ipaddress(self.tun_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv6 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.customer_mac,
                                      ipv6_dst=self.vm_ipv6,
                                      ipv6_src=self.customer_ipv6,
                                      ipv6_hlim=51)
            inner_pkt = simple_udpv6_packet(eth_dst=self.inner_dmac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_dst=self.vm_ipv6,
                                            ipv6_src=self.customer_ipv6,
                                            ipv6_hlim=50)
            ipip_pkt = simple_ipv4ip_packet(eth_dst=self.unbor_mac,
                                            eth_src=ROUTER_MAC,
                                            ip_id=0,
                                            ip_dst=self.tun_ip,
                                            ip_src=self.lpb_ip,
                                            ip_ttl=50,
                                            inner_frame=inner_pkt['IPv6'])

            print("Sending IPv6 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt, self.uport_dev)
            print("\tOK")

            print("Modifying ttl_mode to pipe")
            ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            encap_ttl_mode=ttl_mode)

            ipip_pkt_2 = simple_ipv4ip_packet(eth_dst=self.unbor_mac,
                                              eth_src=ROUTER_MAC,
                                              ip_id=0,
                                              ip_dst=self.tun_ip,
                                              ip_src=self.lpb_ip,
                                              ip_ttl=ttl_val,
                                              inner_frame=inner_pkt['IPv6'])

            print("Sending IPv6 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt_2, self.uport_dev)
            print("\tOK")

            print("Modifying ttl_mode back to uniform")
            ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            encap_ttl_mode=ttl_mode)

            print("Sending IPv6 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt, self.uport_dev)
            print("\tOK")

        finally:
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)

    def encapTtlUniformModeIpv6InIpv6Test(self):
        '''
        Verify if TTL value is properly set in IPv6-in-IPv6 packets according
        to the received TTL value
        '''
        print("\nencapTtlUniformModeIpv6InIpv6Test()")

        ttl_val = 20
        ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ipv6),
                encap_ttl_mode=ttl_mode,
                encap_ttl_val=ttl_val,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ipv6),
                src_ip=sai_ipaddress(self.tun_ipv6))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ipv6),
                tunnel_mac=self.inner_dmac)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv6 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.customer_mac,
                                      ipv6_dst=self.vm_ipv6,
                                      ipv6_src=self.customer_ipv6,
                                      ipv6_hlim=51)
            inner_pkt = simple_udpv6_packet(eth_dst=self.inner_dmac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_dst=self.vm_ipv6,
                                            ipv6_src=self.customer_ipv6,
                                            ipv6_hlim=50)
            ipip_pkt = simple_ipv6ip_packet(eth_dst=self.unbor_mac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_src=self.lpb_ipv6,
                                            ipv6_dst=self.tun_ipv6,
                                            ipv6_hlim=50,
                                            inner_frame=inner_pkt['IPv6'])

            print("Sending IPv6 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt, self.uport_dev)
            print("\tOK")

            print("Modifying ttl_mode to pipe")
            ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            encap_ttl_mode=ttl_mode)

            ipip_pkt_2 = simple_ipv6ip_packet(eth_dst=self.unbor_mac,
                                              eth_src=ROUTER_MAC,
                                              ipv6_src=self.lpb_ipv6,
                                              ipv6_dst=self.tun_ipv6,
                                              ipv6_hlim=ttl_val,
                                              inner_frame=inner_pkt['IPv6'])

            print("Sending IPv6 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt_2, self.uport_dev)
            print("\tOK")

            print("Modifying ttl_mode back to uniform")
            ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            encap_ttl_mode=ttl_mode)

            print("Sending IPv6 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt, self.uport_dev)
            print("\tOK")

        finally:
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)

    def decapTtlUniformModeVxlanTest(self):
        '''
        Verify if TTL value is properly set according to the outer packet,
        when using uniform mode in VXLAN packets
        '''
        print("\ndecapTtlUniformModeVxlanTest()")

        ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P

        try:
            encap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

            decap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

            encap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
                virtual_router_id_key=self.ovrf,
                vni_id_value=self.vni)

            decap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
                virtual_router_id_value=self.ovrf,
                vni_id_key=self.vni)

            encap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[encap_tunnel_map])
            decap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[decap_tunnel_map])

            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                encap_mappers=encap_maps,
                decap_mappers=decap_maps,
                decap_ttl_mode=ttl_mode,
                underlay_interface=self.urif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.customer_ip,
                                    ip_src=self.vm_ip,
                                    ip_id=108,
                                    ip_ttl=50)
            inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.customer_ip,
                                          ip_src=self.vm_ip,
                                          ip_id=108,
                                          ip_ttl=60)
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=51,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)

            print("Sending VxLan packet")
            send_packet(self, self.uport_dev, vxlan_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

            print("Modifying ttl_mode to pipe")
            ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            decap_ttl_mode=ttl_mode)

            pkt_2 = simple_udp_packet(eth_dst=self.customer_mac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=59)

            print("Sending VxLan packet")
            send_packet(self, self.uport_dev, vxlan_pkt)
            verify_packet(self, pkt_2, self.oport_dev)
            print("\tOK")

            print("Modifying ttl_mode back to uniform")
            ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            decap_ttl_mode=ttl_mode)

            print("Sending VxLan packet")
            send_packet(self, self.uport_dev, vxlan_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

        finally:
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               decap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               encap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map(self.client, decap_tunnel_map)
            sai_thrift_remove_tunnel_map(self.client, encap_tunnel_map)

    def decapTtlUniformModeIpv4InIpv4Test(self):
        '''
        Verify if TTL value is properly set according to the outer packet,
        when using uniform mode in IPv4-in-IPv4 packets
        '''
        print("\ndecapTtlUniformModeIpv4InIpv4Test()")

        ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                decap_ttl_mode=ttl_mode,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.customer_ip,
                                    ip_src=self.vm_ip,
                                    ip_id=108,
                                    ip_ttl=50)
            inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                          eth_src=self.inner_dmac,
                                          ip_dst=self.customer_ip,
                                          ip_src=self.vm_ip,
                                          ip_id=108,
                                          ip_ttl=60)
            ipip_pkt = simple_ipv4ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=51,
                                            inner_frame=inner_pkt['IP'])

            print("Sending IPv4 packet")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

            print("Modifying ttl_mode to pipe")
            ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            decap_ttl_mode=ttl_mode)

            pkt_2 = simple_udp_packet(eth_dst=self.customer_mac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=59)

            print("Sending IPv4 packet")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt_2, self.oport_dev)
            print("\tOK")

            print("Modifying ttl_mode back to uniform")
            ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            decap_ttl_mode=ttl_mode)

            print("Sending IPv4 packet")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

        finally:
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)

    def decapTtlUniformModeIpv4InIpv6Test(self):
        '''
        Verify if TTL value is properly set according to the outer packet,
        when using uniform mode in IPv4-in-IPv6 packets
        '''
        print("\ndecapTtlUniformModeIpv4InIpv6Test()")

        ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ipv6),
                decap_ttl_mode=ttl_mode,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ipv6),
                src_ip=sai_ipaddress(self.tun_ipv6))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ipv6),
                tunnel_mac=self.inner_dmac)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.customer_ip,
                                    ip_src=self.vm_ip,
                                    ip_id=108,
                                    ip_ttl=50)
            inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                          eth_src=self.inner_dmac,
                                          ip_dst=self.customer_ip,
                                          ip_src=self.vm_ip,
                                          ip_id=108,
                                          ip_ttl=60)
            ipip_pkt = simple_ipv6ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ipv6_dst=self.lpb_ipv6,
                                            ipv6_src=self.tun_ipv6,
                                            ipv6_hlim=51,
                                            inner_frame=inner_pkt['IP'])

            print("Sending IPv4 packet")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

            print("Modifying ttl_mode to pipe")
            ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            decap_ttl_mode=ttl_mode)

            pkt_2 = simple_udp_packet(eth_dst=self.customer_mac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=59)

            print("Sending IPv4 packet")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt_2, self.oport_dev)
            print("\tOK")

            print("Modifying ttl_mode back to uniform")
            ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            decap_ttl_mode=ttl_mode)

            print("Sending IPv4 packet")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

        finally:
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)

    def decapTtlUniformModeIpv6InIpv4Test(self):
        '''
        Verify if TTL value is properly set according to the outer packet,
        when using uniform mode in IPv6-in-IPv4 packets
        '''
        print("\ndecapTtlUniformModeIpv6InIpv4Test()")

        ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                decap_ttl_mode=ttl_mode,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv6 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udpv6_packet(eth_dst=self.customer_mac,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=self.customer_ipv6,
                                      ipv6_src=self.vm_ipv6,
                                      ipv6_hlim=50)
            inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.inner_dmac,
                                            ipv6_dst=self.customer_ipv6,
                                            ipv6_src=self.vm_ipv6,
                                            ipv6_hlim=60)
            ipip_pkt = simple_ipv4ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_ttl=51,
                                            inner_frame=inner_pkt['IPv6'])

            print("Sending IPv6 packet")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

            print("Modifying ttl_mode to pipe")
            ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            decap_ttl_mode=ttl_mode)

            pkt_2 = simple_udpv6_packet(eth_dst=self.customer_mac,
                                        eth_src=ROUTER_MAC,
                                        ipv6_dst=self.customer_ipv6,
                                        ipv6_src=self.vm_ipv6,
                                        ipv6_hlim=59)

            print("Sending IPv6 packet")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt_2, self.oport_dev)
            print("\tOK")

            print("Modifying ttl_mode back to uniform")
            ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            decap_ttl_mode=ttl_mode)

            print("Sending IPv6 packet")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

        finally:
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)

    def decapTtlUniformModeIpv6InIpv6Test(self):
        '''
        Verify if TTL value is properly set according to the outer packet,
        when using uniform mode in IPv6-in-IPv6 packets
        '''
        print("\ndecapTtlUniformModeIpv6InIpv6Test()")

        ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ipv6),
                decap_ttl_mode=ttl_mode,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ipv6))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ipv6),
                tunnel_mac=self.inner_dmac)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv6 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udpv6_packet(eth_dst=self.customer_mac,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=self.customer_ipv6,
                                      ipv6_src=self.vm_ipv6,
                                      ipv6_hlim=50)
            inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.inner_dmac,
                                            ipv6_dst=self.customer_ipv6,
                                            ipv6_src=self.vm_ipv6,
                                            ipv6_hlim=60)
            ipip_pkt = simple_ipv6ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ipv6_dst=self.lpb_ipv6,
                                            ipv6_src=self.tun_ipv6,
                                            ipv6_hlim=51,
                                            inner_frame=inner_pkt['IPv6'])

            print("Sending IPv6 packet")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

            print("Modifying ttl_mode to pipe")
            ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            decap_ttl_mode=ttl_mode)

            pkt_2 = simple_udpv6_packet(eth_dst=self.customer_mac,
                                        eth_src=ROUTER_MAC,
                                        ipv6_dst=self.customer_ipv6,
                                        ipv6_src=self.vm_ipv6,
                                        ipv6_hlim=59)

            print("Sending IPv6 packet")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt_2, self.oport_dev)
            print("\tOK")

            print("Modifying ttl_mode back to uniform")
            ttl_mode = SAI_TUNNEL_TTL_MODE_UNIFORM_MODEL
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            decap_ttl_mode=ttl_mode)

            print("Sending IPv6 packet")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

        finally:
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)


@group("draft")
class TunnelQosModeTest(SaiHelper):
    '''
    Tests of the qos_mode, focusing mostly on the pipe mode.
    Note that the uniform ttl_mode is covered in more detail in
    TunnelAttributesTest.
    '''

    def setUp(self):
        super(TunnelQosModeTest, self).setUp()

        self.oport = self.port24
        self.oport_dev = self.dev_port24
        self.uport = self.port25
        self.uport_dev = self.dev_port25

        self.vni = 1000
        self.tun_ip = "10.10.10.1"
        self.tun_ipv6 = "2001:0db8::10:1"
        self.lpb_ip = "10.10.10.2"
        self.lpb_ipv6 = "2001:0db8::10:10"
        self.vm_ip = "100.100.1.1"
        self.vm_ipv6 = "2001:0db8::100:1"
        self.customer_ip = "100.100.2.1"
        self.customer_ipv6 = "2001:0db8::100:2"
        self.inner_dmac = "00:11:11:11:11:11"
        self.customer_mac = "00:22:22:22:22:22"
        self.unbor_mac = "00:33:33:33:33:33"

        # underlay configuration
        self.uvrf = sai_thrift_create_virtual_router(self.client)

        # overlay configuraion
        self.ovrf = sai_thrift_create_virtual_router(self.client)

        # underlay loopback RIF for tunnel
        self.urif_lpb = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_LOOPBACK,
            virtual_router_id=self.uvrf)

        self.orif_lpb = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_LOOPBACK,
            virtual_router_id=self.ovrf)

        self.urif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.uvrf,
            port_id=self.uport)

        # route to tunnel
        self.unhop = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip),
                                                router_interface_id=self.urif,
                                                type=SAI_NEXT_HOP_TYPE_IP)

        self.unhop_v6 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.tun_ipv6),
            router_interface_id=self.urif,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.unbor = sai_thrift_neighbor_entry_t(
            rif_id=self.urif, ip_address=sai_ipaddress(self.tun_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.unbor,
                                         dst_mac_address=self.unbor_mac,
                                         no_host_route=True)

        self.unbor_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.urif, ip_address=sai_ipaddress(self.tun_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.unbor_v6,
                                         dst_mac_address=self.unbor_mac,
                                         no_host_route=True)

        self.tunnel_route = sai_thrift_route_entry_t(
            vr_id=self.uvrf, destination=sai_ipprefix(self.tun_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.tunnel_route,
                                      next_hop_id=self.unhop)

        self.tunnel_route_v6 = sai_thrift_route_entry_t(
            vr_id=self.uvrf, destination=sai_ipprefix(self.tun_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.tunnel_route_v6,
                                      next_hop_id=self.unhop_v6)

        self.orif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.ovrf,
            port_id=self.oport)

        # route to customer from VM
        self.onhop = sai_thrift_create_next_hop(
            self.client, ip=sai_ipaddress(self.customer_ip),
            router_interface_id=self.orif, type=SAI_NEXT_HOP_TYPE_IP)

        self.onhop_v6 = sai_thrift_create_next_hop(
            self.client, ip=sai_ipaddress(self.customer_ipv6),
            router_interface_id=self.orif, type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor = sai_thrift_neighbor_entry_t(
            rif_id=self.orif, ip_address=sai_ipaddress(self.customer_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor,
                                         dst_mac_address=self.customer_mac,
                                         no_host_route=True)

        self.onbor_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif, ip_address=sai_ipaddress(self.customer_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor_v6,
                                         dst_mac_address=self.customer_mac,
                                         no_host_route=True)

        self.customer_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(self.customer_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer_route,
                                      next_hop_id=self.onhop)

        self.customer_route_v6 = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(self.customer_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer_route_v6,
                                      next_hop_id=self.onhop_v6)

    def runTest(self):
        self.encapDscpPipeModeVxlanTest()
        self.encapDscpPipeModeIpInIpTest()
        self.encapDscpPipeModeIpv6InIpv6Test()
        self.decapDscpPipeModeVxlanTest()
        self.decapDscpPipeModeIpInIpTest()
        self.decapDscpPipeModeIpv6InIpv6Test()

    def tearDown(self):
        sai_thrift_remove_route_entry(self.client, self.tunnel_route)
        sai_thrift_remove_route_entry(self.client, self.tunnel_route_v6)
        sai_thrift_remove_neighbor_entry(self.client, self.unbor)
        sai_thrift_remove_neighbor_entry(self.client, self.unbor_v6)
        sai_thrift_remove_next_hop(self.client, self.unhop)
        sai_thrift_remove_next_hop(self.client, self.unhop_v6)
        sai_thrift_remove_route_entry(self.client, self.customer_route)
        sai_thrift_remove_route_entry(self.client, self.customer_route_v6)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor_v6)
        sai_thrift_remove_next_hop(self.client, self.onhop)
        sai_thrift_remove_next_hop(self.client, self.onhop_v6)
        sai_thrift_remove_router_interface(self.client, self.orif)
        sai_thrift_remove_router_interface(self.client, self.urif)
        sai_thrift_remove_router_interface(self.client, self.orif_lpb)
        sai_thrift_remove_router_interface(self.client, self.urif_lpb)
        sai_thrift_remove_virtual_router(self.client, self.ovrf)
        sai_thrift_remove_virtual_router(self.client, self.uvrf)

        super(TunnelQosModeTest, self).tearDown()

    def encapDscpPipeModeVxlanTest(self):
        '''
        Verify if DSCP value is properly set according to
        SAI_TUNNEL_ATTR_ENCAP_DSCP_VAL attribute
        '''
        print("\nencapDscpPipeModeVxlanTest()")

        orig_dscp_val = 18
        rewrite_dscp_val = 20
        map_tc = 2
        tunnel_dscp_val = 10
        dscp_mode = SAI_TUNNEL_DSCP_MODE_PIPE_MODEL
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P
        qos_map_exists = False

        try:
            encap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

            decap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

            encap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
                virtual_router_id_key=self.ovrf,
                vni_id_value=self.vni)

            decap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
                virtual_router_id_value=self.ovrf,
                vni_id_key=self.vni)

            encap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[encap_tunnel_map])
            decap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[decap_tunnel_map])

            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                encap_mappers=encap_maps,
                decap_mappers=decap_maps,
                encap_ttl_mode=ttl_mode,
                encap_dscp_mode=dscp_mode,
                encap_dscp_val=tunnel_dscp_val,
                underlay_interface=self.urif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.customer_mac,
                                    ip_dst=self.vm_ip,
                                    ip_src=self.customer_ip,
                                    ip_id=108,
                                    ip_dscp=orig_dscp_val,
                                    ip_ttl=64)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.vm_ip,
                                          ip_src=self.customer_ip,
                                          ip_id=108,
                                          ip_dscp=orig_dscp_val,
                                          ip_ttl=63)
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun_ip,
                                    ip_src=self.lpb_ip,
                                    ip_id=0,
                                    ip_dscp=tunnel_dscp_val,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni,
                                    inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

            print("Sending IPv4 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, vxlan_pkt, self.uport_dev)
            print("\tOK")

            print("Modifying encap DSCP value")
            tunnel_dscp_val = 12
            sai_thrift_set_tunnel_attribute(self.client,
                                            tunnel,
                                            encap_dscp_val=tunnel_dscp_val)
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun_ip,
                                    ip_src=self.lpb_ip,
                                    ip_id=0,
                                    ip_dscp=tunnel_dscp_val,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni,
                                    inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

            print("Sending IPv4 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, vxlan_pkt, self.uport_dev)
            print("\tOK")

            print("Define qos maps to map orig_dscp_val to rewrite_dscp_val")
            dscp_to_tc_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(dscp=orig_dscp_val),
                    value=sai_thrift_qos_map_params_t(tc=map_tc))])
            dscp_to_tc_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_DSCP_TO_TC,
                map_to_value_list=dscp_to_tc_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.oport,
                qos_dscp_to_tc_map=dscp_to_tc_map_id)
            tc_to_dscp_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(
                        tc=map_tc, color=SAI_PACKET_COLOR_GREEN),
                    value=sai_thrift_qos_map_params_t(dscp=rewrite_dscp_val))])
            tc_to_dscp_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
                map_to_value_list=tc_to_dscp_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.uport,
                qos_tc_and_color_to_dscp_map=tc_to_dscp_map_id)
            qos_map_exists = True

            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.customer_mac,
                                    ip_dst=self.vm_ip,
                                    ip_src=self.customer_ip,
                                    ip_id=108,
                                    ip_dscp=orig_dscp_val,
                                    ip_ttl=64)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.vm_ip,
                                          ip_src=self.customer_ip,
                                          ip_id=108,
                                          ip_dscp=rewrite_dscp_val,
                                          ip_ttl=63)
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun_ip,
                                    ip_src=self.lpb_ip,
                                    ip_id=0,
                                    ip_dscp=tunnel_dscp_val,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni,
                                    inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

            print("Sending IPv4 packet subject to dscp rewrite")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, vxlan_pkt, self.uport_dev)
            print("\tOK")

        finally:
            if qos_map_exists:
                sai_thrift_set_port_attribute(
                    self.client,
                    self.oport,
                    qos_dscp_to_tc_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, dscp_to_tc_map_id)
                sai_thrift_set_port_attribute(
                    self.client,
                    self.uport,
                    qos_tc_and_color_to_dscp_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, tc_to_dscp_map_id)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               decap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               encap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map(self.client, decap_tunnel_map)
            sai_thrift_remove_tunnel_map(self.client, encap_tunnel_map)

    def encapDscpPipeModeIpInIpTest(self):
        '''
        Verify if DSCP value is properly set according to
        SAI_TUNNEL_ATTR_ENCAP_DSCP_VAL attribute in IP-in-IP packets
        '''
        print("\nencapDscpPipeModeIpInIpTest()")

        orig_dscp_val = 18
        rewrite_dscp_val = 20
        map_tc = 2
        tunnel_dscp_val = 10
        dscp_mode = SAI_TUNNEL_DSCP_MODE_PIPE_MODEL
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P
        qos_map_exists = False

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                encap_ttl_mode=ttl_mode,
                encap_dscp_mode=dscp_mode,
                encap_dscp_val=tunnel_dscp_val,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip),
                src_ip=sai_ipaddress(self.tun_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.customer_mac,
                                    ip_dst=self.vm_ip,
                                    ip_src=self.customer_ip,
                                    ip_id=108,
                                    ip_dscp=orig_dscp_val,
                                    ip_ttl=64)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.vm_ip,
                                          ip_src=self.customer_ip,
                                          ip_id=108,
                                          ip_dscp=orig_dscp_val,
                                          ip_ttl=63)
            ipip_pkt = simple_ipv4ip_packet(eth_dst=self.unbor_mac,
                                            eth_src=ROUTER_MAC,
                                            ip_id=0,
                                            ip_dst=self.tun_ip,
                                            ip_src=self.lpb_ip,
                                            ip_dscp=tunnel_dscp_val,
                                            ip_ttl=64,
                                            inner_frame=inner_pkt['IP'])

            print("Sending IPv4 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt, self.uport_dev)
            print("\tOK")

            print("Define qos maps to map orig_dscp_val to rewrite_dscp_val")
            dscp_to_tc_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(dscp=orig_dscp_val),
                    value=sai_thrift_qos_map_params_t(tc=map_tc))])
            dscp_to_tc_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_DSCP_TO_TC,
                map_to_value_list=dscp_to_tc_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.oport,
                qos_dscp_to_tc_map=dscp_to_tc_map_id)
            tc_to_dscp_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(
                        tc=map_tc, color=SAI_PACKET_COLOR_GREEN),
                    value=sai_thrift_qos_map_params_t(dscp=rewrite_dscp_val))])
            tc_to_dscp_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
                map_to_value_list=tc_to_dscp_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.uport,
                qos_tc_and_color_to_dscp_map=tc_to_dscp_map_id)
            qos_map_exists = True

            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.customer_mac,
                                    ip_dst=self.vm_ip,
                                    ip_src=self.customer_ip,
                                    ip_id=108,
                                    ip_dscp=orig_dscp_val,
                                    ip_ttl=64)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.vm_ip,
                                          ip_src=self.customer_ip,
                                          ip_id=108,
                                          ip_dscp=rewrite_dscp_val,
                                          ip_ttl=63)
            ipip_pkt = simple_ipv4ip_packet(eth_dst=self.unbor_mac,
                                            eth_src=ROUTER_MAC,
                                            ip_id=0,
                                            ip_dst=self.tun_ip,
                                            ip_src=self.lpb_ip,
                                            ip_dscp=tunnel_dscp_val,
                                            ip_ttl=64,
                                            inner_frame=inner_pkt['IP'])

            print("Sending IPv4 packet subject to dscp rewrite")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt, self.uport_dev)
            print("\tOK")

        finally:
            if qos_map_exists:
                sai_thrift_set_port_attribute(
                    self.client,
                    self.oport,
                    qos_dscp_to_tc_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, dscp_to_tc_map_id)
                sai_thrift_set_port_attribute(
                    self.client,
                    self.uport,
                    qos_tc_and_color_to_dscp_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, tc_to_dscp_map_id)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)

    def encapDscpPipeModeIpv6InIpv6Test(self):
        '''
        Verify if DSCP value is properly set according to
        SAI_TUNNEL_ATTR_ENCAP_DSCP_VAL attribute in IPv6-in-IPv6 packets
        '''
        print("\nencapDscpPipeModeIpv6InIpv6Test()")

        orig_dscp_val = 18
        rewrite_dscp_val = 20
        map_tc = 2
        tunnel_dscp_val = 10
        dscp_mode = SAI_TUNNEL_DSCP_MODE_PIPE_MODEL
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P
        qos_map_exists = False

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ipv6),
                encap_ttl_mode=ttl_mode,
                encap_dscp_mode=dscp_mode,
                encap_dscp_val=tunnel_dscp_val,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ipv6),
                src_ip=sai_ipaddress(self.tun_ipv6))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ipv6),
                tunnel_mac=self.inner_dmac)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv6 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.customer_mac,
                                      ipv6_dst=self.vm_ipv6,
                                      ipv6_src=self.customer_ipv6,
                                      ipv6_dscp=orig_dscp_val,
                                      ipv6_hlim=64)
            inner_pkt = simple_udpv6_packet(eth_dst=self.inner_dmac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_dst=self.vm_ipv6,
                                            ipv6_src=self.customer_ipv6,
                                            ipv6_dscp=orig_dscp_val,
                                            ipv6_hlim=63)
            ipip_pkt = simple_ipv6ip_packet(eth_dst=self.unbor_mac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_src=self.lpb_ipv6,
                                            ipv6_dst=self.tun_ipv6,
                                            ipv6_dscp=tunnel_dscp_val,
                                            ipv6_hlim=64,
                                            inner_frame=inner_pkt['IPv6'])

            print("Sending IPv6 packet")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt, self.uport_dev)
            print("\tOK")

            print("Define qos maps to map orig_dscp_val to rewrite_dscp_val")
            dscp_to_tc_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(dscp=orig_dscp_val),
                    value=sai_thrift_qos_map_params_t(tc=map_tc))])
            dscp_to_tc_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_DSCP_TO_TC,
                map_to_value_list=dscp_to_tc_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.oport,
                qos_dscp_to_tc_map=dscp_to_tc_map_id)
            tc_to_dscp_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(
                        tc=map_tc, color=SAI_PACKET_COLOR_GREEN),
                    value=sai_thrift_qos_map_params_t(dscp=rewrite_dscp_val))])
            tc_to_dscp_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
                map_to_value_list=tc_to_dscp_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.uport,
                qos_tc_and_color_to_dscp_map=tc_to_dscp_map_id)
            qos_map_exists = True

            pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.customer_mac,
                                      ipv6_dst=self.vm_ipv6,
                                      ipv6_src=self.customer_ipv6,
                                      ipv6_dscp=orig_dscp_val,
                                      ipv6_hlim=64)
            inner_pkt = simple_udpv6_packet(eth_dst=self.inner_dmac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_dst=self.vm_ipv6,
                                            ipv6_src=self.customer_ipv6,
                                            ipv6_dscp=rewrite_dscp_val,
                                            ipv6_hlim=63)
            ipip_pkt = simple_ipv6ip_packet(eth_dst=self.unbor_mac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_src=self.lpb_ipv6,
                                            ipv6_dst=self.tun_ipv6,
                                            ipv6_dscp=tunnel_dscp_val,
                                            ipv6_hlim=64,
                                            inner_frame=inner_pkt['IPv6'])

            print("Sending IPv6 packet subject to dscp rewrite")
            send_packet(self, self.oport_dev, pkt)
            verify_packet(self, ipip_pkt, self.uport_dev)
            print("\tOK")

        finally:
            if qos_map_exists:
                sai_thrift_set_port_attribute(
                    self.client,
                    self.oport,
                    qos_dscp_to_tc_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, dscp_to_tc_map_id)
                sai_thrift_set_port_attribute(
                    self.client,
                    self.uport,
                    qos_tc_and_color_to_dscp_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, tc_to_dscp_map_id)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)

    def decapDscpPipeModeVxlanTest(self):
        '''
        Verify if DSCP value is properly set according to the inner packet,
        when using pipe mode in VXLAN packets
        '''
        print("\ndecapDscpPipeModeVxlanTest()")

        tunnel_dscp_val = 10
        inner_dscp_val = 18
        rewrite_dscp_val = 20
        map_tc = 2
        dscp_mode = SAI_TUNNEL_DSCP_MODE_PIPE_MODEL
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P
        qos_map_exists = False

        try:
            encap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

            decap_tunnel_map = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

            encap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
                virtual_router_id_key=self.ovrf,
                vni_id_value=self.vni)

            decap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
                virtual_router_id_value=self.ovrf,
                vni_id_key=self.vni)

            encap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[encap_tunnel_map])
            decap_maps = sai_thrift_object_list_t(count=1,
                                                  idlist=[decap_tunnel_map])

            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                encap_mappers=encap_maps,
                decap_mappers=decap_maps,
                decap_ttl_mode=ttl_mode,
                decap_dscp_mode=dscp_mode,
                underlay_interface=self.urif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.customer_ip,
                                    ip_src=self.vm_ip,
                                    ip_id=108,
                                    ip_dscp=inner_dscp_val,
                                    ip_ttl=62)
            inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.customer_ip,
                                          ip_src=self.vm_ip,
                                          ip_id=108,
                                          ip_dscp=inner_dscp_val,
                                          ip_ttl=63)
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_dscp=tunnel_dscp_val,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)

            print("Sending VxLan packet")
            send_packet(self, self.uport_dev, vxlan_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

            print("Define qos maps to map inner_dscp_val to rewrite_dscp_val")
            dscp_to_tc_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(dscp=inner_dscp_val),
                    value=sai_thrift_qos_map_params_t(tc=map_tc))])
            dscp_to_tc_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_DSCP_TO_TC,
                map_to_value_list=dscp_to_tc_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.uport,
                qos_dscp_to_tc_map=dscp_to_tc_map_id)
            tc_to_dscp_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(
                        tc=map_tc, color=SAI_PACKET_COLOR_GREEN),
                    value=sai_thrift_qos_map_params_t(dscp=rewrite_dscp_val))])
            tc_to_dscp_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
                map_to_value_list=tc_to_dscp_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.oport,
                qos_tc_and_color_to_dscp_map=tc_to_dscp_map_id)
            qos_map_exists = True

            pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.customer_ip,
                                    ip_src=self.vm_ip,
                                    ip_id=108,
                                    ip_dscp=rewrite_dscp_val,
                                    ip_ttl=62)
            inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.customer_ip,
                                          ip_src=self.vm_ip,
                                          ip_id=108,
                                          ip_dscp=inner_dscp_val,
                                          ip_ttl=63)
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_dscp=tunnel_dscp_val,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)

            print("Sending VxLan packet subject to dscp rewrite")
            send_packet(self, self.uport_dev, vxlan_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

        finally:
            if qos_map_exists:
                sai_thrift_set_port_attribute(
                    self.client,
                    self.uport,
                    qos_dscp_to_tc_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, dscp_to_tc_map_id)
                sai_thrift_set_port_attribute(
                    self.client,
                    self.oport,
                    qos_tc_and_color_to_dscp_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, tc_to_dscp_map_id)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               decap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               encap_tunnel_map_entry)
            sai_thrift_remove_tunnel_map(self.client, decap_tunnel_map)
            sai_thrift_remove_tunnel_map(self.client, encap_tunnel_map)

    def decapDscpPipeModeIpInIpTest(self):
        '''
        Verify if DSCP value is properly set according to the inner packet,
        when using pipe mode in IP-in-IP packets
        '''
        print("\ndecapDscpPipeModeIpInIpTest()")

        tunnel_dscp_val = 10
        inner_dscp_val = 18
        rewrite_dscp_val = 20
        map_tc = 2
        dscp_mode = SAI_TUNNEL_DSCP_MODE_PIPE_MODEL
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P
        qos_map_exists = False

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                decap_ttl_mode=ttl_mode,
                decap_dscp_mode=dscp_mode,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ip))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ip),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.customer_ip,
                                    ip_src=self.vm_ip,
                                    ip_id=108,
                                    ip_dscp=inner_dscp_val,
                                    ip_ttl=62)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.customer_ip,
                                          ip_src=self.vm_ip,
                                          ip_id=108,
                                          ip_dscp=inner_dscp_val,
                                          ip_ttl=63)
            ipip_pkt = simple_ipv4ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_dscp=tunnel_dscp_val,
                                            ip_ttl=64,
                                            inner_frame=inner_pkt['IP'])

            print("Sending IPv4 packet")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

            print("Define qos maps to map inner_dscp_val to rewrite_dscp_val")
            dscp_to_tc_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(dscp=inner_dscp_val),
                    value=sai_thrift_qos_map_params_t(tc=map_tc))])
            dscp_to_tc_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_DSCP_TO_TC,
                map_to_value_list=dscp_to_tc_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.uport,
                qos_dscp_to_tc_map=dscp_to_tc_map_id)
            tc_to_dscp_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(
                        tc=map_tc, color=SAI_PACKET_COLOR_GREEN),
                    value=sai_thrift_qos_map_params_t(dscp=rewrite_dscp_val))])
            tc_to_dscp_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
                map_to_value_list=tc_to_dscp_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.oport,
                qos_tc_and_color_to_dscp_map=tc_to_dscp_map_id)
            qos_map_exists = True

            pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.customer_ip,
                                    ip_src=self.vm_ip,
                                    ip_id=108,
                                    ip_dscp=rewrite_dscp_val,
                                    ip_ttl=62)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.customer_ip,
                                          ip_src=self.vm_ip,
                                          ip_id=108,
                                          ip_dscp=inner_dscp_val,
                                          ip_ttl=63)
            ipip_pkt = simple_ipv4ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_dst=self.lpb_ip,
                                            ip_src=self.tun_ip,
                                            ip_id=0,
                                            ip_dscp=tunnel_dscp_val,
                                            ip_ttl=64,
                                            inner_frame=inner_pkt['IP'])

            print("Sending IPv4 packet subject to dscp rewrite")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

        finally:
            if qos_map_exists:
                sai_thrift_set_port_attribute(
                    self.client,
                    self.uport,
                    qos_dscp_to_tc_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, dscp_to_tc_map_id)
                sai_thrift_set_port_attribute(
                    self.client,
                    self.oport,
                    qos_tc_and_color_to_dscp_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, tc_to_dscp_map_id)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)

    def decapDscpPipeModeIpv6InIpv6Test(self):
        '''
        Verify if DSCP value is properly set according to the inner packet,
        when using pipe mode in IPv6-in-IPv6 packets
        '''
        print("\ndecapDscpPipeModeIpv6InIpv6Test()")

        tunnel_dscp_val = 10
        inner_dscp_val = 18
        rewrite_dscp_val = 20
        map_tc = 2
        dscp_mode = SAI_TUNNEL_DSCP_MODE_PIPE_MODEL
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P
        qos_map_exists = False

        try:
            tunnel = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                encap_src_ip=sai_ipaddress(self.lpb_ipv6),
                decap_ttl_mode=ttl_mode,
                decap_dscp_mode=dscp_mode,
                underlay_interface=self.urif_lpb,
                overlay_interface=self.orif_lpb)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                tunnel_type=tunnel_type,
                vr_id=self.uvrf,
                action_tunnel_id=tunnel,
                type=term_type,
                dst_ip=sai_ipaddress(self.lpb_ipv6))

            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=tunnel,
                ip=sai_ipaddress(self.tun_ipv6),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)

            vm_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(self.vm_ipv6 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udpv6_packet(eth_dst=self.customer_mac,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=self.customer_ipv6,
                                      ipv6_src=self.vm_ipv6,
                                      ipv6_dscp=inner_dscp_val,
                                      ipv6_hlim=62)
            inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.inner_dmac,
                                            ipv6_dst=self.customer_ipv6,
                                            ipv6_src=self.vm_ipv6,
                                            ipv6_dscp=inner_dscp_val,
                                            ipv6_hlim=63)
            ipip_pkt = simple_ipv6ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ipv6_dst=self.lpb_ipv6,
                                            ipv6_src=self.tun_ipv6,
                                            ipv6_dscp=tunnel_dscp_val,
                                            ipv6_hlim=64,
                                            inner_frame=inner_pkt['IPv6'])

            print("Sending IPv6 packet")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

            print("Define qos maps to map inner_dscp_val to rewrite_dscp_val")
            dscp_to_tc_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(dscp=inner_dscp_val),
                    value=sai_thrift_qos_map_params_t(tc=map_tc))])
            dscp_to_tc_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_DSCP_TO_TC,
                map_to_value_list=dscp_to_tc_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.uport,
                qos_dscp_to_tc_map=dscp_to_tc_map_id)
            tc_to_dscp_map_list = sai_thrift_qos_map_list_t(
                1,
                [sai_thrift_qos_map_t(
                    key=sai_thrift_qos_map_params_t(
                        tc=map_tc, color=SAI_PACKET_COLOR_GREEN),
                    value=sai_thrift_qos_map_params_t(dscp=rewrite_dscp_val))])
            tc_to_dscp_map_id = sai_thrift_create_qos_map(
                self.client,
                type=SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
                map_to_value_list=tc_to_dscp_map_list)
            sai_thrift_set_port_attribute(
                self.client,
                self.oport,
                qos_tc_and_color_to_dscp_map=tc_to_dscp_map_id)
            qos_map_exists = True

            pkt = simple_udpv6_packet(eth_dst=self.customer_mac,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=self.customer_ipv6,
                                      ipv6_src=self.vm_ipv6,
                                      ipv6_dscp=rewrite_dscp_val,
                                      ipv6_hlim=62)
            inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.inner_dmac,
                                            ipv6_dst=self.customer_ipv6,
                                            ipv6_src=self.vm_ipv6,
                                            ipv6_dscp=inner_dscp_val,
                                            ipv6_hlim=63)
            ipip_pkt = simple_ipv6ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ipv6_dst=self.lpb_ipv6,
                                            ipv6_src=self.tun_ipv6,
                                            ipv6_dscp=tunnel_dscp_val,
                                            ipv6_hlim=64,
                                            inner_frame=inner_pkt['IPv6'])

            print("Sending IPv6 packet subject to dscp rewrite")
            send_packet(self, self.uport_dev, ipip_pkt)
            verify_packet(self, pkt, self.oport_dev)
            print("\tOK")

        finally:
            if qos_map_exists:
                sai_thrift_set_port_attribute(
                    self.client,
                    self.uport,
                    qos_dscp_to_tc_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, dscp_to_tc_map_id)
                sai_thrift_set_port_attribute(
                    self.client,
                    self.oport,
                    qos_tc_and_color_to_dscp_map=int(SAI_NULL_OBJECT_ID))
                sai_thrift_remove_qos_map(self.client, tc_to_dscp_map_id)
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel)


# # # # # # # # # # Base VxLAN point to point tests follow # # # # # # # # # #
@group("draft")
class VxLanTunnelIpv4UnderlayTest(VxLanBaseSetup):
    '''
    VxLAN tunnel tests with IPv4 underlay layer
    '''

    def runTest(self):
        self.encapDecapTest()
        self.tunnelTermSrcIpTest()

    def encapDecapTest(self):
        '''
        Verify encapsulation and decapsulation for VxLAN tunnels
        '''
        print("\nencapDecapTest()")

        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=self.customer_mac,
                                ip_dst=self.vm_ip,
                                ip_src=self.customer_ip,
                                ip_id=108,
                                ip_ttl=64)
        inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.vm_ip,
                                      ip_src=self.customer_ip,
                                      ip_id=108,
                                      ip_ttl=63)
        vxlan_pkt = Mask(
            simple_vxlan_packet(eth_dst=self.unbor_mac,
                                eth_src=ROUTER_MAC,
                                ip_dst=self.tun_ip,
                                ip_src=self.lpb_ip,
                                ip_id=0,
                                ip_ttl=64,
                                ip_flags=0x2,
                                with_udp_chksum=False,
                                vxlan_vni=self.vni,
                                inner_frame=inner_pkt))
        vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

        print("Verifying VxLan tunnel encapsulation")
        send_packet(self, self.oport_dev, pkt)
        verify_packet(self, vxlan_pkt, self.uport_dev)
        print("\tOK")

        pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                eth_src=ROUTER_MAC,
                                ip_dst=self.customer_ip,
                                ip_src=self.vm_ip,
                                ip_id=108,
                                ip_ttl=63)
        inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.inner_dmac,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=64)
        vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.unbor_mac,
                                        ip_dst=self.lpb_ip,
                                        ip_src=self.tun_ip,
                                        ip_id=0,
                                        ip_ttl=64,
                                        ip_flags=0x2,
                                        udp_sport=11638,
                                        with_udp_chksum=False,
                                        vxlan_vni=self.vni,
                                        inner_frame=inner_pkt)

        print("Verifying VxLan tunnel decapsulation")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_packet(self, pkt, self.oport_dev)
        print("\tOK")

    def tunnelTermSrcIpTest(self):
        '''
        Verify if tunnel de-encapsulation doesn't occur only for tunneled
        packets with source IP not equal to
        SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_SRC_IP
        '''
        print("\ntunnelTermSrcIpTest()")

        test_src_ip = "100.100.100.100"

        inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=63)
        vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.unbor_mac,
                                        ip_dst=self.lpb_ip,
                                        ip_src=test_src_ip,
                                        ip_id=0,
                                        ip_ttl=64,
                                        ip_flags=0x2,
                                        with_udp_chksum=False,
                                        vxlan_vni=self.vni,
                                        inner_frame=inner_pkt)

        print("Verifying if VxLan decapsulation doesn't work with improper "
              "tunnel src IP")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")


@group("draft")
class VxLanTunnelIpv6UnderlayTest(VxLanBaseSetup):
    '''
    VxLAN tunnel tests with IPv6 underlay layer
    '''

    def __init__(self):
        super(VxLanTunnelIpv6UnderlayTest, self).__init__(ipv6=True)

    def runTest(self):
        self.encapDecapTest()
        self.tunnelTermSrcIpTest()

    def encapDecapTest(self):
        '''
        Verify encapsulation and decapsulation for VxLAN tunnels
        '''
        print("\nencapDecapTest()")

        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=self.customer_mac,
                                ip_dst=self.vm_ip,
                                ip_src=self.customer_ip,
                                ip_id=108,
                                ip_ttl=64)
        inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.vm_ip,
                                      ip_src=self.customer_ip,
                                      ip_id=108,
                                      ip_ttl=63)
        vxlan_pkt = Mask(
            simple_vxlanv6_packet(eth_dst=self.unbor_mac,
                                  eth_src=ROUTER_MAC,
                                  ipv6_dst=self.tun_ip,
                                  ipv6_src=self.lpb_ip,
                                  ipv6_hlim=64,
                                  with_udp_chksum=False,
                                  vxlan_vni=self.vni,
                                  inner_frame=inner_pkt))
        vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

        print("Verifying VxLan tunnel encapsulation")
        send_packet(self, self.oport_dev, pkt)
        verify_packet(self, vxlan_pkt, self.uport_dev)
        print("\tOK")

        pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                eth_src=ROUTER_MAC,
                                ip_dst=self.customer_ip,
                                ip_src=self.vm_ip,
                                ip_id=108,
                                ip_ttl=63)
        inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.inner_dmac,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=64)
        vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                          eth_src=self.unbor_mac,
                                          ipv6_dst=self.lpb_ip,
                                          ipv6_src=self.tun_ip,
                                          ipv6_hlim=64,
                                          udp_sport=11638,
                                          with_udp_chksum=False,
                                          vxlan_vni=self.vni,
                                          inner_frame=inner_pkt)

        print("Verifying VxLan tunnel decapsulation")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_packet(self, pkt, self.oport_dev)
        print("\tOK")

    def tunnelTermSrcIpTest(self):
        '''
        Verify if tunnel de-encapsulation doesn't occur only for tunneled
        packets with source IP not equal to
        SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_SRC_IP
        '''
        print("\ntunnelTermSrcIpTest()")

        test_src_ip = "2001:0db8::100:100"

        inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=63)
        vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                          eth_src=self.unbor_mac,
                                          ipv6_dst=self.lpb_ip,
                                          ipv6_src=test_src_ip,
                                          ipv6_hlim=64,
                                          with_udp_chksum=False,
                                          vxlan_vni=self.vni,
                                          inner_frame=inner_pkt)

        print("Verifying if VxLan decapsulation doesn't work with improper "
              "tunnel src IP")
        send_packet(self, self.uport_dev, vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")


# # # # # # # # # Base IP in IP point to point tests follow # # # # # # # # #
@group("draft")
class IpInIpTunnelBase(SaiHelper):
    '''
    Base setup for IP in IP tunnel tests

    Args:
        ipv6 (bool): ipv6 underlay configuraton indicator
    '''

    def __init__(self, ipv6=False):
        super(IpInIpTunnelBase, self).__init__()
        self.ipv6 = ipv6

        if ipv6 is True:
            self.tun_ip = "2001:0db8::10:1"
            self.lpb_ip = "2001:0db8::10:10"
            self.tun_lpb_mask = "/128"
        else:
            self.tun_ip = "10.10.10.1"
            self.lpb_ip = "10.10.10.10"
            self.tun_lpb_mask = "/32"

    def setUp(self):
        super(IpInIpTunnelBase, self).setUp()

        self.oport = self.port24
        self.oport_dev = self.dev_port24
        self.uport = self.port25
        self.uport_dev = self.dev_port25

        self.vm_ip = "100.100.1.1"
        self.vm_ipv6 = "2001:0db8::100:1"
        self.customer_ip = "100.100.2.1"
        self.customer_ipv6 = "2001:0db8::100:2"
        self.inner_dmac = "00:11:11:11:11:11"
        self.customer_mac = "00:22:22:22:22:11"
        self.unbor_mac = "00:33:33:33:33:11"

        # underlay configuration
        self.uvrf = sai_thrift_create_virtual_router(self.client)

        # overlay configuration
        self.ovrf = sai_thrift_create_virtual_router(self.client)
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2P
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL

        # loopback RIFs for tunnel
        self.urif_lpb = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_LOOPBACK,
            virtual_router_id=self.uvrf)

        self.orif_lpb = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_LOOPBACK,
            virtual_router_id=self.ovrf)

        # route to tunnel
        self.urif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.uvrf,
            port_id=self.uport)

        self.unhop = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip),
                                                router_interface_id=self.urif,
                                                type=SAI_NEXT_HOP_TYPE_IP)

        self.unbor = sai_thrift_neighbor_entry_t(
            rif_id=self.urif, ip_address=sai_ipaddress(self.tun_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.unbor,
                                         dst_mac_address=self.unbor_mac,
                                         no_host_route=True)

        self.tunnel_route = sai_thrift_route_entry_t(
            vr_id=self.uvrf,
            destination=sai_ipprefix(self.tun_ip + self.tun_lpb_mask))
        sai_thrift_create_route_entry(self.client,
                                      self.tunnel_route,
                                      next_hop_id=self.unhop)

        # tunnel
        self.tunnel = sai_thrift_create_tunnel(
            self.client,
            type=tunnel_type,
            encap_src_ip=sai_ipaddress(self.lpb_ip),
            encap_ttl_mode=ttl_mode,
            decap_ttl_mode=ttl_mode,
            underlay_interface=self.urif_lpb,
            overlay_interface=self.orif_lpb)

        # tunnel termination entry
        self.tunnel_term = sai_thrift_create_tunnel_term_table_entry(
            self.client,
            tunnel_type=tunnel_type,
            vr_id=self.uvrf,
            action_tunnel_id=self.tunnel,
            type=term_type,
            dst_ip=sai_ipaddress(self.lpb_ip),
            src_ip=sai_ipaddress(self.tun_ip))

        # tunnel nexthop for VM
        self.tunnel_nhop = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
            tunnel_id=self.tunnel,
            ip=sai_ipaddress(self.tun_ip),
            tunnel_mac=self.inner_dmac)

        # routes to VM via tunnel nexthop
        self.vm_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.vm_route,
                                      next_hop_id=self.tunnel_nhop)

        self.vm_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.vm_v6_route,
                                      next_hop_id=self.tunnel_nhop)

        # routes to customer from VM
        self.orif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.ovrf,
            port_id=self.oport)

        self.onhop = sai_thrift_create_next_hop(
            self.client, ip=sai_ipaddress(self.customer_ip),
            router_interface_id=self.orif, type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor = sai_thrift_neighbor_entry_t(
            rif_id=self.orif, ip_address=sai_ipaddress(self.customer_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor,
                                         dst_mac_address=self.customer_mac,
                                         no_host_route=True)

        self.customer_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(self.customer_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer_route,
                                      next_hop_id=self.onhop)

        self.onhop_v6 = sai_thrift_create_next_hop(
            self.client, ip=sai_ipaddress(self.customer_ipv6),
            router_interface_id=self.orif, type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif, ip_address=sai_ipaddress(self.customer_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor_v6,
                                         dst_mac_address=self.customer_mac,
                                         no_host_route=True)

        self.customer_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(self.customer_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer_v6_route,
                                      next_hop_id=self.onhop_v6)

    def tearDown(self):
        sai_thrift_remove_route_entry(self.client, self.customer_v6_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor_v6)
        sai_thrift_remove_next_hop(self.client, self.onhop_v6)
        sai_thrift_remove_route_entry(self.client, self.customer_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor)
        sai_thrift_remove_next_hop(self.client, self.onhop)
        sai_thrift_remove_router_interface(self.client, self.orif)
        sai_thrift_remove_route_entry(self.client, self.vm_v6_route)
        sai_thrift_remove_route_entry(self.client, self.vm_route)
        sai_thrift_remove_next_hop(self.client, self.tunnel_nhop)
        sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                  self.tunnel_term)
        sai_thrift_remove_tunnel(self.client, self.tunnel)
        sai_thrift_remove_route_entry(self.client, self.tunnel_route)
        sai_thrift_remove_neighbor_entry(self.client, self.unbor)
        sai_thrift_remove_next_hop(self.client, self.unhop)
        sai_thrift_remove_router_interface(self.client, self.urif)
        sai_thrift_remove_router_interface(self.client, self.orif_lpb)
        sai_thrift_remove_router_interface(self.client, self.urif_lpb)
        sai_thrift_remove_virtual_router(self.client, self.ovrf)
        sai_thrift_remove_virtual_router(self.client, self.uvrf)

        super(IpInIpTunnelBase, self).tearDown()

    def innerIpv4TunnelTest(self):
        '''
        Base IPv4 in IP tunnel test
        '''
        print("\ninnerIpv4TunnelTest()")

        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=self.customer_mac,
                                ip_dst=self.vm_ip,
                                ip_src=self.customer_ip,
                                ip_id=108,
                                ip_ttl=64)
        inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.vm_ip,
                                      ip_src=self.customer_ip,
                                      ip_id=108,
                                      ip_ttl=63)
        if self.ipv6 is False:
            ipip_pkt = simple_ipv4ip_packet(eth_dst=self.unbor_mac,
                                            eth_src=ROUTER_MAC,
                                            ip_id=0,
                                            ip_src=self.lpb_ip,
                                            ip_dst=self.tun_ip,
                                            inner_frame=inner_pkt['IP'])
        else:
            ipip_pkt = simple_ipv6ip_packet(eth_dst=self.unbor_mac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_src=self.lpb_ip,
                                            ipv6_dst=self.tun_ip,
                                            inner_frame=inner_pkt['IP'])

        print("Verifying IPinIP (4 in %d) encapsulation"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.oport_dev, pkt)
        verify_packet(self, ipip_pkt, self.uport_dev)
        print("\tOK")

        pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                eth_src=ROUTER_MAC,
                                ip_dst=self.customer_ip,
                                ip_src=self.vm_ip,
                                ip_id=108,
                                ip_ttl=63)
        inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=64)
        if self.ipv6 is False:
            ipip_pkt = simple_ipv4ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_id=0,
                                            ip_src=self.tun_ip,
                                            ip_dst=self.lpb_ip,
                                            inner_frame=inner_pkt['IP'])
        else:
            ipip_pkt = simple_ipv6ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ipv6_src=self.tun_ip,
                                            ipv6_dst=self.lpb_ip,
                                            inner_frame=inner_pkt['IP'])

        print("Verifying IPinIP (4 in %d) decapsulation"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.uport_dev, ipip_pkt)
        verify_packet(self, pkt, self.oport_dev)
        print("\tOK")

    def innerIpv6TunnelTest(self):
        '''
        Base IPv6 in IP tunnel test
        '''
        print("\ninnerIpv6TunnelTest()")

        pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                  eth_src=self.customer_mac,
                                  ipv6_dst=self.vm_ipv6,
                                  ipv6_src=self.customer_ipv6,
                                  ipv6_hlim=64)
        inner_pkt = simple_udpv6_packet(eth_dst=self.inner_dmac,
                                        eth_src=ROUTER_MAC,
                                        ipv6_dst=self.vm_ipv6,
                                        ipv6_src=self.customer_ipv6,
                                        ipv6_hlim=63)
        if self.ipv6 is False:
            ipip_pkt = simple_ipv4ip_packet(eth_dst=self.unbor_mac,
                                            eth_src=ROUTER_MAC,
                                            ip_id=0,
                                            ip_src=self.lpb_ip,
                                            ip_dst=self.tun_ip,
                                            inner_frame=inner_pkt['IPv6'])
        else:
            ipip_pkt = simple_ipv6ip_packet(eth_dst=self.unbor_mac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_src=self.lpb_ip,
                                            ipv6_dst=self.tun_ip,
                                            inner_frame=inner_pkt['IPv6'])

        print("Verifying IPinIP (6 in %d) encapsulation"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.oport_dev, pkt)
        verify_packet(self, ipip_pkt, self.uport_dev)
        print("\tOK")

        pkt = simple_udpv6_packet(eth_dst=self.customer_mac,
                                  eth_src=ROUTER_MAC,
                                  ipv6_dst=self.customer_ipv6,
                                  ipv6_src=self.vm_ipv6,
                                  ipv6_hlim=63)
        inner_pkt = simple_udpv6_packet(eth_dst=self.inner_dmac,
                                        eth_src=ROUTER_MAC,
                                        ipv6_dst=self.customer_ipv6,
                                        ipv6_src=self.vm_ipv6,
                                        ipv6_hlim=64)
        if self.ipv6 is False:
            ipip_pkt = simple_ipv4ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_id=0,
                                            ip_src=self.tun_ip,
                                            ip_dst=self.lpb_ip,
                                            inner_frame=inner_pkt['IPv6'])
        else:
            ipip_pkt = simple_ipv6ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ipv6_src=self.tun_ip,
                                            ipv6_dst=self.lpb_ip,
                                            inner_frame=inner_pkt['IPv6'])

        print("Verifying IPinIP (6 in %d) decapsulation"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.uport_dev, ipip_pkt)
        verify_packet(self, pkt, self.oport_dev)
        print("\tOK")

    def tunnelTermSrcIpTest(self):
        '''
        Verify if tunnel de-encapsulation doesn't occur only for tunneled
        packets with source IP not equal to
        SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_SRC_IP
        '''
        print("\ntunnelTermSrcIpTest()")

        inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=64)
        if self.ipv6 is False:
            test_src_ip = "100.100.100.100"
            ipip_pkt = simple_ipv4ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ip_id=0,
                                            ip_src=test_src_ip,
                                            ip_dst=self.lpb_ip,
                                            inner_frame=inner_pkt['IP'])
        else:
            test_src_ip = "2001:0db8::100:100"
            ipip_pkt = simple_ipv6ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac,
                                            ipv6_src=test_src_ip,
                                            ipv6_dst=self.lpb_ip,
                                            inner_frame=inner_pkt['IP'])

        print("Verifying if IPinIP (4 in %d) decapsulation doesn't work "
              "with improper tunnel src IP" % (6 if self.ipv6 else 4))
        send_packet(self, self.uport_dev, ipip_pkt)
        verify_no_other_packets(self)
        print("\tDropped")


@group("draft")
class IpInIpTnnnelIpv4UnderlayTest(IpInIpTunnelBase):
    '''
    IP in IP tunnel tests with IPv4 underlay layer
    '''

    def runTest(self):
        self.innerIpv4TunnelTest()
        self.innerIpv6TunnelTest()
        self.tunnelTermSrcIpTest()


@group("draft")
class IpInIpTnnnelIpv6UnderlayTest(IpInIpTunnelBase):
    '''
    IP in IP tunnel tests with IPv6 underlay layer
    '''

    def __init__(self):
        super(IpInIpTnnnelIpv6UnderlayTest, self).__init__(ipv6=True)

    def runTest(self):
        self.innerIpv4TunnelTest()
        self.innerIpv6TunnelTest()
        self.tunnelTermSrcIpTest()


# # # # # # # # # # VxLAN point to multipoint tests follow # # # # # # # # # #
@group("draft")
class VxLanP2MpTnnnelBase(SaiHelper):
    '''
    Base configuration for VxLAN tunnel point to multipoint tests

    Args:
        ipv6 (bool): ipv6 underlay configuraton indicator
    '''

    def __init__(self, ipv6=False):
        super(VxLanP2MpTnnnelBase, self).__init__()
        self.ipv6 = ipv6

        if ipv6 is True:
            self.tun_ip1 = "2001:0db8::10:1"
            self.tun_ip2 = "2001:0db8::20:1"
            self.tun_ip3 = "2001:0db8::30:1"
            self.lpb_ip1 = "2001:0db8::10:10"
            self.lpb_ip2 = "2001:0db8::20:10"
            self.lpb_ip3 = "2001:0db8::30:10"
            self.tun_lpb_mask = "/128"
        else:
            self.tun_ip1 = "10.10.10.1"
            self.tun_ip2 = "20.20.20.1"
            self.tun_ip3 = "30.30.30.1"
            self.lpb_ip1 = "10.10.10.10"
            self.lpb_ip2 = "20.20.20.10"
            self.lpb_ip3 = "30.30.30.10"
            self.tun_lpb_mask = "/32"

    def setUp(self):
        super(VxLanP2MpTnnnelBase, self).setUp()

        self.oport = self.port24
        self.oport_dev = self.dev_port24
        self.uport1 = self.port25
        self.uport1_dev = self.dev_port25
        self.uport2 = self.port26
        self.uport2_dev = self.dev_port26
        self.uport3 = self.port27
        self.uport3_dev = self.dev_port27

        self.vni = 1000
        self.vm_ip = "100.100.1.1"
        self.vm_ipv6 = "2001:0db8::100:1"
        self.customer_ip = "100.100.2.1"
        self.customer_ipv6 = "2001:0db8::100:2"
        self.inner_dmac = "00:11:11:11:11:11"
        self.customer_mac = "00:22:22:22:22:11"
        self.unbor_mac1 = "00:33:33:33:33:11"
        self.unbor_mac2 = "00:33:33:33:33:22"
        self.unbor_mac3 = "00:33:33:33:33:33"

        # underlay configuration
        self.uvrf1 = sai_thrift_create_virtual_router(self.client)
        self.uvrf2 = sai_thrift_create_virtual_router(self.client)
        self.uvrf3 = sai_thrift_create_virtual_router(self.client)

        # overlay configuration
        self.ovrf = sai_thrift_create_virtual_router(self.client)
        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2MP
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL

        # loopback RIF for tunnel
        self.urif_lpb = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_LOOPBACK,
            virtual_router_id=self.uvrf1)

        # routes to tunnel from underlay RIFs
        self.urif1 = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.uvrf1,
            port_id=self.uport1)

        self.unhop1 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.tun_ip1),
            router_interface_id=self.urif1,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.unbor1 = sai_thrift_neighbor_entry_t(
            rif_id=self.urif1, ip_address=sai_ipaddress(self.tun_ip1))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.unbor1,
                                         dst_mac_address=self.unbor_mac1,
                                         no_host_route=True)

        self.tunnel_route1 = sai_thrift_route_entry_t(
            vr_id=self.uvrf1,
            destination=sai_ipprefix(self.tun_ip1 + self.tun_lpb_mask))
        sai_thrift_create_route_entry(self.client,
                                      self.tunnel_route1,
                                      next_hop_id=self.unhop1)

        self.urif2 = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.uvrf2,
            port_id=self.uport2)

        self.unhop2 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.tun_ip2),
            router_interface_id=self.urif2,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.unbor2 = sai_thrift_neighbor_entry_t(
            rif_id=self.urif2, ip_address=sai_ipaddress(self.tun_ip2))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.unbor2,
                                         dst_mac_address=self.unbor_mac2,
                                         no_host_route=True)

        self.tunnel_route2 = sai_thrift_route_entry_t(
            vr_id=self.uvrf2,
            destination=sai_ipprefix(self.tun_ip2 + self.tun_lpb_mask))
        sai_thrift_create_route_entry(self.client,
                                      self.tunnel_route2,
                                      next_hop_id=self.unhop2)

        self.urif3 = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.uvrf3,
            port_id=self.uport3)

        self.unhop3 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.tun_ip3),
            router_interface_id=self.urif3,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.unbor3 = sai_thrift_neighbor_entry_t(
            rif_id=self.urif1, ip_address=sai_ipaddress(self.tun_ip3))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.unbor3,
                                         dst_mac_address=self.unbor_mac3,
                                         no_host_route=True)

        self.tunnel_route3 = sai_thrift_route_entry_t(
            vr_id=self.uvrf3,
            destination=sai_ipprefix(self.tun_ip3 + self.tun_lpb_mask))
        sai_thrift_create_route_entry(self.client,
                                      self.tunnel_route3,
                                      next_hop_id=self.unhop3)

        # encap/decap mappers
        self.encap_tunnel_map = sai_thrift_create_tunnel_map(
            self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

        self.decap_tunnel_map = sai_thrift_create_tunnel_map(
            self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

        # encap/decap mapper entries
        self.encap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
            self.client,
            tunnel_map=self.encap_tunnel_map,
            tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
            virtual_router_id_key=self.ovrf,
            vni_id_value=self.vni)

        self.decap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
            self.client,
            tunnel_map=self.encap_tunnel_map,
            tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
            virtual_router_id_value=self.ovrf,
            vni_id_key=self.vni)

        encap_maps = sai_thrift_object_list_t(count=1,
                                              idlist=[self.encap_tunnel_map])
        decap_maps = sai_thrift_object_list_t(count=1,
                                              idlist=[self.decap_tunnel_map])

        # tunnel
        self.tunnel = sai_thrift_create_tunnel(
            self.client,
            type=tunnel_type,
            encap_src_ip=sai_ipaddress(self.lpb_ip1),
            encap_mappers=encap_maps,
            decap_mappers=decap_maps,
            encap_ttl_mode=ttl_mode,
            decap_ttl_mode=ttl_mode,
            underlay_interface=self.urif_lpb)

        # tunnel termination entries
        self.tunnel_term1 = sai_thrift_create_tunnel_term_table_entry(
            self.client,
            tunnel_type=tunnel_type,
            vr_id=self.uvrf1,
            action_tunnel_id=self.tunnel,
            type=term_type,
            src_ip=sai_ipaddress(self.tun_ip1),
            dst_ip=sai_ipaddress(self.lpb_ip1))

        self.tunnel_term2 = sai_thrift_create_tunnel_term_table_entry(
            self.client,
            tunnel_type=tunnel_type,
            vr_id=self.uvrf2,
            action_tunnel_id=self.tunnel,
            type=term_type,
            src_ip=sai_ipaddress(self.tun_ip2),
            dst_ip=sai_ipaddress(self.lpb_ip2))

        self.tunnel_term3 = sai_thrift_create_tunnel_term_table_entry(
            self.client,
            tunnel_type=tunnel_type,
            vr_id=self.uvrf3,
            action_tunnel_id=self.tunnel,
            type=term_type,
            src_ip=sai_ipaddress(self.tun_ip3),
            dst_ip=sai_ipaddress(self.lpb_ip3))

        # tunnel nexthop for VM
        self.tunnel_nhop = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
            tunnel_id=self.tunnel,
            ip=sai_ipaddress(self.tun_ip1),
            tunnel_mac=self.inner_dmac,
            tunnel_vni=self.vni)

        # routes to VM via tunnel nexthop
        self.vm_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.vm_route,
                                      next_hop_id=self.tunnel_nhop)

        self.vm_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.vm_v6_route,
                                      next_hop_id=self.tunnel_nhop)

        # routes to customer from VM
        self.orif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.ovrf,
            port_id=self.oport)

        self.onhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer_ip),
            router_interface_id=self.orif,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor = sai_thrift_neighbor_entry_t(
            rif_id=self.orif, ip_address=sai_ipaddress(self.customer_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor,
                                         dst_mac_address=self.customer_mac,
                                         no_host_route=True)

        self.customer_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(self.customer_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer_route,
                                      next_hop_id=self.onhop)

        self.onhop_v6 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer_ipv6),
            router_interface_id=self.orif,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif, ip_address=sai_ipaddress(self.customer_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor_v6,
                                         dst_mac_address=self.customer_mac,
                                         no_host_route=True)

        self.customer_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(self.customer_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer_v6_route,
                                      next_hop_id=self.onhop_v6)

    def tearDown(self):
        sai_thrift_remove_route_entry(self.client, self.customer_v6_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor_v6)
        sai_thrift_remove_next_hop(self.client, self.onhop_v6)
        sai_thrift_remove_route_entry(self.client, self.customer_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor)
        sai_thrift_remove_next_hop(self.client, self.onhop)
        sai_thrift_remove_router_interface(self.client, self.orif)
        sai_thrift_remove_route_entry(self.client, self.vm_v6_route)
        sai_thrift_remove_route_entry(self.client, self.vm_route)
        sai_thrift_remove_next_hop(self.client, self.tunnel_nhop)
        sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                  self.tunnel_term3)
        sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                  self.tunnel_term2)
        sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                  self.tunnel_term1)
        sai_thrift_remove_tunnel(self.client, self.tunnel)
        sai_thrift_remove_tunnel_map_entry(self.client,
                                           self.decap_tunnel_map_entry)
        sai_thrift_remove_tunnel_map_entry(self.client,
                                           self.encap_tunnel_map_entry)
        sai_thrift_remove_tunnel_map(self.client, self.decap_tunnel_map)
        sai_thrift_remove_tunnel_map(self.client, self.encap_tunnel_map)
        sai_thrift_remove_route_entry(self.client, self.tunnel_route3)
        sai_thrift_remove_neighbor_entry(self.client, self.unbor3)
        sai_thrift_remove_next_hop(self.client, self.unhop3)
        sai_thrift_remove_router_interface(self.client, self.urif3)
        sai_thrift_remove_route_entry(self.client, self.tunnel_route2)
        sai_thrift_remove_neighbor_entry(self.client, self.unbor2)
        sai_thrift_remove_next_hop(self.client, self.unhop2)
        sai_thrift_remove_router_interface(self.client, self.urif2)
        sai_thrift_remove_route_entry(self.client, self.tunnel_route1)
        sai_thrift_remove_neighbor_entry(self.client, self.unbor1)
        sai_thrift_remove_next_hop(self.client, self.unhop1)
        sai_thrift_remove_router_interface(self.client, self.urif1)
        sai_thrift_remove_router_interface(self.client, self.urif_lpb)
        sai_thrift_remove_virtual_router(self.client, self.ovrf)
        sai_thrift_remove_virtual_router(self.client, self.uvrf3)
        sai_thrift_remove_virtual_router(self.client, self.uvrf2)
        sai_thrift_remove_virtual_router(self.client, self.uvrf1)

        super(VxLanP2MpTnnnelBase, self).tearDown()

    def vxLanP2MpSingleIpv4OvrfTunnelTest(self):
        '''
        Verify point to multipoint tunnel case with single IPv4 overlay VRF
        '''
        print("\nvxLanP2MpSingleIpv4OvrfTunnelTest()")

        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=self.customer_mac,
                                ip_dst=self.vm_ip,
                                ip_src=self.customer_ip,
                                ip_id=108,
                                ip_ttl=64)
        inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.vm_ip,
                                      ip_src=self.customer_ip,
                                      ip_id=108,
                                      ip_ttl=63)
        if self.ipv6 is False:
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor_mac1,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun_ip1,
                                    ip_src=self.lpb_ip1,
                                    ip_id=0,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni,
                                    inner_frame=inner_pkt))
        else:
            vxlan_pkt = Mask(
                simple_vxlanv6_packet(eth_dst=self.unbor_mac1,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=self.tun_ip1,
                                      ipv6_src=self.lpb_ip1,
                                      ipv6_hlim=64,
                                      with_udp_chksum=False,
                                      vxlan_vni=self.vni,
                                      inner_frame=inner_pkt))
        vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

        print("Verifying VxLAN (4 in %d) encapsulation"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.oport_dev, pkt)
        verify_packet(self, vxlan_pkt, self.uport1_dev)
        print("\tOK")

        pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                eth_src=ROUTER_MAC,
                                ip_dst=self.customer_ip,
                                ip_src=self.vm_ip,
                                ip_id=108,
                                ip_ttl=63)
        inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.inner_dmac,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=64)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac1,
                                            ip_dst=self.lpb_ip1,
                                            ip_src=self.tun_ip1,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac1,
                                              ipv6_dst=self.lpb_ip1,
                                              ipv6_src=self.tun_ip1,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Verifying VxLAN (4 in %d) decapsulation (term 1)"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.uport1_dev, vxlan_pkt)
        verify_packet(self, pkt, self.oport_dev)
        print("\tOK")

        pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                eth_src=ROUTER_MAC,
                                ip_dst=self.customer_ip,
                                ip_src=self.vm_ip,
                                ip_id=108,
                                ip_ttl=63)
        inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.inner_dmac,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=64)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac2,
                                            ip_dst=self.lpb_ip2,
                                            ip_src=self.tun_ip2,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac2,
                                              ipv6_dst=self.lpb_ip2,
                                              ipv6_src=self.tun_ip2,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Verifying VxLAN (4 in %d) decapsulation (term 2)"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.uport2_dev, vxlan_pkt)
        verify_packet(self, pkt, self.oport_dev)
        print("\tOK")

        pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                eth_src=ROUTER_MAC,
                                ip_dst=self.customer_ip,
                                ip_src=self.vm_ip,
                                ip_id=108,
                                ip_ttl=63)
        inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.inner_dmac,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=64)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac3,
                                            ip_dst=self.lpb_ip3,
                                            ip_src=self.tun_ip3,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac3,
                                              ipv6_dst=self.lpb_ip3,
                                              ipv6_src=self.tun_ip3,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Verifying VxLAN (4 in %d) decapsulation (term 3)"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.uport3_dev, vxlan_pkt)
        verify_packet(self, pkt, self.oport_dev)
        print("\tOK")

    def vxLanP2MpSingleIpv6OvrfTunnelTest(self):
        '''
        Verify point to multipoint tunnel case with single IPv6 overlay VRF
        '''
        print("\nvxLanP2MpSingleIpv6OvrfTunnelTest()")

        pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                  eth_src=self.customer_mac,
                                  ipv6_dst=self.vm_ipv6,
                                  ipv6_src=self.customer_ipv6,
                                  ipv6_hlim=64)
        inner_pkt = simple_udpv6_packet(eth_dst=self.inner_dmac,
                                        eth_src=ROUTER_MAC,
                                        ipv6_dst=self.vm_ipv6,
                                        ipv6_src=self.customer_ipv6,
                                        ipv6_hlim=63)
        if self.ipv6 is False:
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor_mac1,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun_ip1,
                                    ip_src=self.lpb_ip1,
                                    ip_id=0,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni,
                                    inner_frame=inner_pkt))
        else:
            vxlan_pkt = Mask(
                simple_vxlanv6_packet(eth_dst=self.unbor_mac1,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=self.tun_ip1,
                                      ipv6_src=self.lpb_ip1,
                                      ipv6_hlim=64,
                                      with_udp_chksum=False,
                                      vxlan_vni=self.vni,
                                      inner_frame=inner_pkt))
        vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

        print("Verifying VxLAN (6 in %d) encapsulation"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.oport_dev, pkt)
        verify_packet(self, vxlan_pkt, self.uport1_dev)
        print("\tOK")

        pkt = simple_udpv6_packet(eth_dst=self.customer_mac,
                                  eth_src=ROUTER_MAC,
                                  ipv6_dst=self.customer_ipv6,
                                  ipv6_src=self.vm_ipv6,
                                  ipv6_hlim=63)
        inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.inner_dmac,
                                        ipv6_dst=self.customer_ipv6,
                                        ipv6_src=self.vm_ipv6,
                                        ipv6_hlim=64)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac1,
                                            ip_dst=self.lpb_ip1,
                                            ip_src=self.tun_ip1,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac1,
                                              ipv6_dst=self.lpb_ip1,
                                              ipv6_src=self.tun_ip1,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Verifying VxLAN (6 in %d) decapsulation (term 1)"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.uport1_dev, vxlan_pkt)
        verify_packet(self, pkt, self.oport_dev)
        print("\tOK")

        pkt = simple_udpv6_packet(eth_dst=self.customer_mac,
                                  eth_src=ROUTER_MAC,
                                  ipv6_dst=self.customer_ipv6,
                                  ipv6_src=self.vm_ipv6,
                                  ipv6_hlim=63)
        inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.inner_dmac,
                                        ipv6_dst=self.customer_ipv6,
                                        ipv6_src=self.vm_ipv6,
                                        ipv6_hlim=64)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac2,
                                            ip_dst=self.lpb_ip2,
                                            ip_src=self.tun_ip2,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac2,
                                              ipv6_dst=self.lpb_ip2,
                                              ipv6_src=self.tun_ip2,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Verifying VxLAN (6 in %d) decapsulation (term 2)"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.uport2_dev, vxlan_pkt)
        verify_packet(self, pkt, self.oport_dev)
        print("\tOK")

        pkt = simple_udpv6_packet(eth_dst=self.customer_mac,
                                  eth_src=ROUTER_MAC,
                                  ipv6_dst=self.customer_ipv6,
                                  ipv6_src=self.vm_ipv6,
                                  ipv6_hlim=63)
        inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.inner_dmac,
                                        ipv6_dst=self.customer_ipv6,
                                        ipv6_src=self.vm_ipv6,
                                        ipv6_hlim=64)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac3,
                                            ip_dst=self.lpb_ip3,
                                            ip_src=self.tun_ip3,
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor_mac3,
                                              ipv6_dst=self.lpb_ip3,
                                              ipv6_src=self.tun_ip3,
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Verifying VxLAN (6 in %d) decapsulation (term 3)"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.uport3_dev, vxlan_pkt)
        verify_packet(self, pkt, self.oport_dev)
        print("\tOK")

    def vxLanP2MpMultipleOvrfTunnelTest(self):
        '''
        Verify point to multipoint tunnel with multiple overlay VRF
        '''
        print("\nvxLanP2MpIpv4MultipleOvrfTunnelTest()")

        try:
            oport2 = self.port28
            oport2_dev = self.dev_port28
            oport3 = self.port29
            oport3_dev = self.dev_port29

            vni2 = 2000
            vni3 = 3000

            customer2_ip = "100.100.2.1"
            customer2_ipv6 = "2001:0db8::2:1"
            customer2_mac = '00:22:22:22:22:22'
            customer3_ip = "100.100.3.1"
            customer3_ipv6 = "2001:0db8::3:1"
            customer3_mac = '00:22:22:22:22:33'

            ovrf2 = sai_thrift_create_virtual_router(self.client)
            ovrf3 = sai_thrift_create_virtual_router(self.client)

            orif2 = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_PORT,
                virtual_router_id=ovrf2,
                port_id=oport2)

            orif3 = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_PORT,
                virtual_router_id=ovrf3,
                port_id=oport3)

            encap_tunnel_map_entry2 = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=self.encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
                virtual_router_id_key=ovrf2,
                vni_id_value=vni2)

            decap_tunnel_map_entry2 = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=self.encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
                virtual_router_id_key=ovrf2,
                vni_id_value=vni2)

            onhop2 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(customer2_ip),
                                                router_interface_id=orif2,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            onbor2 = sai_thrift_neighbor_entry_t(
                rif_id=orif2, ip_address=sai_ipaddress(customer2_ip))
            sai_thrift_create_neighbor_entry(self.client,
                                             onbor2,
                                             dst_mac_address=customer2_mac,
                                             no_host_route=True)

            customer2_route = sai_thrift_route_entry_t(
                vr_id=ovrf2, destination=sai_ipprefix(customer2_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          customer2_route,
                                          next_hop_id=onhop2)

            onhop2_v6 = sai_thrift_create_next_hop(
                self.client,
                ip=sai_ipaddress(customer2_ipv6),
                router_interface_id=orif2,
                type=SAI_NEXT_HOP_TYPE_IP)

            onbor2_v6 = sai_thrift_neighbor_entry_t(
                rif_id=orif2, ip_address=sai_ipaddress(customer2_ipv6))
            sai_thrift_create_neighbor_entry(self.client,
                                             onbor2_v6,
                                             dst_mac_address=customer2_mac,
                                             no_host_route=True)

            customer2_v6_route = sai_thrift_route_entry_t(
                vr_id=ovrf2, destination=sai_ipprefix(customer2_ipv6 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          customer2_v6_route,
                                          next_hop_id=onhop2_v6)

            onhop3 = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(customer3_ip),
                                                router_interface_id=orif3,
                                                type=SAI_NEXT_HOP_TYPE_IP)

            onbor3 = sai_thrift_neighbor_entry_t(
                rif_id=orif3, ip_address=sai_ipaddress(customer3_ip))
            sai_thrift_create_neighbor_entry(self.client,
                                             onbor3,
                                             dst_mac_address=customer3_mac,
                                             no_host_route=True)

            customer3_route = sai_thrift_route_entry_t(
                vr_id=ovrf3, destination=sai_ipprefix(customer3_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          customer3_route,
                                          next_hop_id=onhop3)

            onhop3_v6 = sai_thrift_create_next_hop(
                self.client,
                ip=sai_ipaddress(customer3_ipv6),
                router_interface_id=orif3,
                type=SAI_NEXT_HOP_TYPE_IP)

            onbor3_v6 = sai_thrift_neighbor_entry_t(
                rif_id=orif3, ip_address=sai_ipaddress(customer3_ipv6))
            sai_thrift_create_neighbor_entry(self.client,
                                             onbor3_v6,
                                             dst_mac_address=customer3_mac,
                                             no_host_route=True)

            customer3_v6_route = sai_thrift_route_entry_t(
                vr_id=ovrf3, destination=sai_ipprefix(customer3_ipv6 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          customer3_v6_route,
                                          next_hop_id=onhop3_v6)

            pkt_data = [{
                'oport': self.oport_dev,
                'uport': self.uport1_dev,
                'ip': self.customer_ip,
                'ipv6': self.customer_ipv6,
                'mac': self.customer_mac,
                'umac': self.unbor_mac1,
                'tun_ip': self.tun_ip1,
                'lpb_ip': self.lpb_ip1,
                'vni': self.vni
            }, {
                'oport': oport2_dev,
                'uport': self.uport2_dev,
                'ip': customer2_ip,
                'ipv6': customer2_ipv6,
                'mac': customer2_mac,
                'umac': self.unbor_mac2,
                'tun_ip': self.tun_ip2,
                'lpb_ip': self.lpb_ip2,
                'vni': vni2
            }]

            self._vxLanP2MpMultipleIpv4OvrfTunnelTest(pkt_data)
            self._vxLanP2MpMultipleIpv6OvrfTunnelTest(pkt_data)

            print("Adding mapper entry")
            encap_tunnel_map_entry3 = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=self.encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
                virtual_router_id_key=ovrf3,
                vni_id_value=vni3)

            decap_tunnel_map_entry3 = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=self.encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
                virtual_router_id_key=ovrf3,
                vni_id_value=vni3)

            pkt_data.append({
                'oport': oport3_dev,
                'uport': self.uport3_dev,
                'ip': customer3_ip,
                'ipv6': customer3_ipv6,
                'mac': customer3_mac,
                'umac': self.unbor_mac3,
                'tun_ip': self.tun_ip3,
                'lpb_ip': self.lpb_ip3,
                'vni': vni3
            })

            self._vxLanP2MpMultipleIpv4OvrfTunnelTest(pkt_data)
            self._vxLanP2MpMultipleIpv6OvrfTunnelTest(pkt_data)

            print("Removing mapper entry")
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               decap_tunnel_map_entry3)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               encap_tunnel_map_entry3)

            self._vxLanP2MpMultipleIpv4OvrfTunnelTest(pkt_data[:2])
            self._vxLanP2MpMultipleIpv6OvrfTunnelTest(pkt_data[:2])
            self._noMapperEntryMultipleOvrfTunnelTest(pkt_data[2])

        finally:
            sai_thrift_remove_route_entry(self.client, customer3_v6_route)
            sai_thrift_remove_neighbor_entry(self.client, onbor3_v6)
            sai_thrift_remove_next_hop(self.client, onhop3_v6)
            sai_thrift_remove_route_entry(self.client, customer3_route)
            sai_thrift_remove_neighbor_entry(self.client, onbor3)
            sai_thrift_remove_next_hop(self.client, onhop3)
            sai_thrift_remove_route_entry(self.client, customer2_v6_route)
            sai_thrift_remove_neighbor_entry(self.client, onbor2_v6)
            sai_thrift_remove_next_hop(self.client, onhop2_v6)
            sai_thrift_remove_route_entry(self.client, customer2_route)
            sai_thrift_remove_neighbor_entry(self.client, onbor2)
            sai_thrift_remove_next_hop(self.client, onhop2)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               decap_tunnel_map_entry2)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               encap_tunnel_map_entry2)
            sai_thrift_remove_router_interface(self.client, orif3)
            sai_thrift_remove_router_interface(self.client, orif2)
            sai_thrift_remove_virtual_router(self.client, ovrf3)
            sai_thrift_remove_virtual_router(self.client, ovrf2)

    def _vxLanP2MpMultipleIpv4OvrfTunnelTest(self, pkt_data):
        '''
        A helper function for IPv4 case of overlay VRF

        Args:
            pkt_data (dict): a dictionary with data necessary for packet
                             verification; necessary keys are:
                             oport - overlay port number
                             uport - underlay port number
                             ip - customer IPv4 address
                             mac - customer MAC address
                             umac - underlay neighbor MAC address
                             tun_ip - tunnel IP
                             lpb_ip - loopback IP
                             vni - tunnel VNI
        '''

        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=self.customer_mac,
                                ip_dst=self.vm_ip,
                                ip_src=self.customer_ip,
                                ip_id=108,
                                ip_ttl=64)
        inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.vm_ip,
                                      ip_src=self.customer_ip,
                                      ip_id=108,
                                      ip_ttl=63)
        if self.ipv6 is False:
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor_mac1,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun_ip1,
                                    ip_src=self.lpb_ip1,
                                    ip_id=0,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni,
                                    inner_frame=inner_pkt))
        else:
            vxlan_pkt = Mask(
                simple_vxlanv6_packet(eth_dst=self.unbor_mac1,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=self.tun_ip1,
                                      ipv6_src=self.lpb_ip1,
                                      ipv6_hlim=64,
                                      with_udp_chksum=False,
                                      vxlan_vni=self.vni,
                                      inner_frame=inner_pkt))
        vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

        print("Verifying VxLAN (4 in %d) encapsulation"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.oport_dev, pkt)
        verify_packet(self, vxlan_pkt, self.uport1_dev)
        print("\tOK")

        print("Verifying VxLAN (4 in %d) decapsulation"
              % (6 if self.ipv6 else 4))
        for data in pkt_data:
            pkt = simple_udp_packet(eth_dst=data['mac'],
                                    eth_src=ROUTER_MAC,
                                    ip_dst=data['ip'],
                                    ip_src=self.vm_ip,
                                    ip_id=108,
                                    ip_ttl=63)
            inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                          eth_src=self.inner_dmac,
                                          ip_dst=data['ip'],
                                          ip_src=self.vm_ip,
                                          ip_id=108,
                                          ip_ttl=64)
            if self.ipv6 is False:
                vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                                eth_src=data['umac'],
                                                ip_dst=data['lpb_ip'],
                                                ip_src=data['tun_ip'],
                                                ip_id=0,
                                                ip_ttl=64,
                                                ip_flags=0x2,
                                                udp_sport=11638,
                                                with_udp_chksum=False,
                                                vxlan_vni=data['vni'],
                                                inner_frame=inner_pkt)
            else:
                vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                                  eth_src=data['umac'],
                                                  ipv6_dst=data['lpb_ip'],
                                                  ipv6_src=data['tun_ip'],
                                                  ipv6_hlim=64,
                                                  udp_sport=11638,
                                                  with_udp_chksum=False,
                                                  vxlan_vni=data['vni'],
                                                  inner_frame=inner_pkt)

            print("- Sending packet from VNI %d -> port %d" %
                  (data['vni'], data['oport']))
            send_packet(self, data['uport'], vxlan_pkt)
            verify_packet(self, pkt, data['oport'])
            print("\tOK")

    def _vxLanP2MpMultipleIpv6OvrfTunnelTest(self, pkt_data):
        '''
        A helper function for IPv6 case of overlay VRF

        Args:
            pkt_data (dict): a dictionary with data necessary for packet
                             verification; necessary keys are:
                             oport - overlay port number
                             uport - underlay port number
                             ipv6 - customer IPv6 address
                             mac - customer MAC address
                             umac - underlay neighbor MAC address
                             tun_ip - tunnel IP
                             lpb_ip - loopback IP
                             vni - tunnel VNI
        '''

        pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                  eth_src=self.customer_mac,
                                  ipv6_dst=self.vm_ipv6,
                                  ipv6_src=self.customer_ipv6,
                                  ipv6_hlim=64)
        inner_pkt = simple_udpv6_packet(eth_dst=self.inner_dmac,
                                        eth_src=ROUTER_MAC,
                                        ipv6_dst=self.vm_ipv6,
                                        ipv6_src=self.customer_ipv6,
                                        ipv6_hlim=63)
        if self.ipv6 is False:
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor_mac1,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun_ip1,
                                    ip_src=self.lpb_ip1,
                                    ip_id=0,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni,
                                    inner_frame=inner_pkt))
        else:
            vxlan_pkt = Mask(
                simple_vxlanv6_packet(eth_dst=self.unbor_mac1,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=self.tun_ip1,
                                      ipv6_src=self.lpb_ip1,
                                      ipv6_hlim=64,
                                      with_udp_chksum=False,
                                      vxlan_vni=self.vni,
                                      inner_frame=inner_pkt))
        vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

        print("Verifying VxLAN (6 in %d) encapsulation"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.oport_dev, pkt)
        verify_packet(self, vxlan_pkt, self.uport1_dev)
        print("\tOK")

        print("Verifying VxLAN (6 in %d) decapsulation"
              % (6 if self.ipv6 else 4))
        for data in pkt_data:
            pkt = simple_udpv6_packet(eth_dst=data['mac'],
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=data['ipv6'],
                                      ipv6_src=self.vm_ipv6,
                                      ipv6_hlim=63)
            inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.inner_dmac,
                                            ipv6_dst=data['ipv6'],
                                            ipv6_src=self.vm_ipv6,
                                            ipv6_hlim=64)
            if self.ipv6 is False:
                vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                                eth_src=data['umac'],
                                                ip_dst=data['lpb_ip'],
                                                ip_src=data['tun_ip'],
                                                ip_id=0,
                                                ip_ttl=64,
                                                ip_flags=0x2,
                                                udp_sport=11638,
                                                with_udp_chksum=False,
                                                vxlan_vni=data['vni'],
                                                inner_frame=inner_pkt)
            else:
                vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                                  eth_src=data['umac'],
                                                  ipv6_dst=data['lpb_ip'],
                                                  ipv6_src=data['tun_ip'],
                                                  ipv6_hlim=64,
                                                  udp_sport=11638,
                                                  with_udp_chksum=False,
                                                  vxlan_vni=data['vni'],
                                                  inner_frame=inner_pkt)

            print("- Sending packet from VNI %d -> port %d" %
                  (data['vni'], data['oport']))
            send_packet(self, data['uport'], vxlan_pkt)
            verify_packet(self, pkt, data['oport'])
            print("\tOK")

    def _noMapperEntryMultipleOvrfTunnelTest(self, pkt_data):
        '''
        A helper function drop verification when no mapper entries exists

        Args:
            pkt_data (dict): a dictionary with data necessary for packet
                             verification; necessary keys are:
                             oport - overlay port number
                             uport - underlay port number
                             ip - customer IPv4 address
                             umac - underlay neighbor MAC address
                             tun_ip - tunnel IP
                             lpb_ip - loopback IP
                             vni - tunnel VNI
        '''

        inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.inner_dmac,
                                      ip_dst=pkt_data['ip'],
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=64)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=pkt_data['umac'],
                                            ip_dst=pkt_data['lpb_ip'],
                                            ip_src=pkt_data['tun_ip'],
                                            ip_id=0,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            udp_sport=11638,
                                            with_udp_chksum=False,
                                            vxlan_vni=pkt_data['vni'],
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=pkt_data['umac'],
                                              ipv6_dst=pkt_data['lpb_ip'],
                                              ipv6_src=pkt_data['tun_ip'],
                                              ipv6_hlim=64,
                                              udp_sport=11638,
                                              with_udp_chksum=False,
                                              vxlan_vni=pkt_data['vni'],
                                              inner_frame=inner_pkt)

        print("Verifying decapsulation without mapper entry")
        print("Sending packet from VNI %d -> port %d" %
              (pkt_data['vni'], pkt_data['oport']))
        send_packet(self, pkt_data['uport'], vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")


@group("draft")
class VxLanP2MpTnnnelIpv4UnderlayTest(VxLanP2MpTnnnelBase):
    '''
    Base VxLAN tunnel point to multipoint tests with IPv4 underlay layer
    '''

    def runTest(self):
        self.vxLanP2MpSingleIpv4OvrfTunnelTest()
        self.vxLanP2MpSingleIpv6OvrfTunnelTest()
        self.vxLanP2MpMultipleOvrfTunnelTest()


@group("draft")
class VxLanP2MpTnnnelIpv6UnderlayTest(VxLanP2MpTnnnelBase):
    '''
    Base VxLAN tunnel point to multipoint tests with IPv6 underlay layer
    '''

    def __init__(self):
        super(VxLanP2MpTnnnelIpv6UnderlayTest, self).__init__(ipv6=True)

    def runTest(self):
        self.vxLanP2MpSingleIpv4OvrfTunnelTest()
        self.vxLanP2MpSingleIpv6OvrfTunnelTest()
        self.vxLanP2MpMultipleOvrfTunnelTest()


# # # # # # # # # IP in IP point to multipoint tests follow # # # # # # # # #
@group("draft")
class IpInIpP2MpTunnelBase(SaiHelper):
    '''
    Base setup for IP in IP tunnel point to multipoint tests

    Args:
        ipv6 (bool): ipv6 underlay configuraton indicator
    '''

    def __init__(self, ipv6=False):
        super(IpInIpP2MpTunnelBase, self).__init__()
        self.ipv6 = ipv6

        if ipv6 is True:
            self.tun_ip1 = "2001:0db8::10:1"
            self.tun_ip2 = "2001:0db8::20:1"
            self.tun_ip3 = "2001:0db8::30:1"
            self.lpb_ip1 = "2001:0db8::10:10"
            self.lpb_ip2 = "2001:0db8::20:10"
            self.lpb_ip3 = "2001:0db8::30:10"
            self.tun_ip_mask = "/128"
        else:
            self.tun_ip1 = "10.10.10.1"
            self.tun_ip2 = "20.20.20.1"
            self.tun_ip3 = "30.30.30.1"
            self.lpb_ip1 = "10.10.10.10"
            self.lpb_ip2 = "20.20.20.10"
            self.lpb_ip3 = "30.30.30.10"
            self.tun_ip_mask = "/32"

    def setUp(self):
        super(IpInIpP2MpTunnelBase, self).setUp()

        self.oport = self.port24
        self.oport_dev = self.dev_port24
        self.uport1 = self.port25
        self.uport1_dev = self.dev_port25
        self.uport2 = self.port26
        self.uport2_dev = self.dev_port26
        self.uport3 = self.port27
        self.uport3_dev = self.dev_port27

        self.vm_ip = "100.100.1.1"
        self.vm_ipv6 = "2001:0db8::100:1"
        self.customer_ip = "100.100.2.1"
        self.customer_ipv6 = "2001:0db8::100:2"
        self.inner_dmac = "00:11:11:11:11:11"
        self.customer_mac = "00:22:22:22:22:11"
        self.unbor_mac1 = "00:33:33:33:33:11"
        self.unbor_mac2 = "00:33:33:33:33:22"
        self.unbor_mac3 = "00:33:33:33:33:33"

        # underlay configuration
        self.uvrf1 = sai_thrift_create_virtual_router(self.client)
        self.uvrf2 = sai_thrift_create_virtual_router(self.client)
        self.uvrf3 = sai_thrift_create_virtual_router(self.client)

        # overlay configuration
        self.ovrf = sai_thrift_create_virtual_router(self.client)
        tunnel_type = SAI_TUNNEL_TYPE_IPINIP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2MP
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL

        # loopback RIFs for tunnel
        self.urif_lpb = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_LOOPBACK,
            virtual_router_id=self.uvrf1)

        self.orif_lpb = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_LOOPBACK,
            virtual_router_id=self.ovrf)

        # routes to tunnel from underlay RIFs
        self.urif1 = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.uvrf1,
            port_id=self.uport1)

        self.unhop1 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.tun_ip1),
            router_interface_id=self.urif1,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.unbor1 = sai_thrift_neighbor_entry_t(
            rif_id=self.urif1, ip_address=sai_ipaddress(self.tun_ip1))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.unbor1,
                                         dst_mac_address=self.unbor_mac1,
                                         no_host_route=True)

        self.tunnel_route1 = sai_thrift_route_entry_t(
            vr_id=self.uvrf1,
            destination=sai_ipprefix(self.tun_ip1 + self.tun_ip_mask))
        sai_thrift_create_route_entry(self.client,
                                      self.tunnel_route1,
                                      next_hop_id=self.unhop1)

        self.urif2 = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.uvrf2,
            port_id=self.uport2)

        self.unhop2 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.tun_ip2),
            router_interface_id=self.urif2,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.unbor2 = sai_thrift_neighbor_entry_t(
            rif_id=self.urif2, ip_address=sai_ipaddress(self.tun_ip2))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.unbor2,
                                         dst_mac_address=self.unbor_mac2,
                                         no_host_route=True)

        self.tunnel_route2 = sai_thrift_route_entry_t(
            vr_id=self.uvrf2,
            destination=sai_ipprefix(self.tun_ip2 + self.tun_ip_mask))
        sai_thrift_create_route_entry(self.client,
                                      self.tunnel_route2,
                                      next_hop_id=self.unhop2)

        self.urif3 = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.uvrf3,
            port_id=self.uport3)

        self.unhop3 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.tun_ip3),
            router_interface_id=self.urif3,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.unbor3 = sai_thrift_neighbor_entry_t(
            rif_id=self.urif1, ip_address=sai_ipaddress(self.tun_ip3))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.unbor3,
                                         dst_mac_address=self.unbor_mac3,
                                         no_host_route=True)

        self.tunnel_route3 = sai_thrift_route_entry_t(
            vr_id=self.uvrf3,
            destination=sai_ipprefix(self.tun_ip3 + self.tun_ip_mask))
        sai_thrift_create_route_entry(self.client,
                                      self.tunnel_route3,
                                      next_hop_id=self.unhop3)

        # tunnel
        self.tunnel = sai_thrift_create_tunnel(
            self.client,
            type=tunnel_type,
            encap_src_ip=sai_ipaddress(self.lpb_ip1),
            encap_ttl_mode=ttl_mode,
            decap_ttl_mode=ttl_mode,
            underlay_interface=self.urif_lpb,
            overlay_interface=self.orif_lpb)

        # tunnel termination entries
        self.tunnel_term1 = sai_thrift_create_tunnel_term_table_entry(
            self.client,
            tunnel_type=tunnel_type,
            vr_id=self.uvrf1,
            action_tunnel_id=self.tunnel,
            type=term_type,
            dst_ip=sai_ipaddress(self.lpb_ip1),
            src_ip=sai_ipaddress(self.tun_ip1))

        self.tunnel_term2 = sai_thrift_create_tunnel_term_table_entry(
            self.client,
            tunnel_type=tunnel_type,
            vr_id=self.uvrf2,
            action_tunnel_id=self.tunnel,
            type=term_type,
            dst_ip=sai_ipaddress(self.lpb_ip2),
            src_ip=sai_ipaddress(self.tun_ip2))

        self.tunnel_term3 = sai_thrift_create_tunnel_term_table_entry(
            self.client,
            tunnel_type=tunnel_type,
            vr_id=self.uvrf3,
            action_tunnel_id=self.tunnel,
            type=term_type,
            dst_ip=sai_ipaddress(self.lpb_ip3),
            src_ip=sai_ipaddress(self.tun_ip3))

        # tunnel nexthop for VM
        self.tunnel_nhop = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
            tunnel_id=self.tunnel,
            ip=sai_ipaddress(self.tun_ip1),
            tunnel_mac=self.inner_dmac)

        # routes to VM via tunnel nexthop
        self.vm_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.vm_route,
                                      next_hop_id=self.tunnel_nhop)

        self.vm_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf, destination=sai_ipprefix(self.vm_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.vm_v6_route,
                                      next_hop_id=self.tunnel_nhop)

        # routes to customer from VM
        self.orif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.ovrf,
            port_id=self.oport)

        self.onhop = sai_thrift_create_next_hop(
            self.client, ip=sai_ipaddress(self.customer_ip),
            router_interface_id=self.orif, type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor = sai_thrift_neighbor_entry_t(
            rif_id=self.orif, ip_address=sai_ipaddress(self.customer_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor,
                                         dst_mac_address=self.customer_mac,
                                         no_host_route=True)

        self.customer_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(self.customer_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer_route,
                                      next_hop_id=self.onhop)

        self.onhop_v6 = sai_thrift_create_next_hop(
            self.client, ip=sai_ipaddress(self.customer_ipv6),
            router_interface_id=self.orif, type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif, ip_address=sai_ipaddress(self.customer_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor_v6,
                                         dst_mac_address=self.customer_mac,
                                         no_host_route=True)

        self.customer_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(self.customer_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer_v6_route,
                                      next_hop_id=self.onhop_v6)

    def tearDown(self):
        sai_thrift_remove_route_entry(self.client, self.customer_v6_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor_v6)
        sai_thrift_remove_next_hop(self.client, self.onhop_v6)
        sai_thrift_remove_route_entry(self.client, self.customer_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor)
        sai_thrift_remove_next_hop(self.client, self.onhop)
        sai_thrift_remove_router_interface(self.client, self.orif)
        sai_thrift_remove_route_entry(self.client, self.vm_v6_route)
        sai_thrift_remove_route_entry(self.client, self.vm_route)
        sai_thrift_remove_next_hop(self.client, self.tunnel_nhop)
        sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                  self.tunnel_term3)
        sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                  self.tunnel_term2)
        sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                  self.tunnel_term1)
        sai_thrift_remove_tunnel(self.client, self.tunnel)
        sai_thrift_remove_route_entry(self.client, self.tunnel_route3)
        sai_thrift_remove_neighbor_entry(self.client, self.unbor3)
        sai_thrift_remove_next_hop(self.client, self.unhop3)
        sai_thrift_remove_router_interface(self.client, self.urif3)
        sai_thrift_remove_route_entry(self.client, self.tunnel_route2)
        sai_thrift_remove_neighbor_entry(self.client, self.unbor2)
        sai_thrift_remove_next_hop(self.client, self.unhop2)
        sai_thrift_remove_router_interface(self.client, self.urif2)
        sai_thrift_remove_route_entry(self.client, self.tunnel_route1)
        sai_thrift_remove_neighbor_entry(self.client, self.unbor1)
        sai_thrift_remove_next_hop(self.client, self.unhop1)
        sai_thrift_remove_router_interface(self.client, self.urif1)
        sai_thrift_remove_router_interface(self.client, self.orif_lpb)
        sai_thrift_remove_router_interface(self.client, self.urif_lpb)
        sai_thrift_remove_virtual_router(self.client, self.ovrf)
        sai_thrift_remove_virtual_router(self.client, self.uvrf3)
        sai_thrift_remove_virtual_router(self.client, self.uvrf2)
        sai_thrift_remove_virtual_router(self.client, self.uvrf1)

        super(IpInIpP2MpTunnelBase, self).tearDown()

    def innerIpv4P2MpTunnelTest(self):
        '''
        IP in IP point to multipoint tunnel test with IPv4 inner packet
        '''
        print("\ninnerIpv4P2MpTunnelTest()")

        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=self.customer_mac,
                                ip_dst=self.vm_ip,
                                ip_src=self.customer_ip,
                                ip_id=108,
                                ip_ttl=64)
        inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.vm_ip,
                                      ip_src=self.customer_ip,
                                      ip_id=108,
                                      ip_ttl=63)
        if self.ipv6 is False:
            ipip_pkt = simple_ipv4ip_packet(eth_dst=self.unbor_mac1,
                                            eth_src=ROUTER_MAC,
                                            ip_dst=self.tun_ip1,
                                            ip_src=self.lpb_ip1,
                                            ip_id=0,
                                            inner_frame=inner_pkt['IP'])
        else:
            ipip_pkt = simple_ipv6ip_packet(eth_dst=self.unbor_mac1,
                                            eth_src=ROUTER_MAC,
                                            ipv6_dst=self.tun_ip1,
                                            ipv6_src=self.lpb_ip1,
                                            inner_frame=inner_pkt['IP'])

        print("Verifying IP in IP (4 in %d) encapsulation"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.oport_dev, pkt)
        verify_packet(self, ipip_pkt, self.uport1_dev)
        print("\tOK")

        pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                eth_src=ROUTER_MAC,
                                ip_dst=self.customer_ip,
                                ip_src=self.vm_ip,
                                ip_id=108,
                                ip_ttl=63)
        inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.inner_dmac,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=64)
        if self.ipv6 is False:
            ipip_pkt = simple_ipv4ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac1,
                                            ip_dst=self.lpb_ip1,
                                            ip_src=self.tun_ip1,
                                            ip_id=0,
                                            inner_frame=inner_pkt['IP'])
        else:
            ipip_pkt = simple_ipv6ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac1,
                                            ipv6_dst=self.lpb_ip1,
                                            ipv6_src=self.tun_ip1,
                                            inner_frame=inner_pkt['IP'])

        print("Verifying IPinIP (4 in %d) decapsulation (term 1)"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.uport1_dev, ipip_pkt)
        verify_packet(self, pkt, self.oport_dev)
        print("\tOK")

        pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                eth_src=ROUTER_MAC,
                                ip_dst=self.customer_ip,
                                ip_src=self.vm_ip,
                                ip_id=108,
                                ip_ttl=63)
        inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.inner_dmac,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=64)
        if self.ipv6 is False:
            ipip_pkt = simple_ipv4ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac2,
                                            ip_dst=self.lpb_ip2,
                                            ip_src=self.tun_ip2,
                                            ip_id=0,
                                            inner_frame=inner_pkt['IP'])
        else:
            ipip_pkt = simple_ipv6ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac2,
                                            ipv6_dst=self.lpb_ip2,
                                            ipv6_src=self.tun_ip2,
                                            inner_frame=inner_pkt['IP'])

        print("Verifying IPinIP (4 in %d) decapsulation (term 2)"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.uport2_dev, ipip_pkt)
        verify_packet(self, pkt, self.oport_dev)
        print("\tOK")

        pkt = simple_udp_packet(eth_dst=self.customer_mac,
                                eth_src=ROUTER_MAC,
                                ip_dst=self.customer_ip,
                                ip_src=self.vm_ip,
                                ip_id=108,
                                ip_ttl=63)
        inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.inner_dmac,
                                      ip_dst=self.customer_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=64)
        if self.ipv6 is False:
            ipip_pkt = simple_ipv4ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac3,
                                            ip_dst=self.lpb_ip3,
                                            ip_src=self.tun_ip3,
                                            ip_id=0,
                                            inner_frame=inner_pkt['IP'])
        else:
            ipip_pkt = simple_ipv6ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac3,
                                            ipv6_dst=self.lpb_ip3,
                                            ipv6_src=self.tun_ip3,
                                            inner_frame=inner_pkt['IP'])

        print("Verifying IPinIP (4 in %d) decapsulation (term 3)"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.uport3_dev, ipip_pkt)
        verify_packet(self, pkt, self.oport_dev)
        print("\tOK")

    def innerIpv6P2MpTunnelTest(self):
        '''
        IP in IP point to multipoint tunnel test with IPv6 inner packet
        '''
        print("\ninnerIpv6P2MpTunnelTest()")

        pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                  eth_src=self.customer_mac,
                                  ipv6_dst=self.vm_ipv6,
                                  ipv6_src=self.customer_ipv6,
                                  ipv6_hlim=64)
        inner_pkt = simple_udpv6_packet(eth_dst=self.inner_dmac,
                                        eth_src=ROUTER_MAC,
                                        ipv6_dst=self.vm_ipv6,
                                        ipv6_src=self.customer_ipv6,
                                        ipv6_hlim=63)
        if self.ipv6 is False:
            ipip_pkt = simple_ipv4ip_packet(eth_dst=self.unbor_mac1,
                                            eth_src=ROUTER_MAC,
                                            ip_dst=self.tun_ip1,
                                            ip_src=self.lpb_ip1,
                                            ip_id=0,
                                            inner_frame=inner_pkt['IPv6'])
        else:
            ipip_pkt = simple_ipv6ip_packet(eth_dst=self.unbor_mac1,
                                            eth_src=ROUTER_MAC,
                                            ipv6_dst=self.tun_ip1,
                                            ipv6_src=self.lpb_ip1,
                                            inner_frame=inner_pkt['IPv6'])

        print("Verifying IPinIP (6 in %d) encapsulation"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.oport_dev, pkt)
        verify_packet(self, ipip_pkt, self.uport1_dev)
        print("\tOK")

        pkt = simple_udpv6_packet(eth_dst=self.customer_mac,
                                  eth_src=ROUTER_MAC,
                                  ipv6_dst=self.customer_ipv6,
                                  ipv6_src=self.vm_ipv6,
                                  ipv6_hlim=63)
        inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.inner_dmac,
                                        ipv6_dst=self.customer_ipv6,
                                        ipv6_src=self.vm_ipv6,
                                        ipv6_hlim=64)
        if self.ipv6 is False:
            ipip_pkt = simple_ipv4ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac1,
                                            ip_dst=self.lpb_ip1,
                                            ip_src=self.tun_ip1,
                                            ip_id=0,
                                            inner_frame=inner_pkt['IPv6'])
        else:
            ipip_pkt = simple_ipv6ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac1,
                                            ipv6_dst=self.lpb_ip1,
                                            ipv6_src=self.tun_ip1,
                                            inner_frame=inner_pkt['IPv6'])

        print("Verifying IPinIP (6 in %d) decapsulation (term 1)"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.uport1_dev, ipip_pkt)
        verify_packet(self, pkt, self.oport_dev)
        print("\tOK")

        pkt = simple_udpv6_packet(eth_dst=self.customer_mac,
                                  eth_src=ROUTER_MAC,
                                  ipv6_dst=self.customer_ipv6,
                                  ipv6_src=self.vm_ipv6,
                                  ipv6_hlim=63)
        inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.inner_dmac,
                                        ipv6_dst=self.customer_ipv6,
                                        ipv6_src=self.vm_ipv6,
                                        ipv6_hlim=64)
        if self.ipv6 is False:
            ipip_pkt = simple_ipv4ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac2,
                                            ip_dst=self.lpb_ip2,
                                            ip_src=self.tun_ip2,
                                            ip_id=0,
                                            inner_frame=inner_pkt['IPv6'])
        else:
            ipip_pkt = simple_ipv6ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac2,
                                            ipv6_dst=self.lpb_ip2,
                                            ipv6_src=self.tun_ip2,
                                            inner_frame=inner_pkt['IPv6'])

        print("Verifying IPinIP (6 in %d) decapsulation (term 2)"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.uport2_dev, ipip_pkt)
        verify_packet(self, pkt, self.oport_dev)
        print("\tOK")

        pkt = simple_udpv6_packet(eth_dst=self.customer_mac,
                                  eth_src=ROUTER_MAC,
                                  ipv6_dst=self.customer_ipv6,
                                  ipv6_src=self.vm_ipv6,
                                  ipv6_hlim=63)
        inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.inner_dmac,
                                        ipv6_dst=self.customer_ipv6,
                                        ipv6_src=self.vm_ipv6,
                                        ipv6_hlim=64)
        if self.ipv6 is False:
            ipip_pkt = simple_ipv4ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac3,
                                            ip_dst=self.lpb_ip3,
                                            ip_src=self.tun_ip3,
                                            ip_id=0,
                                            inner_frame=inner_pkt['IPv6'])
        else:
            ipip_pkt = simple_ipv6ip_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.unbor_mac3,
                                            ipv6_dst=self.lpb_ip3,
                                            ipv6_src=self.tun_ip3,
                                            inner_frame=inner_pkt['IPv6'])

        print("Verifying IPinIP (6 in %d) decapsulation (term 3)"
              % (6 if self.ipv6 else 4))
        send_packet(self, self.uport3_dev, ipip_pkt)
        verify_packet(self, pkt, self.oport_dev)
        print("\tOK")


@group("draft")
class IpInIpP2MpTnnnelIpv4UnderlayTest(IpInIpP2MpTunnelBase):
    '''
    Base IP in IP tunnel point to multipoint tests with IPv4 underlay layer
    '''

    def runTest(self):
        self.innerIpv4P2MpTunnelTest()
        self.innerIpv6P2MpTunnelTest()


@group("draft")
class IpInIpP2MpTnnnelIpv6UnderlayTest(IpInIpP2MpTunnelBase):
    '''
    Base Ip in IP tunnel point to multipoint tests with IPv6 underlay layer
    '''

    def __init__(self):
        super(IpInIpP2MpTnnnelIpv6UnderlayTest, self).__init__(ipv6=True)

    def runTest(self):
        self.innerIpv4P2MpTunnelTest()
        self.innerIpv6P2MpTunnelTest()


# # # # # # # # # VxLAN multiple mapper entries tests follow # # # # # # # # #
@group("draft")
class MultipleMapperEntriesBase(SaiHelper):
    '''
    Base setup for tests verifying encap/decap on different overlay
    VRFs + RIFs configurations (multiple mapper entries)

    Args:
        ipv6 (bool): ipv6 underlay configuraton indicator
    '''

    def __init__(self, ipv6=False):
        super(MultipleMapperEntriesBase, self).__init__()
        self.ipv6 = ipv6

        if ipv6 is True:
            self.tun_ip = "2001:0db8::10:1"
            self.lpb_ip = "2001:0db8::10:10"
            self.tun_lpb_mask = "/128"
        else:
            self.tun_ip = "10.10.10.1"
            self.lpb_ip = "10.10.10.10"
            self.tun_lpb_mask = "/32"

    def setUp(self):
        super(MultipleMapperEntriesBase, self).setUp()

        # for orif1
        self.oport1 = self.port24
        self.oport1_dev = self.dev_port24
        # for orif234
        self.oport234_vlan = self.vlan10
        self.oport234_bp0 = self.port0_bp
        self.oport234_bp1 = self.port1_bp
        self.oport234_lbp = self.lag1_bp
        self.oport2_dev = self.dev_port0
        self.oport3_dev = self.dev_port1
        self.oport4_dev = [self.dev_port4, self.dev_port5, self.dev_port6]
        self.oport234_vlan_no = 10
        # for orif5
        self.oport5 = self.port25
        self.oport5_dev = self.dev_port25
        self.orif5_vlan_no = 400
        # for orif6 and orif7
        self.oport67 = self.port26
        self.oport67_dev = self.dev_port26
        self.orif6_vlan_no = 500
        self.orif7_vlan_no = 600
        # for orif8
        self.oport8 = self.port27
        self.oport8_dev = self.dev_port27

        self.uport = self.port28
        self.uport_dev = self.dev_port28

        self.vni1 = 1000
        self.vni234 = 2340
        self.vni5 = 5000
        self.vni67 = 6700
        self.vni8 = 8000
        self.vm_ip = "100.100.0.1"
        self.vm_ipv6 = "2001:0db8::0:1"
        self.customer1_ip = "100.100.1.1"
        self.customer1_ipv6 = "2001:0db8::1:1"
        self.customer1_mac = '00:22:22:22:22:11'
        self.customer2_ip = "100.100.2.1"
        self.customer2_ipv6 = "2001:0db8::2:1"
        self.customer2_mac = '00:22:22:22:22:22'
        self.customer3_ip = "100.100.3.1"
        self.customer3_ipv6 = "2001:0db8::3:1"
        self.customer3_mac = '00:22:22:22:22:33'
        self.customer4_ip = "100.100.4.1"
        self.customer4_ipv6 = "2001:0db8::4:1"
        self.customer4_mac = '00:22:22:22:22:44'
        self.customer5_ip = "100.100.5.1"
        self.customer5_ipv6 = "2001:0db8::5:1"
        self.customer5_mac = '00:22:22:22:22:55'
        self.customer6_ip = "100.100.6.1"
        self.customer6_ipv6 = "2001:0db8::6:1"
        self.customer6_mac = '00:22:22:22:22:66'
        self.customer7_ip = "100.100.7.1"
        self.customer7_ipv6 = "2001:0db8::7:1"
        self.customer7_mac = '00:22:22:22:22:77'
        self.customer8_ip = "100.100.8.1"
        self.customer8_ipv6 = "2001:0db8::8:1"
        self.customer8_mac = '00:22:22:22:22:88'
        self.inner_dmac = "00:11:11:11:11:11"
        self.unbor_mac = "00:33:33:33:33:33"

        self.uvrf = sai_thrift_create_virtual_router(self.client)

        self.urif_lpb = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_LOOPBACK,
            virtual_router_id=self.uvrf)

        # overlay configuraion
        self.ovrf1 = sai_thrift_create_virtual_router(self.client)
        self.ovrf234 = sai_thrift_create_virtual_router(self.client)
        self.ovrf5 = sai_thrift_create_virtual_router(self.client)
        self.ovrf67 = sai_thrift_create_virtual_router(self.client)
        self.ovrf8 = sai_thrift_create_virtual_router(self.client)

        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2MP
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL

        self.orif1 = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.ovrf1,
            port_id=self.oport1)

        self.orif234 = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_VLAN,
            virtual_router_id=self.ovrf234,
            vlan_id=self.oport234_vlan)

        self.orif5 = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT,
            virtual_router_id=self.ovrf5,
            port_id=self.oport5,
            outer_vlan_id=self.orif5_vlan_no)

        self.orif6 = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT,
            virtual_router_id=self.ovrf67,
            port_id=self.oport67,
            outer_vlan_id=self.orif6_vlan_no)

        self.orif7 = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT,
            virtual_router_id=self.ovrf67,
            port_id=self.oport67,
            outer_vlan_id=self.orif7_vlan_no)

        self.orif8 = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.ovrf8,
            port_id=self.oport8)

        # route to tunnel
        self.urif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.uvrf,
            port_id=self.uport)

        self.unhop = sai_thrift_create_next_hop(self.client,
                                                ip=sai_ipaddress(self.tun_ip),
                                                router_interface_id=self.urif,
                                                type=SAI_NEXT_HOP_TYPE_IP)

        self.unbor = sai_thrift_neighbor_entry_t(
            rif_id=self.urif, ip_address=sai_ipaddress(self.tun_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.unbor,
                                         dst_mac_address=self.unbor_mac,
                                         no_host_route=True)

        self.tunnel_route = sai_thrift_route_entry_t(
            vr_id=self.uvrf,
            destination=sai_ipprefix(self.tun_ip + self.tun_lpb_mask))
        sai_thrift_create_route_entry(self.client,
                                      self.tunnel_route,
                                      next_hop_id=self.unhop)

        # encap/decap mapper entries
        self.encap_tunnel_map = sai_thrift_create_tunnel_map(
            self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

        self.decap_tunnel_map = sai_thrift_create_tunnel_map(
            self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

        # encap/decap mapper entries
        for i, (vrf, vni) in enumerate(
                zip([self.ovrf1, self.ovrf234, self.ovrf5, self.ovrf67],
                    [self.vni1, self.vni234, self.vni5, self.vni67]),
                start=1):
            encap_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=self.encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
                virtual_router_id_key=vrf,
                vni_id_value=vni)
            setattr(self, 'encap_tunnel_map_entry%d' % i, encap_map_entry)

            decap_map_entry = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map=self.encap_tunnel_map,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
                virtual_router_id_value=vrf,
                vni_id_key=vni)
            setattr(self, 'decap_tunnel_map_entry%d' % i, decap_map_entry)

        encap_maps = sai_thrift_object_list_t(count=1,
                                              idlist=[self.encap_tunnel_map])
        decap_maps = sai_thrift_object_list_t(count=1,
                                              idlist=[self.decap_tunnel_map])

        # tunnel
        self.tunnel = sai_thrift_create_tunnel(
            self.client,
            type=tunnel_type,
            encap_src_ip=sai_ipaddress(self.lpb_ip),
            encap_mappers=encap_maps,
            decap_mappers=decap_maps,
            encap_ttl_mode=ttl_mode,
            decap_ttl_mode=ttl_mode,
            underlay_interface=self.urif_lpb)

        # tunnel termination entry
        self.tunnel_term = sai_thrift_create_tunnel_term_table_entry(
            self.client,
            tunnel_type=tunnel_type,
            vr_id=self.uvrf,
            action_tunnel_id=self.tunnel,
            type=term_type,
            src_ip=sai_ipaddress(self.tun_ip),
            dst_ip=sai_ipaddress(self.lpb_ip))

        # tunnel nexthop for VM
        self.tunnel_nhop = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
            tunnel_id=self.tunnel,
            ip=sai_ipaddress(self.tun_ip),
            tunnel_mac=self.inner_dmac)

        # routes to tunnel for all VRFs
        for i, vrf in enumerate([self.ovrf1, self.ovrf234, self.ovrf5,
                                 self.ovrf67, self.ovrf8], start=1):
            vm_route = sai_thrift_route_entry_t(
                vr_id=vrf, destination=sai_ipprefix(self.vm_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          vm_route,
                                          next_hop_id=self.tunnel_nhop)
            setattr(self, 'vm_route%d' % i, vm_route)

            vm_v6_route = sai_thrift_route_entry_t(
                vr_id=vrf, destination=sai_ipprefix(self.vm_ipv6 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          vm_v6_route,
                                          next_hop_id=self.tunnel_nhop)
            setattr(self, 'vm_v6_route%d' % i, vm_v6_route)

        # customer1 routes
        self.onhop1 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer1_ip),
            router_interface_id=self.orif1,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor1 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif1, ip_address=sai_ipaddress(self.customer1_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor1,
                                         dst_mac_address=self.customer1_mac,
                                         no_host_route=True)

        self.customer1_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf1,
            destination=sai_ipprefix(self.customer1_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer1_route,
                                      next_hop_id=self.onhop1)

        self.onhop1_v6 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer1_ipv6),
            router_interface_id=self.orif1,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor1_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif1, ip_address=sai_ipaddress(self.customer1_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor1_v6,
                                         dst_mac_address=self.customer1_mac,
                                         no_host_route=True)

        self.customer1_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf1,
            destination=sai_ipprefix(self.customer1_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer1_v6_route,
                                      next_hop_id=self.onhop1_v6)

        # customer2 routes
        self.onhop2 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer2_ip),
            router_interface_id=self.orif234,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor2 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif234, ip_address=sai_ipaddress(self.customer2_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor2,
                                         dst_mac_address=self.customer2_mac,
                                         no_host_route=True)

        self.customer2_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf234,
            destination=sai_ipprefix(self.customer2_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer2_route,
                                      next_hop_id=self.onhop2)

        self.onhop2_v6 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer2_ipv6),
            router_interface_id=self.orif234,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor2_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif234, ip_address=sai_ipaddress(self.customer2_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor2_v6,
                                         dst_mac_address=self.customer2_mac,
                                         no_host_route=True)

        self.customer2_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf234,
            destination=sai_ipprefix(self.customer2_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer2_v6_route,
                                      next_hop_id=self.onhop2_v6)

        self.c2_fdb_entry = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.customer2_mac,
            bv_id=self.oport234_vlan)
        status = sai_thrift_create_fdb_entry(self.client,
                                             self.c2_fdb_entry,
                                             type=SAI_FDB_ENTRY_TYPE_STATIC,
                                             bridge_port_id=self.oport234_bp0)
        self.assertEqual(status, SAI_STATUS_SUCCESS)

        # customer3 routes
        self.onhop3 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer3_ip),
            router_interface_id=self.orif234,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor3 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif234, ip_address=sai_ipaddress(self.customer3_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor3,
                                         dst_mac_address=self.customer3_mac,
                                         no_host_route=True)

        self.customer3_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf234,
            destination=sai_ipprefix(self.customer3_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer3_route,
                                      next_hop_id=self.onhop3)

        self.onhop3_v6 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer3_ipv6),
            router_interface_id=self.orif234,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor3_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif234, ip_address=sai_ipaddress(self.customer3_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor3_v6,
                                         dst_mac_address=self.customer3_mac,
                                         no_host_route=True)

        self.customer3_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf234,
            destination=sai_ipprefix(self.customer3_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer3_v6_route,
                                      next_hop_id=self.onhop3_v6)

        self.c3_fdb_entry = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.customer3_mac,
            bv_id=self.oport234_vlan)
        status = sai_thrift_create_fdb_entry(self.client,
                                             self.c3_fdb_entry,
                                             type=SAI_FDB_ENTRY_TYPE_STATIC,
                                             bridge_port_id=self.oport234_bp1)
        self.assertEqual(status, SAI_STATUS_SUCCESS)

        # customer4 routes
        self.onhop4 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer4_ip),
            router_interface_id=self.orif234,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor4 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif234, ip_address=sai_ipaddress(self.customer4_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor4,
                                         dst_mac_address=self.customer4_mac,
                                         no_host_route=True)

        self.customer4_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf234,
            destination=sai_ipprefix(self.customer4_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer4_route,
                                      next_hop_id=self.onhop4)

        self.onhop4_v6 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer4_ipv6),
            router_interface_id=self.orif234,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor4_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif234, ip_address=sai_ipaddress(self.customer4_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor4_v6,
                                         dst_mac_address=self.customer4_mac,
                                         no_host_route=True)

        self.customer4_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf234,
            destination=sai_ipprefix(self.customer4_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer4_v6_route,
                                      next_hop_id=self.onhop4_v6)

        self.c4_fdb_entry = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.customer4_mac,
            bv_id=self.oport234_vlan)
        status = sai_thrift_create_fdb_entry(self.client,
                                             self.c4_fdb_entry,
                                             type=SAI_FDB_ENTRY_TYPE_STATIC,
                                             bridge_port_id=self.oport234_lbp)
        self.assertEqual(status, SAI_STATUS_SUCCESS)

        # customer5 routes
        self.onhop5 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer5_ip),
            router_interface_id=self.orif5,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor5 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif5, ip_address=sai_ipaddress(self.customer5_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor5,
                                         dst_mac_address=self.customer5_mac,
                                         no_host_route=True)

        self.customer5_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf5,
            destination=sai_ipprefix(self.customer5_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer5_route,
                                      next_hop_id=self.onhop5)

        self.onhop5_v6 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer5_ipv6),
            router_interface_id=self.orif5,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor5_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif5, ip_address=sai_ipaddress(self.customer5_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor5_v6,
                                         dst_mac_address=self.customer5_mac,
                                         no_host_route=True)

        self.customer5_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf5,
            destination=sai_ipprefix(self.customer5_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer5_v6_route,
                                      next_hop_id=self.onhop5_v6)

        # customer6 routes
        self.onhop6 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer6_ip),
            router_interface_id=self.orif6,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor6 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif6, ip_address=sai_ipaddress(self.customer6_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor6,
                                         dst_mac_address=self.customer6_mac,
                                         no_host_route=True)

        self.customer6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf67,
            destination=sai_ipprefix(self.customer6_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer6_route,
                                      next_hop_id=self.onhop6)

        self.onhop6_v6 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer6_ipv6),
            router_interface_id=self.orif6,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor6_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif6, ip_address=sai_ipaddress(self.customer6_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor6_v6,
                                         dst_mac_address=self.customer6_mac,
                                         no_host_route=True)

        self.customer6_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf67,
            destination=sai_ipprefix(self.customer6_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer6_v6_route,
                                      next_hop_id=self.onhop6_v6)

        # customer7 routes
        self.onhop7 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer7_ip),
            router_interface_id=self.orif7,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor7 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif7, ip_address=sai_ipaddress(self.customer7_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor7,
                                         dst_mac_address=self.customer7_mac,
                                         no_host_route=True)

        self.customer7_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf67,
            destination=sai_ipprefix(self.customer7_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer7_route,
                                      next_hop_id=self.onhop7)

        self.onhop7_v6 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer7_ipv6),
            router_interface_id=self.orif7,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor7_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif7, ip_address=sai_ipaddress(self.customer7_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor7_v6,
                                         dst_mac_address=self.customer7_mac,
                                         no_host_route=True)

        self.customer7_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf67,
            destination=sai_ipprefix(self.customer7_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer7_v6_route,
                                      next_hop_id=self.onhop7_v6)

        # customer8 routes
        self.onhop8 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer8_ip),
            router_interface_id=self.orif8,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor8 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif8, ip_address=sai_ipaddress(self.customer8_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor8,
                                         dst_mac_address=self.customer8_mac,
                                         no_host_route=True)

        self.customer8_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf8,
            destination=sai_ipprefix(self.customer8_ip + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer8_route,
                                      next_hop_id=self.onhop8)

        self.onhop8_v6 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.customer8_ipv6),
            router_interface_id=self.orif8,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.onbor8_v6 = sai_thrift_neighbor_entry_t(
            rif_id=self.orif8, ip_address=sai_ipaddress(self.customer8_ipv6))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.onbor8_v6,
                                         dst_mac_address=self.customer8_mac,
                                         no_host_route=True)

        self.customer8_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf8,
            destination=sai_ipprefix(self.customer8_ipv6 + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      self.customer8_v6_route,
                                      next_hop_id=self.onhop8_v6)

        self.pkt_data = [
            {
                'port': self.oport1_dev,
                'ip': self.customer1_ip,
                'ipv6': self.customer1_ipv6,
                'mac': self.customer1_mac,
                'vlan': False,
                'vlan_no': 0,
                'vni': self.vni1
            },
            {
                'port': self.oport2_dev,
                'ip': self.customer2_ip,
                'ipv6': self.customer2_ipv6,
                'mac': self.customer2_mac,
                'vlan': False,
                'vlan_no': 0,
                'vni': self.vni234
            },
            {
                'port': self.oport3_dev,
                'ip': self.customer3_ip,
                'ipv6': self.customer3_ipv6,
                'mac': self.customer3_mac,
                'vlan': True,
                'vlan_no': self.oport234_vlan_no,
                'vni': self.vni234
            },
            {
                'port': self.oport4_dev,
                'ip': self.customer4_ip,
                'ipv6': self.customer4_ipv6,
                'mac': self.customer4_mac,
                'vlan': False,
                'vlan_no': 0,
                'vni': self.vni234
            },
            {
                'port': self.oport5_dev,
                'ip': self.customer5_ip,
                'ipv6': self.customer5_ipv6,
                'mac': self.customer5_mac,
                'vlan': True,
                'vlan_no': self.orif5_vlan_no,
                'vni': self.vni5
            },
            {
                'port': self.oport67_dev,
                'ip': self.customer6_ip,
                'ipv6': self.customer6_ipv6,
                'mac': self.customer6_mac,
                'vlan': True,
                'vlan_no': self.orif6_vlan_no,
                'vni': self.vni67
            },
            {
                'port': self.oport67_dev,
                'ip': self.customer7_ip,
                'ipv6': self.customer7_ipv6,
                'mac': self.customer7_mac,
                'vlan': True,
                'vlan_no': self.orif7_vlan_no,
                'vni': self.vni67
            }
        ]

    def tearDown(self):
        sai_thrift_flush_fdb_entries(self.client,
                                     entry_type=SAI_FDB_FLUSH_ENTRY_TYPE_ALL)
        sai_thrift_remove_route_entry(self.client, self.customer8_v6_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor8_v6)
        sai_thrift_remove_next_hop(self.client, self.onhop8_v6)
        sai_thrift_remove_route_entry(self.client, self.customer8_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor8)
        sai_thrift_remove_next_hop(self.client, self.onhop8)
        sai_thrift_remove_route_entry(self.client, self.customer7_v6_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor7_v6)
        sai_thrift_remove_next_hop(self.client, self.onhop7_v6)
        sai_thrift_remove_route_entry(self.client, self.customer7_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor7)
        sai_thrift_remove_next_hop(self.client, self.onhop7)
        sai_thrift_remove_route_entry(self.client, self.customer6_v6_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor6_v6)
        sai_thrift_remove_next_hop(self.client, self.onhop6_v6)
        sai_thrift_remove_route_entry(self.client, self.customer6_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor6)
        sai_thrift_remove_next_hop(self.client, self.onhop6)
        sai_thrift_remove_route_entry(self.client, self.customer5_v6_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor5_v6)
        sai_thrift_remove_next_hop(self.client, self.onhop5_v6)
        sai_thrift_remove_route_entry(self.client, self.customer5_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor5)
        sai_thrift_remove_next_hop(self.client, self.onhop5)
        sai_thrift_remove_route_entry(self.client, self.customer4_v6_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor4_v6)
        sai_thrift_remove_next_hop(self.client, self.onhop4_v6)
        sai_thrift_remove_route_entry(self.client, self.customer4_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor4)
        sai_thrift_remove_next_hop(self.client, self.onhop4)
        sai_thrift_remove_route_entry(self.client, self.customer3_v6_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor3_v6)
        sai_thrift_remove_next_hop(self.client, self.onhop3_v6)
        sai_thrift_remove_route_entry(self.client, self.customer3_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor3)
        sai_thrift_remove_next_hop(self.client, self.onhop3)
        sai_thrift_remove_route_entry(self.client, self.customer2_v6_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor2_v6)
        sai_thrift_remove_next_hop(self.client, self.onhop2_v6)
        sai_thrift_remove_route_entry(self.client, self.customer2_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor2)
        sai_thrift_remove_next_hop(self.client, self.onhop2)
        sai_thrift_remove_route_entry(self.client, self.customer1_v6_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor1_v6)
        sai_thrift_remove_next_hop(self.client, self.onhop1_v6)
        sai_thrift_remove_route_entry(self.client, self.customer1_route)
        sai_thrift_remove_neighbor_entry(self.client, self.onbor1)
        sai_thrift_remove_next_hop(self.client, self.onhop1)

        i = 1
        while i:
            vm_v6_route = getattr(self, 'vm_v6_route%d' % i, None)
            if vm_v6_route:
                sai_thrift_remove_route_entry(self.client, vm_v6_route)
                i += 1
            else:
                break

        i = 1
        while i:
            vm_route = getattr(self, 'vm_route%d' % i, None)
            if vm_route:
                sai_thrift_remove_route_entry(self.client, vm_route)
                i += 1
            else:
                break

        sai_thrift_remove_next_hop(self.client, self.tunnel_nhop)
        sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                  self.tunnel_term)
        sai_thrift_remove_tunnel(self.client, self.tunnel)

        i = 1
        while i:
            decap_map_entry = getattr(self, 'decap_tunnel_map_entry%d' % i,
                                      None)
            if decap_map_entry:
                sai_thrift_remove_tunnel_map_entry(self.client,
                                                   decap_map_entry)
                i += 1
            else:
                break

        i = 1
        while i:
            encap_map_entry = getattr(self, 'encap_tunnel_map_entry%d' % i,
                                      None)
            if encap_map_entry:
                sai_thrift_remove_tunnel_map_entry(self.client,
                                                   encap_map_entry)
                i += 1
            else:
                break

        sai_thrift_remove_tunnel_map(self.client, self.decap_tunnel_map)
        sai_thrift_remove_tunnel_map(self.client, self.encap_tunnel_map)
        sai_thrift_remove_route_entry(self.client, self.tunnel_route)
        sai_thrift_remove_neighbor_entry(self.client, self.unbor)
        sai_thrift_remove_next_hop(self.client, self.unhop)
        sai_thrift_remove_router_interface(self.client, self.urif)
        sai_thrift_remove_router_interface(self.client, self.orif8)
        sai_thrift_remove_router_interface(self.client, self.orif7)
        sai_thrift_remove_router_interface(self.client, self.orif6)
        sai_thrift_remove_router_interface(self.client, self.orif5)
        sai_thrift_remove_router_interface(self.client, self.orif234)
        sai_thrift_remove_router_interface(self.client, self.orif1)
        sai_thrift_remove_virtual_router(self.client, self.ovrf8)
        sai_thrift_remove_virtual_router(self.client, self.ovrf67)
        sai_thrift_remove_virtual_router(self.client, self.ovrf5)
        sai_thrift_remove_virtual_router(self.client, self.ovrf234)
        sai_thrift_remove_virtual_router(self.client, self.ovrf1)
        sai_thrift_remove_router_interface(self.client, self.urif_lpb)
        sai_thrift_remove_virtual_router(self.client, self.uvrf)

        super(MultipleMapperEntriesBase, self).tearDown()

    def encapV4Test(self):
        '''
        Verify IPv4 packets encapsulation with multiple mapper entries
        '''
        print("\nencapV4Test()")

        for data in self.pkt_data:
            pkt_len = 104
            dec = 0

            if data['vlan']:
                dec = 4

            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=data['mac'],
                                    ip_dst=self.vm_ip,
                                    ip_src=data['ip'],
                                    dl_vlan_enable=data['vlan'],
                                    vlan_vid=data['vlan_no'],
                                    ip_id=108,
                                    ip_ttl=64,
                                    pktlen=pkt_len)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.vm_ip,
                                          ip_src=data['ip'],
                                          ip_id=108,
                                          ip_ttl=63,
                                          pktlen=pkt_len - dec)
            if self.ipv6 is False:
                vxlan_pkt = Mask(
                    simple_vxlan_packet(eth_dst=self.unbor_mac,
                                        eth_src=ROUTER_MAC,
                                        ip_dst=self.tun_ip,
                                        ip_src=self.lpb_ip,
                                        ip_id=0,
                                        ip_ttl=64,
                                        ip_flags=0x2,
                                        with_udp_chksum=False,
                                        vxlan_vni=data['vni'],
                                        inner_frame=inner_pkt))
            else:
                vxlan_pkt = Mask(
                    simple_vxlanv6_packet(eth_dst=self.unbor_mac,
                                          eth_src=ROUTER_MAC,
                                          ipv6_dst=self.tun_ip,
                                          ipv6_src=self.lpb_ip,
                                          ipv6_hlim=64,
                                          with_udp_chksum=False,
                                          vxlan_vni=data['vni'],
                                          inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

            if isinstance(data['port'], int):
                print("Sending packet from port %d -> VNI %d" %
                      (data['port'], data['vni']))
                send_packet(self, data['port'], pkt)
            else:
                print("Sending packet from LAG port %d -> VNI %d" %
                      (data['port'][0], data['vni']))
                send_packet(self, data['port'][0], pkt)
            verify_packet(self, vxlan_pkt, self.uport_dev)
            print("\tOK")

    def decapV4Test(self):
        '''
        Verify IPv4 packets decapsulation with multiple mapper entries
        '''
        print("\ndecapV4Test()")

        for data in self.pkt_data:
            pkt_len = 100
            inc = 0

            if data['vlan']:
                inc = 4

            pkt = simple_udp_packet(eth_dst=data['mac'],
                                    eth_src=ROUTER_MAC,
                                    ip_dst=data['ip'],
                                    ip_src=self.vm_ip,
                                    dl_vlan_enable=data['vlan'],
                                    vlan_vid=data['vlan_no'],
                                    ip_id=108,
                                    ip_ttl=63,
                                    pktlen=pkt_len + inc)
            inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                          eth_src=self.inner_dmac,
                                          ip_dst=data['ip'],
                                          ip_src=self.vm_ip,
                                          ip_id=108,
                                          ip_ttl=64,
                                          pktlen=pkt_len)
            if self.ipv6 is False:
                vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                                eth_src=self.unbor_mac,
                                                ip_dst=self.lpb_ip,
                                                ip_src=self.tun_ip,
                                                ip_id=0,
                                                ip_ttl=64,
                                                ip_flags=0x2,
                                                udp_sport=11638,
                                                with_udp_chksum=False,
                                                vxlan_vni=data['vni'],
                                                inner_frame=inner_pkt)
            else:
                vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                                  eth_src=self.unbor_mac,
                                                  ipv6_dst=self.lpb_ip,
                                                  ipv6_src=self.tun_ip,
                                                  ipv6_hlim=64,
                                                  udp_sport=11638,
                                                  with_udp_chksum=False,
                                                  vxlan_vni=data['vni'],
                                                  inner_frame=inner_pkt)

            print("Sending packet from VNI %d" % data['vni'], end="")
            send_packet(self, self.uport_dev, vxlan_pkt)
            if isinstance(data['port'], int):
                print(" -> port %d" % data['port'])
                verify_packet(self, pkt, data['port'])
            else:
                print(" -> LAG")
                verify_packet_any_port(self, pkt, data['port'])
            print("\tOK")

    def encapV6Test(self):
        '''
        Verify IPv6 packets encapsulation with multiple mapper entries
        '''
        print("\nencapV6Test()")

        for data in self.pkt_data:
            pkt_len = 104
            dec = 0

            if data['vlan']:
                dec = 4

            pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                      eth_src=data['mac'],
                                      ipv6_dst=self.vm_ipv6,
                                      ipv6_src=data['ipv6'],
                                      dl_vlan_enable=data['vlan'],
                                      vlan_vid=data['vlan_no'],
                                      ipv6_hlim=64,
                                      pktlen=pkt_len)
            inner_pkt = simple_udpv6_packet(eth_dst=self.inner_dmac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_dst=self.vm_ipv6,
                                            ipv6_src=data['ipv6'],
                                            ipv6_hlim=63,
                                            pktlen=pkt_len - dec)
            if self.ipv6 is False:
                vxlan_pkt = Mask(
                    simple_vxlan_packet(eth_dst=self.unbor_mac,
                                        eth_src=ROUTER_MAC,
                                        ip_dst=self.tun_ip,
                                        ip_src=self.lpb_ip,
                                        ip_id=0,
                                        ip_ttl=64,
                                        ip_flags=0x2,
                                        with_udp_chksum=False,
                                        vxlan_vni=data['vni'],
                                        inner_frame=inner_pkt))
            else:
                vxlan_pkt = Mask(
                    simple_vxlanv6_packet(eth_dst=self.unbor_mac,
                                          eth_src=ROUTER_MAC,
                                          ipv6_dst=self.tun_ip,
                                          ipv6_src=self.lpb_ip,
                                          ipv6_hlim=64,
                                          with_udp_chksum=False,
                                          vxlan_vni=data['vni'],
                                          inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

            if isinstance(data['port'], int):
                print("Sending packet from port %d -> VNI %d" %
                      (data['port'], data['vni']))
                send_packet(self, data['port'], pkt)
            else:
                print("Sending packet from LAG port %d -> VNI %d" %
                      (data['port'][0], data['vni']))
                send_packet(self, data['port'][0], pkt)
            verify_packet(self, vxlan_pkt, self.uport_dev)
            print("\tOK")

    def decapV6Test(self):
        '''
        Verify IPv6 packets decapsulation with multiple mapper entries
        '''
        print("\ndecapV6Test()")

        for data in self.pkt_data:
            pkt_len = 100
            inc = 0

            if data['vlan']:
                inc = 4

            pkt = simple_udpv6_packet(eth_dst=data['mac'],
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=data['ipv6'],
                                      ipv6_src=self.vm_ipv6,
                                      dl_vlan_enable=data['vlan'],
                                      vlan_vid=data['vlan_no'],
                                      ipv6_hlim=63,
                                      pktlen=pkt_len + inc)
            inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.inner_dmac,
                                            ipv6_dst=data['ipv6'],
                                            ipv6_src=self.vm_ipv6,
                                            ipv6_hlim=64,
                                            pktlen=pkt_len)
            if self.ipv6 is False:
                vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                                eth_src=self.unbor_mac,
                                                ip_dst=self.lpb_ip,
                                                ip_src=self.tun_ip,
                                                ip_id=0,
                                                ip_ttl=64,
                                                ip_flags=0x2,
                                                udp_sport=11638,
                                                with_udp_chksum=False,
                                                vxlan_vni=data['vni'],
                                                inner_frame=inner_pkt)
            else:
                vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                                  eth_src=self.unbor_mac,
                                                  ipv6_dst=self.lpb_ip,
                                                  ipv6_src=self.tun_ip,
                                                  ipv6_hlim=64,
                                                  udp_sport=11638,
                                                  with_udp_chksum=False,
                                                  vxlan_vni=data['vni'],
                                                  inner_frame=inner_pkt)

            print("Sending packet from VNI %d" % data['vni'], end="")
            send_packet(self, self.uport_dev, vxlan_pkt)
            if isinstance(data['port'], int):
                print(" -> port %d" % data['port'])
                verify_packet(self, pkt, data['port'])
            else:
                print(" -> LAG")
                verify_packet_any_port(self, pkt, data['port'])
            print("\tOK")

    def addDelMapperEntriesTest(self):
        '''
        Verify packets encap/decap when mapper entries are added or removed
        dynamically
        '''
        print("\naddDelMapperEntriesTest()")

        enc_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.customer8_mac,
                                    ip_dst=self.vm_ip,
                                    ip_src=self.customer8_ip,
                                    ip_id=108,
                                    ip_ttl=64)
        inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.vm_ip,
                                      ip_src=self.customer8_ip,
                                      ip_id=108,
                                      ip_ttl=63)
        if self.ipv6 is False:
            enc_vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun_ip,
                                    ip_src=self.lpb_ip,
                                    ip_id=0,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni8,
                                    inner_frame=inner_pkt))
        else:
            enc_vxlan_pkt = Mask(
                simple_vxlanv6_packet(eth_dst=self.unbor_mac,
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=self.tun_ip,
                                      ipv6_src=self.lpb_ip,
                                      ipv6_hlim=64,
                                      with_udp_chksum=False,
                                      vxlan_vni=self.vni8,
                                      inner_frame=inner_pkt))
        enc_vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

        dec_pkt = simple_udp_packet(eth_dst=self.customer8_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.customer8_ip,
                                    ip_src=self.vm_ip,
                                    ip_id=108,
                                    ip_ttl=63)
        inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.inner_dmac,
                                      ip_dst=self.customer8_ip,
                                      ip_src=self.vm_ip,
                                      ip_id=108,
                                      ip_ttl=64)
        if self.ipv6 is False:
            dec_vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                                eth_src=self.unbor_mac,
                                                ip_dst=self.lpb_ip,
                                                ip_src=self.tun_ip,
                                                ip_id=0,
                                                ip_ttl=64,
                                                ip_flags=0x2,
                                                udp_sport=11638,
                                                with_udp_chksum=False,
                                                vxlan_vni=self.vni8,
                                                inner_frame=inner_pkt)
        else:
            dec_vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                                  eth_src=self.unbor_mac,
                                                  ipv6_dst=self.lpb_ip,
                                                  ipv6_src=self.tun_ip,
                                                  ipv6_hlim=64,
                                                  udp_sport=11638,
                                                  with_udp_chksum=False,
                                                  vxlan_vni=self.vni8,
                                                  inner_frame=inner_pkt)

        print("Verifying encapsulation without mapper entries")
        send_packet(self, self.oport8_dev, enc_pkt)
        verify_packet(self, enc_vxlan_pkt, self.uport_dev)
        verify_no_other_packets(self)
        print("\tDropped")

        print("Verifying decapsulation without mapper entries")
        send_packet(self, self.uport_dev, dec_vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

        print("Adding encap mapper entry")
        encap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
            self.client,
            tunnel_map=self.encap_tunnel_map,
            tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
            virtual_router_id_key=self.ovrf8,
            vni_id_value=self.vni8)

        print("Verifying encapsulation after adding encap mapper entry")
        send_packet(self, self.oport8_dev, enc_pkt)
        verify_packet(self, enc_vxlan_pkt, self.uport_dev)
        print("\tOK")

        print("Verifying decapsulation after adding encap mapper entry")
        send_packet(self, self.uport_dev, dec_vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

        print("Adding decap mapper entry")
        decap_tunnel_map_entry = sai_thrift_create_tunnel_map_entry(
            self.client,
            tunnel_map=self.encap_tunnel_map,
            tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
            virtual_router_id_value=self.ovrf8,
            vni_id_key=self.vni8)

        print("Verifying encapsulation after adding encap and decap "
              "mapper entries")
        send_packet(self, self.oport8_dev, enc_pkt)
        verify_packet(self, enc_vxlan_pkt, self.uport_dev)
        print("\tOK")

        print("Verifying decapsulation after adding encap and decap "
              "mapper entries")
        send_packet(self, self.uport_dev, dec_vxlan_pkt)
        verify_packet(self, dec_pkt, self.oport8_dev)
        print("\tOK")

        print("Removing decap mapper entry")
        sai_thrift_remove_tunnel_map_entry(self.client, decap_tunnel_map_entry)

        print("Verifying encapsulation after removing decap mapper entry")
        send_packet(self, self.oport8_dev, enc_pkt)
        verify_packet(self, enc_vxlan_pkt, self.uport_dev)
        print("\tOK")

        print("Verifying decapsulation after removing decap mapper entry")
        send_packet(self, self.uport_dev, dec_vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")

        print("Removing encap mapper entry")
        sai_thrift_remove_tunnel_map_entry(self.client, encap_tunnel_map_entry)

        print("Verifying encapsulation after removing encap and decap "
              "mapper entries")
        send_packet(self, self.oport8_dev, enc_pkt)
        verify_packet(self, enc_vxlan_pkt, self.uport_dev)
        verify_no_other_packets(self)
        print("\tDropped")

        print("Verifying decapsulation after removing encap and decap "
              "mapper entries")
        send_packet(self, self.uport_dev, dec_vxlan_pkt)
        verify_no_other_packets(self)
        print("\tDropped")


@group("draft")
class MultipleMapperEntriesIpv4UnderlayTest(MultipleMapperEntriesBase):
    '''
    Tests verifying encap/decap on different overlay VRFs + RIFs
    (multiple mapper entries) with IPv4 underlay layer
    '''

    def runTest(self):
        self.encapV4Test()
        self.decapV4Test()
        self.encapV6Test()
        self.decapV6Test()
        self.addDelMapperEntriesTest()


@group("draft")
class MultipleMapperEntriesIpv6UnderlayTest(MultipleMapperEntriesBase):
    '''
    Tests verifying encap/decap on different overlay VRFs + RIFs
    (multiple mapper entries) with IPv6 underlay layer
    '''

    def __init__(self):
        super(MultipleMapperEntriesIpv6UnderlayTest, self).__init__(ipv6=True)

    def runTest(self):
        self.encapV4Test()
        self.decapV4Test()
        self.encapV6Test()
        self.decapV6Test()
        self.addDelMapperEntriesTest()


# # # # # # # # # # # # # VxLAN MP to MP tests follow # # # # # # # # # # # #
@group("draft")
class VxLanRifsConfigBaseSetup(SaiHelperBase):
    '''
    Base setup for multipoint-to-multipoint tunnel tests regarding different
    overlay-underlay interfaces configutrations

    Args:
        ipv6 (bool): ipv6 underlay configuraton indicator
    '''

    def __init__(self, ipv6=False):
        super(VxLanRifsConfigBaseSetup, self).__init__()
        self.ipv6 = ipv6

        if ipv6 is True:
            self.tun_ip = "2001:0db8::10:1"
            self.lpb_ip = "2001:0db8::10:10"
        else:
            self.tun_ip = "10.10.10.1"
            self.lpb_ip = "10.10.10.10"

    def setUp(self):
        super(VxLanRifsConfigBaseSetup, self).setUp()

        self.vni = 1000
        self.inner_dmac = "00:11:11:11:11:11"

        self.ovrf = sai_thrift_create_virtual_router(self.client)
        self.uvrf = sai_thrift_create_virtual_router(self.client)

        self.urif_lpb = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_LOOPBACK,
            virtual_router_id=self.uvrf)

        self.encap_tunnel_map = sai_thrift_create_tunnel_map(
            self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

        self.decap_tunnel_map = sai_thrift_create_tunnel_map(
            self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

        # encap/decap mapper entries
        self.encap_map_entry = sai_thrift_create_tunnel_map_entry(
            self.client,
            tunnel_map=self.encap_tunnel_map,
            tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
            virtual_router_id_key=self.ovrf,
            vni_id_value=self.vni)

        self.decap_map_entry = sai_thrift_create_tunnel_map_entry(
            self.client,
            tunnel_map=self.decap_tunnel_map,
            tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
            virtual_router_id_value=self.ovrf,
            vni_id_key=self.vni)

        encap_maps = sai_thrift_object_list_t(count=1,
                                              idlist=[self.encap_tunnel_map])
        decap_maps = sai_thrift_object_list_t(count=1,
                                              idlist=[self.decap_tunnel_map])

        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2MP
        ttl_mode = SAI_TUNNEL_TTL_MODE_PIPE_MODEL

        self.tunnel = sai_thrift_create_tunnel(
            self.client,
            type=tunnel_type,
            encap_src_ip=sai_ipaddress(self.lpb_ip),
            encap_mappers=encap_maps,
            decap_mappers=decap_maps,
            encap_ttl_mode=ttl_mode,
            decap_ttl_mode=ttl_mode,
            underlay_interface=self.urif_lpb)

        self.tunnel_term = sai_thrift_create_tunnel_term_table_entry(
            self.client,
            tunnel_type=tunnel_type,
            vr_id=self.uvrf,
            action_tunnel_id=self.tunnel,
            type=term_type,
            src_ip=sai_ipaddress(self.tun_ip),
            dst_ip=sai_ipaddress(self.lpb_ip))

        self.tunnel_nhop = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
            tunnel_id=self.tunnel,
            ip=sai_ipaddress(self.tun_ip),
            tunnel_mac=self.inner_dmac,
            tunnel_vni=self.vni)

    def tearDown(self):
        sai_thrift_remove_next_hop(self.client, self.tunnel_nhop)
        sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                  self.tunnel_term)
        sai_thrift_remove_tunnel(self.client, self.tunnel)
        sai_thrift_remove_tunnel_map_entry(self.client, self.decap_map_entry)
        sai_thrift_remove_tunnel_map_entry(self.client, self.encap_map_entry)
        sai_thrift_remove_tunnel_map(self.client, self.decap_tunnel_map)
        sai_thrift_remove_tunnel_map(self.client, self.encap_tunnel_map)
        sai_thrift_remove_router_interface(self.client, self.urif_lpb)
        sai_thrift_remove_virtual_router(self.client, self.uvrf)
        sai_thrift_remove_virtual_router(self.client, self.ovrf)

        super(VxLanRifsConfigBaseSetup, self).tearDown()

    def _configureOrif(self, port_vlan_id, addrs, bridge_ports=None,
                       rif_type=SAI_ROUTER_INTERFACE_TYPE_PORT):
        '''
        A helper function for creating the objects related with overlay
        configuration.

        Args:
            port_vlan_id (oid): object ID of port or vlan for which RIF
                                is to be created
            addrs (dict): a dictionary with necessary addresses
                          reguired keys are:
                              customer_ip - customer IP
                              customer_ipv6 - customer IPv6
                              customer_mac - customer MAC
                              vlan_no - (if required) VLAN number
            bridge_ports (list): a list of bridge port's objects ID; applied
                                 when RIF type is VLAN
            rif_type (SAI_type): a type of router interface

        Return:
            orif: overlay RIF object ID
            onhops: a list of overlay nexthops object IDs
            onbors: a list of overlay neighbors object IDs
            customer_routes: a list of customer route entries object IDs
        '''
        addrs = addrs.copy()
        for key in list(addrs.keys()):
            if key not in ["customer_ip", "customer_ipv6", "customer_mac",
                           "vlan_no"]:
                addrs.pop(key)
            elif key != "vlan_no":
                addrs[key] = addrs[key] if isinstance(addrs[key], list) \
                    else [addrs[key]]

        port_id = None
        vlan_id = None

        if rif_type == SAI_ROUTER_INTERFACE_TYPE_VLAN:
            vlan_id = port_vlan_id
            for mac, bport in zip(addrs["customer_mac"], bridge_ports):
                fdb_entry = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                                   mac_address=mac,
                                                   bv_id=vlan_id)
                sai_thrift_create_fdb_entry(self.client,
                                            fdb_entry,
                                            type=SAI_FDB_ENTRY_TYPE_STATIC,
                                            bridge_port_id=bport)
        else:
            port_id = port_vlan_id

        outer_vid = None

        if rif_type == SAI_ROUTER_INTERFACE_TYPE_SUB_PORT:
            outer_vid = addrs["vlan_no"]

        onhops = []
        onbors = []
        customer_routes = []

        orif = sai_thrift_create_router_interface(self.client,
                                                  type=rif_type,
                                                  virtual_router_id=self.ovrf,
                                                  port_id=port_id,
                                                  vlan_id=vlan_id,
                                                  outer_vlan_id=outer_vid)

        for customer_ip, customer_ipv6, customer_mac in zip(
                addrs["customer_ip"], addrs["customer_ipv6"],
                addrs["customer_mac"]):
            onhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(customer_ip),
                                               router_interface_id=orif,
                                               type=SAI_NEXT_HOP_TYPE_IP)
            onhops.append(onhop)

            onbor = sai_thrift_neighbor_entry_t(
                rif_id=orif, ip_address=sai_ipaddress(customer_ip))
            sai_thrift_create_neighbor_entry(self.client, onbor,
                                             dst_mac_address=customer_mac,
                                             no_host_route=True)
            onbors.append(onbor)

            customer_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf, destination=sai_ipprefix(customer_ip + '/32'))
            sai_thrift_create_route_entry(self.client,
                                          customer_route,
                                          next_hop_id=onhop)
            customer_routes.append(customer_route)

            onhop_v6 = sai_thrift_create_next_hop(
                self.client,
                ip=sai_ipaddress(customer_ipv6),
                router_interface_id=orif,
                type=SAI_NEXT_HOP_TYPE_IP)
            onhops.append(onhop_v6)

            onbor_v6 = sai_thrift_neighbor_entry_t(
                rif_id=orif, ip_address=sai_ipaddress(customer_ipv6))
            sai_thrift_create_neighbor_entry(self.client, onbor_v6,
                                             dst_mac_address=customer_mac,
                                             no_host_route=True)
            onbors.append(onbor_v6)

            customer_v6_route = sai_thrift_route_entry_t(
                vr_id=self.ovrf,
                destination=sai_ipprefix(customer_ipv6 + '/128'))
            sai_thrift_create_route_entry(self.client,
                                          customer_v6_route,
                                          next_hop_id=onhop_v6)
            customer_routes.append(customer_v6_route)

        return orif, onhops, onbors, customer_routes

    def _configureUrif(self, port_vlan_id, addrs, bridge_ports=None,
                       rif_type=SAI_ROUTER_INTERFACE_TYPE_PORT):
        '''
        A helper function for creating the objects related with overlay
        configuration.

        Args:
            port_vlan_id (oid): object ID of port or vlan for which RIF
                                is to be created
            addrs (dict): a dictionary with necessary addresses
                          reguired keys are:
                              tun_ip - tunnel IP
                              lpb_ip - loopback IP
                              vm_ip - VM IP
                              vm_ipv6 - VM IPv6
                              unbor_mac - underlay neighbor MAC
                              vlan_no - (if required) VLAN number
            bridge_ports (list): a list of bridge port's objects ID; applied
                                 when RIF type is VLAN
            rif_type (SAI_type): a type of router interface

        Return:
            urif: underlay RIF object ID
            unhops: a list of underlay nexthops
            unbors: a list of underlay neighbors
            tunnel_terms: a list of tunnel termination entries object IDs
            tunnel_routes: a list of tunnel route entries object IDs
            tunnel_nhops: a list of tunnel nexthops object IDs
            vm_routes: a list of object IDs of route entires to VM
        '''
        if self.ipv6 is True:
            tun_ip_mask = "/128"
        else:
            tun_ip_mask = "/32"

        addrs = addrs.copy()
        for key in list(addrs.keys()):
            if key not in ["tun_ip", "lpb_ip", "unbor_mac", "vlan_no", "vm_ip",
                           "vm_ipv6", "tunnel_route", "vm_route"]:
                addrs.pop(key)
            elif key not in ["vlan_no", "tunnel_route", "vm_route"]:
                addrs[key] = addrs[key] if isinstance(addrs[key], list) \
                    else [addrs[key]]

        port_id = None
        vlan_id = None

        if rif_type == SAI_ROUTER_INTERFACE_TYPE_VLAN:
            vlan_id = port_vlan_id
            for mac, bport in zip(addrs["unbor_mac"], bridge_ports):
                fdb_entry = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                                   mac_address=mac,
                                                   bv_id=vlan_id)
                sai_thrift_create_fdb_entry(self.client,
                                            fdb_entry,
                                            type=SAI_FDB_ENTRY_TYPE_STATIC,
                                            bridge_port_id=bport)
        else:
            port_id = port_vlan_id

        outer_vid = None

        if rif_type == SAI_ROUTER_INTERFACE_TYPE_SUB_PORT:
            outer_vid = addrs["vlan_no"]

        unhops = []
        unbors = []
        tunnel_terms = []
        tunnel_routes = []
        tunnel_nhops = []
        vm_routes = []

        urif = sai_thrift_create_router_interface(self.client,
                                                  type=rif_type,
                                                  virtual_router_id=self.uvrf,
                                                  port_id=port_id,
                                                  vlan_id=vlan_id,
                                                  outer_vlan_id=outer_vid)

        for i, (tun_ip, unbor_mac) in enumerate(
                zip(addrs["tun_ip"], addrs["unbor_mac"])):
            unhop = sai_thrift_create_next_hop(self.client,
                                               ip=sai_ipaddress(tun_ip),
                                               router_interface_id=urif,
                                               type=SAI_NEXT_HOP_TYPE_IP)
            unhops.append(unhop)

            unbor = sai_thrift_neighbor_entry_t(
                rif_id=urif, ip_address=sai_ipaddress(tun_ip))
            sai_thrift_create_neighbor_entry(self.client,
                                             unbor,
                                             dst_mac_address=unbor_mac,
                                             no_host_route=True)
            unbors.append(unbor)

            if addrs["vm_route"] is True:
                tunnel_nhop = sai_thrift_create_next_hop(
                    self.client,
                    type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                    tunnel_id=self.tunnel,
                    ip=sai_ipaddress(tun_ip),
                    tunnel_mac=self.inner_dmac,
                    tunnel_vni=self.vni)
                tunnel_nhops.append(tunnel_nhop)

                vm_route = sai_thrift_route_entry_t(
                    vr_id=self.ovrf,
                    destination=sai_ipprefix(addrs["vm_ip"][i] + '/24'))
                sai_thrift_create_route_entry(self.client, vm_route,
                                              next_hop_id=tunnel_nhop)
                vm_routes.append(vm_route)

                vm_v6_route = sai_thrift_route_entry_t(
                    vr_id=self.ovrf,
                    destination=sai_ipprefix(addrs["vm_ipv6"][i] + '/128'))
                sai_thrift_create_route_entry(self.client, vm_v6_route,
                                              next_hop_id=tunnel_nhop)
                vm_routes.append(vm_v6_route)

            if addrs["tunnel_route"] is True:
                tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                    self.client,
                    tunnel_type=SAI_TUNNEL_TYPE_VXLAN,
                    vr_id=self.uvrf,
                    action_tunnel_id=self.tunnel,
                    type=SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2MP,
                    src_ip=sai_ipaddress(tun_ip),
                    dst_ip=sai_ipaddress(addrs["lpb_ip"][i]))
                tunnel_terms.append(tunnel_term)

                tunnel_route = sai_thrift_route_entry_t(
                    vr_id=self.uvrf,
                    destination=sai_ipprefix(tun_ip + tun_ip_mask))
                sai_thrift_create_route_entry(self.client,
                                              tunnel_route,
                                              next_hop_id=unhop)
                tunnel_routes.append(tunnel_route)

        return \
            urif, unhops, unbors, tunnel_nhops, vm_routes, tunnel_terms, \
            tunnel_routes

    def _configureOverlayEcmp(self, oport, odata, tun_data, ecmp):
        '''
        A helper function for creating the objects related with overlay ECMP
        configuration.

        Args:
            oport (oid): object ID of port RIF is to be created
            odata (dict): an overlay confguration data
                          reguired keys are:
                              vm_ip - VM IP
                              vm_ipv6 - VM IPv6
                              customer_ip - customer IP
                              customer_ipv6 - customer IPv6
                              customer_mac - customer MAC
            tun_data (list): a list of tunnel IPs
            ecmp (oid): object ID of an ECMP

        Return:
            orif: overlay RIF object ID
            [onhop, onhop_v6]: overlay nexthops object IDs for IPv4 and IPv6
            [onbor, onbor_v6]: overlay neighbors object IDs for IPv4 and IPv6
            [customer_route, customer_v6_route]: IPv4 and IPv6 customer route
                                                 entries object IDs
            tunnel_nhops: a list of tunnel nexthops object IDs
            ecmp_members: a list of ECMP members object IDs
            [vm_route, vm_v6_route]: IPv4 and IPv6 VM route entries object IDs
        '''
        tunnel_nhops = []
        ecmp_members = []

        orif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.ovrf,
            port_id=oport)

        onhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(odata["customer_ip"]),
            router_interface_id=orif,
            type=SAI_NEXT_HOP_TYPE_IP)

        onbor = sai_thrift_neighbor_entry_t(
            rif_id=orif, ip_address=sai_ipaddress(odata["customer_ip"]))
        sai_thrift_create_neighbor_entry(self.client, onbor,
                                         dst_mac_address=odata["customer_mac"],
                                         no_host_route=True)

        customer_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(odata["customer_ip"] + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      customer_route,
                                      next_hop_id=onhop)

        onhop_v6 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(odata["customer_ipv6"]),
            router_interface_id=orif,
            type=SAI_NEXT_HOP_TYPE_IP)

        onbor_v6 = sai_thrift_neighbor_entry_t(
            rif_id=orif, ip_address=sai_ipaddress(odata["customer_ipv6"]))
        sai_thrift_create_neighbor_entry(self.client, onbor_v6,
                                         dst_mac_address=odata["customer_mac"],
                                         no_host_route=True)

        customer_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(odata["customer_ipv6"] + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      customer_v6_route,
                                      next_hop_id=onhop_v6)

        for addr in tun_data:
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                tunnel_id=self.tunnel,
                ip=sai_ipaddress(addr),
                tunnel_mac=self.inner_dmac,
                tunnel_vni=self.vni)
            tunnel_nhops.append(tunnel_nhop)

            ecmp_member = sai_thrift_create_next_hop_group_member(
                self.client,
                next_hop_group_id=ecmp,
                next_hop_id=tunnel_nhop)
            ecmp_members.append(ecmp_member)

        vm_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(odata["vm_ip"] + '/32'))
        sai_thrift_create_route_entry(self.client,
                                      vm_route,
                                      next_hop_id=ecmp)

        vm_v6_route = sai_thrift_route_entry_t(
            vr_id=self.ovrf,
            destination=sai_ipprefix(odata["vm_ipv6"] + '/128'))
        sai_thrift_create_route_entry(self.client,
                                      vm_v6_route,
                                      next_hop_id=ecmp)

        return \
            orif, [onhop, onhop_v6], [onbor, onbor_v6], \
            [customer_route, customer_v6_route], tunnel_nhops, ecmp_members, \
            [vm_route, vm_v6_route]

    def _v4EncapTest(self, src_port, dst_ports, pkt_data, vlan_no=None):
        '''
        A helper function for checking IPv4 packets encapsulation

        Args:
            src_port (int): an overlay device port number
            dst_ports (list_or_int): a list with underlay destination
                                     device port number(s)
            pkt_data (dict): a dictionary with necessary packets data
                             required keys are:
                                 customer_mac - customer MAC
                                 customer_ip - customer IP
                                 vm_ip - VM IP
                                 unbor_mac - underlay neighbour MAC
                                 tun_ip - tunnel IP
            vlan_no (dict): a dictionary with VLAN numbers; allowed keys:
                                in - input (overlay port) VLAN number
                                out - output (underlay port) VLAN number
        '''
        in_vlan_enable = False
        in_vlan_no = 0
        in_len_inc = 0
        if "in" in vlan_no:
            in_vlan_no = vlan_no["in"]
            in_vlan_enable = True if in_vlan_no else False
            in_len_inc = 4 if in_vlan_enable else 0

        out_vlan_enable = False
        out_vlan_no = 0
        if "out" in vlan_no:
            out_vlan_no = vlan_no["out"]
            out_vlan_enable = True if out_vlan_no else False

        if not isinstance(dst_ports, list):
            dst_ports = [dst_ports]

        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=pkt_data["customer_mac"],
                                ip_dst=pkt_data["vm_ip"],
                                ip_src=pkt_data["customer_ip"],
                                ip_id=108,
                                dl_vlan_enable=in_vlan_enable,
                                vlan_vid=in_vlan_no,
                                ip_ttl=64,
                                pktlen=100 + in_len_inc)
        inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=pkt_data["vm_ip"],
                                      ip_src=pkt_data["customer_ip"],
                                      ip_id=108,
                                      ip_ttl=63,
                                      pktlen=100)
        if self.ipv6 is False:
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=pkt_data["unbor_mac"],
                                    eth_src=ROUTER_MAC,
                                    ip_dst=pkt_data["tun_ip"],
                                    ip_src=self.lpb_ip,
                                    ip_id=0,
                                    dl_vlan_enable=out_vlan_enable,
                                    vlan_vid=out_vlan_no,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni,
                                    inner_frame=inner_pkt))
        else:
            vxlan_pkt = Mask(
                simple_vxlanv6_packet(eth_dst=pkt_data["unbor_mac"],
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=pkt_data["tun_ip"],
                                      ipv6_src=self.lpb_ip,
                                      dl_vlan_enable=out_vlan_enable,
                                      vlan_vid=out_vlan_no,
                                      ipv6_hlim=64,
                                      with_udp_chksum=False,
                                      vxlan_vni=self.vni,
                                      inner_frame=inner_pkt))
        vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

        print("Sending IPv4 packet: port %d -> %s"
              % (src_port, dst_ports))
        send_packet(self, src_port, pkt)
        verify_packet_any_port(self, vxlan_pkt, dst_ports)
        print("\tOK")

    def _v6EncapTest(self, src_port, dst_ports, pkt_data, vlan_no=None):
        '''
        A helper function for checking IPv6 packets encapsulation

        Args:
            src_port (int): an overlay device port number
            dst_ports (list_or_int): a list with underlay destination
                                     device port number(s)
            pkt_data (dict): a dictionary with necessary packets data
                             required keys are:
                                 customer_mac - customer MAC
                                 customer_ip - customer IP
                                 vm_ipv6 - VM IP
                                 unbor_mac - underlay neighbour MAC
                                 tun_ip - tunnel IP
            vlan_no (dict): a dictionary with VLAN numbers; allowed keys:
                                in - input (overlay port) VLAN number
                                out - output (underlay port) VLAN number
        '''
        in_vlan_enable = False
        in_vlan_no = 0
        in_len_inc = 0
        if "in" in vlan_no:
            in_vlan_no = vlan_no["in"]
            in_vlan_enable = True if in_vlan_no else False
            in_len_inc = 4 if in_vlan_enable else 0

        out_vlan_enable = False
        out_vlan_no = 0
        if "out" in vlan_no:
            out_vlan_no = vlan_no["out"]
            out_vlan_enable = True if out_vlan_no else False

        if not isinstance(dst_ports, list):
            dst_ports = [dst_ports]

        pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                  eth_src=pkt_data["customer_mac"],
                                  ipv6_dst=pkt_data["vm_ipv6"],
                                  ipv6_src=pkt_data["customer_ipv6"],
                                  dl_vlan_enable=in_vlan_enable,
                                  vlan_vid=in_vlan_no,
                                  ipv6_hlim=64,
                                  pktlen=100 + in_len_inc)
        inner_pkt = simple_udpv6_packet(eth_dst=self.inner_dmac,
                                        eth_src=ROUTER_MAC,
                                        ipv6_dst=pkt_data["vm_ipv6"],
                                        ipv6_src=pkt_data["customer_ipv6"],
                                        ipv6_hlim=63,
                                        pktlen=100)
        if self.ipv6 is False:
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=pkt_data["unbor_mac"],
                                    eth_src=ROUTER_MAC,
                                    ip_dst=pkt_data["tun_ip"],
                                    ip_src=self.lpb_ip,
                                    ip_id=0,
                                    dl_vlan_enable=out_vlan_enable,
                                    vlan_vid=out_vlan_no,
                                    ip_ttl=64,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni,
                                    inner_frame=inner_pkt))
        else:
            vxlan_pkt = Mask(
                simple_vxlanv6_packet(eth_dst=pkt_data["unbor_mac"],
                                      eth_src=ROUTER_MAC,
                                      ipv6_dst=pkt_data["tun_ip"],
                                      ipv6_src=self.lpb_ip,
                                      dl_vlan_enable=out_vlan_enable,
                                      vlan_vid=out_vlan_no,
                                      ipv6_hlim=64,
                                      with_udp_chksum=False,
                                      vxlan_vni=self.vni,
                                      inner_frame=inner_pkt))
        vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

        print("Sending IPv6 packet: port %d -> %s"
              % (src_port, dst_ports))
        send_packet(self, src_port, pkt)
        verify_packet_any_port(self, vxlan_pkt, dst_ports)
        print("\tOK")

    def _v4DecapTest(self, src_port, dst_ports, pkt_data, vlan_no=None):
        '''
        A helper function for checking IPv4 packets decapsulation

        Args:
            src_port (int): an underlay device port number
            dst_ports (list_or_int): a list with overlay destination
                                     device port number(s)
            pkt_data (dict): a dictionary with necessary packets data
                             required keys are:
                                 customer_mac - customer MAC
                                 customer_ip - customer IP
                                 vm_ip - VM IP
                                 unbor_mac - underlay neighbour MAC
                                 tun_ip - tunnel IP
            vlan_no (dict): a dictionary with VLAN numbers; allowed keys:
                                in - input (underlay port) VLAN number
                                out - output (overlay port) VLAN number
        '''
        in_vlan_enable = False
        in_vlan_no = 0
        if "in" in vlan_no:
            in_vlan_no = vlan_no["in"]
            in_vlan_enable = True if in_vlan_no else False

        out_vlan_enable = False
        out_vlan_no = 0
        out_len_inc = 0
        if "out" in vlan_no:
            out_vlan_no = vlan_no["out"]
            out_vlan_enable = True if out_vlan_no else False
            out_len_inc = 4 if out_vlan_enable else 0

        pkt = simple_udp_packet(eth_dst=pkt_data["customer_mac"],
                                eth_src=ROUTER_MAC,
                                ip_dst=pkt_data["customer_ip"],
                                ip_src=pkt_data["vm_ip"],
                                dl_vlan_enable=out_vlan_enable,
                                vlan_vid=out_vlan_no,
                                ip_id=108,
                                ip_ttl=63,
                                pktlen=100 + out_len_inc)
        inner_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                      eth_src=self.inner_dmac,
                                      ip_dst=pkt_data["customer_ip"],
                                      ip_src=pkt_data["vm_ip"],
                                      ip_id=108,
                                      ip_ttl=64,
                                      pktlen=100)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=pkt_data["unbor_mac"],
                                            ip_dst=self.lpb_ip,
                                            ip_src=pkt_data["tun_ip"],
                                            ip_id=0,
                                            dl_vlan_enable=in_vlan_enable,
                                            vlan_vid=in_vlan_no,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=pkt_data["unbor_mac"],
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=pkt_data["tun_ip"],
                                              dl_vlan_enable=in_vlan_enable,
                                              vlan_vid=in_vlan_no,
                                              ipv6_hlim=64,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Sending %s VxLAN packet with IPv4 inner packet: port%d -> %s"
              % ("IPv6" if self.ipv6 else "IPv4", src_port, dst_ports))
        send_packet(self, src_port, vxlan_pkt)
        verify_packet_any_port(self, pkt, dst_ports)
        print("\tOK")

    def _v6DecapTest(self, src_port, dst_ports, pkt_data, vlan_no=None):
        '''
        A helper function for checking IPv6 packets decapsulation

        Args:
            src_port (int): an underlay device port number
            dst_ports (list_or_int): a list with overlay destination
                                     device port number(s)
            pkt_data (dict): a dictionary with necessary packets data
                             required keys are:
                                 customer_mac - customer MAC
                                 customer_ipv6 - customer IPv6
                                 vm_ipv6 - VM IPv6
                                 unbor_mac - underlay neighbour MAC
                                 tun_ip - tunnel IP
            vlan_no (dict): a dictionary with VLAN numbers; allowed keys:
                                in - input (underlay port) VLAN number
                                out - output (overlay port) VLAN number
        '''
        in_vlan_enable = False
        in_vlan_no = 0
        if "in" in vlan_no:
            in_vlan_no = vlan_no["in"]
            in_vlan_enable = True if in_vlan_no else False

        out_vlan_enable = False
        out_vlan_no = 0
        out_len_inc = 0
        if "out" in vlan_no:
            out_vlan_no = vlan_no["out"]
            out_vlan_enable = True if out_vlan_no else False
            out_len_inc = 4 if out_vlan_enable else 0

        pkt = simple_udpv6_packet(eth_dst=pkt_data["customer_mac"],
                                  eth_src=ROUTER_MAC,
                                  ipv6_dst=pkt_data["customer_ipv6"],
                                  ipv6_src=pkt_data["vm_ipv6"],
                                  dl_vlan_enable=out_vlan_enable,
                                  vlan_vid=out_vlan_no,
                                  ipv6_hlim=63,
                                  pktlen=100 + out_len_inc)
        inner_pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.inner_dmac,
                                        ipv6_dst=pkt_data["customer_ipv6"],
                                        ipv6_src=pkt_data["vm_ipv6"],
                                        ipv6_hlim=64,
                                        pktlen=100)
        if self.ipv6 is False:
            vxlan_pkt = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                            eth_src=pkt_data["unbor_mac"],
                                            ip_dst=self.lpb_ip,
                                            ip_src=pkt_data["tun_ip"],
                                            ip_id=0,
                                            dl_vlan_enable=in_vlan_enable,
                                            vlan_vid=in_vlan_no,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt)
        else:
            vxlan_pkt = simple_vxlanv6_packet(eth_dst=ROUTER_MAC,
                                              eth_src=pkt_data["unbor_mac"],
                                              ipv6_dst=self.lpb_ip,
                                              ipv6_src=pkt_data["tun_ip"],
                                              dl_vlan_enable=in_vlan_enable,
                                              vlan_vid=in_vlan_no,
                                              ipv6_hlim=64,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt)

        print("Sending %s VxLAN packet with IPv6 inner packet: port%d -> %s"
              % ("IPv6" if self.ipv6 else "IPv4", src_port, dst_ports))
        send_packet(self, src_port, vxlan_pkt)
        verify_packet_any_port(self, pkt, dst_ports)
        print("\tOK")

    def _verifyEncap(self, oports, uports, customer_data, underlay_data):
        '''
        A helper function for preparing data for encapsulation verification

        Args:
            oports (list_or_int): overlay port number(s)
            uports (list_or_int): underlay port number(s)
            customer_data (dict): a dictionary with overlay (customer) data
                                  required keys are:
                                      oname - overlay RIF name
                                      customer_mac - customer MAC
                                      customer_ip - customer IP
                                      customer_ipv6 - customer IPv6
                                      vlan_no - (if required) VLAN number
            underlay_data (dict): a dictionary with underlay (VM) data
                                  required keys are:
                                      uname - underlay RIF name
                                      unbor_mac - customer MAC
                                      vm_ip - VM IP
                                      vm_ipv6 - VM IPv6
                                      tun_ip - tunnel IP
                                      vlan_no - (if required) VLAN number
        '''
        customer_data = customer_data.copy()
        for key in list(customer_data.keys()):
            if key not in ["oname", "customer_mac", "customer_ip",
                           "customer_ipv6", "vlan_no"]:
                customer_data.pop(key)

        underlay_data = underlay_data.copy()
        for key in list(underlay_data.keys()):
            if key not in ["uname", "unbor_mac", "vm_ip", "vm_ipv6",
                           "tun_ip", "vlan_no"]:
                underlay_data.pop(key)

        print("Verifying encap on RIF pair: %s <-> %s"
              % (customer_data.pop("oname"), underlay_data.pop("uname")))

        in_vlan_no = 0
        if "vlan_no" in customer_data:
            in_vlan_no = customer_data.pop("vlan_no")

        out_vlan_no = 0
        if "vlan_no" in underlay_data:
            out_vlan_no = underlay_data.pop("vlan_no")

        if not isinstance(oports, list):
            oports = [oports]

        if not isinstance(uports, list):
            uports = [uports]

        for i, oport in enumerate(oports):
            if not isinstance(oport, list):
                if not isinstance(uports[0], list):
                    pkt_data = dict(list(customer_data.items()) +
                                    list(underlay_data.items()))
                    self._v4EncapTest(oport, uports, pkt_data,
                                      {"in": in_vlan_no,
                                       "out": out_vlan_no})
                    self._v6EncapTest(oport, uports, pkt_data,
                                      {"in": in_vlan_no,
                                       "out": out_vlan_no})
                else:
                    for j, uport in enumerate(uports):
                        case_udata = {}
                        for key in underlay_data:
                            case_udata[key] = underlay_data[key][j]

                        pkt_data = dict(list(customer_data.items()) +
                                        list(case_udata.items()))
                        self._v4EncapTest(oport, uport, pkt_data,
                                          {"in": in_vlan_no,
                                           "out": out_vlan_no[j]})
                        self._v6EncapTest(oport, uport, pkt_data,
                                          {"in": in_vlan_no,
                                           "out": out_vlan_no[j]})
                continue

            for src_oport in oport:
                case_odata = {}
                for key in customer_data:
                    case_odata[key] = customer_data[key][i]

                if not isinstance(uports[0], list):
                    pkt_data = dict(list(case_odata.items()) +
                                    list(underlay_data.items()))
                    self._v4EncapTest(src_oport, uports, pkt_data,
                                      {"in": in_vlan_no[i],
                                       "out": out_vlan_no})
                    self._v6EncapTest(src_oport, uports, pkt_data,
                                      {"in": in_vlan_no[i],
                                       "out": out_vlan_no})
                else:
                    for j, uport in enumerate(uports):
                        case_udata = {}
                        for key in underlay_data:
                            case_udata[key] = underlay_data[key][j]

                        pkt_data = dict(list(case_odata.items()) +
                                        list(case_udata.items()))
                        self._v4EncapTest(src_oport, uport, pkt_data,
                                          {"in": in_vlan_no[i],
                                           "out": out_vlan_no[j]})
                        self._v6EncapTest(src_oport, uport, pkt_data,
                                          {"in": in_vlan_no[i],
                                           "out": out_vlan_no[j]})

    def _verifyDecap(self, oports, uports, customer_data, underlay_data):
        '''
        A helper function for preparing data for encapsulation verification

        Args:
            oports (list_or_int): overlay port number(s)
            uports (list_or_int): underlay port number(s)
            customer_data (dict): a dictionary with overlay (customer) data
                                  required keys are:
                                      oname - overlay RIF name
                                      customer_mac - customer MAC
                                      customer_ip - customer IP
                                      customer_ipv6 - customer IPv6
                                      vlan_no - (if required) VLAN number
            underlay_data (dict): a dictionary with underlay (VM) data
                                  required keys are:
                                      uname - underlay RIF name
                                      unbor_mac - customer MAC
                                      vm_ip - VM IP
                                      vm_ipv6 - VM IPv6
                                      tun_ip - tunnel IP
                                      vlan_no - (if required) VLAN number
        '''
        customer_data = customer_data.copy()
        for key in list(customer_data.keys()):
            if key not in ["oname", "customer_mac", "customer_ip",
                           "customer_ipv6", "vlan_no"]:
                customer_data.pop(key)

        underlay_data = underlay_data.copy()
        for key in list(underlay_data.keys()):
            if key not in ["uname", "unbor_mac", "vm_ip", "vm_ipv6",
                           "vlan_no", "tun_ip"]:
                underlay_data.pop(key)

        print("Verifying decap on RIF pair: %s <-> %s"
              % (underlay_data.pop("uname"), customer_data.pop("oname")))

        in_vlan_no = 0
        if "vlan_no" in underlay_data:
            in_vlan_no = underlay_data.pop("vlan_no")

        out_vlan_no = 0
        if "vlan_no" in customer_data:
            out_vlan_no = customer_data.pop("vlan_no")

        if not isinstance(oports, list):
            oports = [oports]

        if not isinstance(uports, list):
            uports = [uports]

        for i, uport in enumerate(uports):
            if not isinstance(uport, list):
                if not isinstance(oports[0], list):
                    pkt_data = dict(list(customer_data.items()) +
                                    list(underlay_data.items()))
                    self._v4DecapTest(uport, oports, pkt_data,
                                      {"in": in_vlan_no,
                                       "out": out_vlan_no})
                    self._v6DecapTest(uport, oports, pkt_data,
                                      {"in": in_vlan_no,
                                       "out": out_vlan_no})
                else:
                    for j, oport in enumerate(oports):
                        case_odata = {}
                        for key in customer_data:
                            case_odata[key] = customer_data[key][j]

                        pkt_data = dict(list(case_odata.items()) +
                                        list(underlay_data.items()))
                        self._v4DecapTest(uport, oport, pkt_data,
                                          {"in": in_vlan_no,
                                           "out": out_vlan_no[j]})
                        self._v6DecapTest(uport, oport, pkt_data,
                                          {"in": in_vlan_no,
                                           "out": out_vlan_no[j]})
                continue

            for src_uport in uport:
                case_udata = {}
                for key, value in underlay_data.items():
                    case_udata[key] = value[i] if isinstance(value, list) \
                        else value

                if not isinstance(oports[0], list):
                    pkt_data = dict(list(customer_data.items()) +
                                    list(case_udata.items()))
                    self._v4DecapTest(src_uport, oports, pkt_data,
                                      {"in": in_vlan_no[i],
                                       "out": out_vlan_no})
                    self._v6DecapTest(src_uport, oports, pkt_data,
                                      {"in": in_vlan_no[i],
                                       "out": out_vlan_no})
                else:
                    for j, oport in enumerate(oports):
                        case_odata = {}
                        for key in customer_data:
                            case_odata[key] = customer_data[key][j]

                        pkt_data = dict(list(case_odata.items()) +
                                        list(case_udata.items()))
                        self._v4DecapTest(src_uport, oport, pkt_data,
                                          {"in": in_vlan_no[i],
                                           "out": out_vlan_no[j]})
                        self._v6DecapTest(src_uport, oport, pkt_data,
                                          {"in": in_vlan_no[i],
                                           "out": out_vlan_no[j]})

    def _v4EcmpEncapTest(self, src_port, dst_ports, customer_data,
                         underlay_data):
        '''
        A helper function for checking IPv4 packets encapsulation with underlay
        ECMP

        Args:
            src_port (int): an overlay device port number
            dst_ports (list): a list of underlay destination ECMP device port
                              numbers
            customer_data (dict): a dictionary with overlay (customer) data
                                  required keys are:
                                      customer_mac - customer MAC
                                      customer_ip - customer IP
                                      vlan_no - (if required) VLAN number
            underlay_data (list): a list of dictionaries with underlay (VM)
                                  data; required keys are:
                                      unbor_mac - underlay neighbour MAC
                                      vm_ip - VM IP
                                      tun_ip - tunnel IP
                                      vlan_no - (if required) VLAN number
        '''
        customer_data = customer_data.copy()
        for key in list(customer_data.keys()):
            if key not in ["customer_mac", "customer_ip", "vlan_no"]:
                customer_data.pop(key)

        for udata in underlay_data:
            udata = udata.copy()
            for key in list(udata.keys()):
                if key not in ["unbor_mac", "vm_ip", "tun_ip", "vlan_no"]:
                    udata.pop(key)

        in_vlan_enable = False
        in_vlan_no = 0
        in_len_inc = 0
        if "vlan_no" in customer_data:
            in_vlan_no = customer_data["vlan_no"]
            in_vlan_enable = True if in_vlan_no else False
            in_len_inc = 4 if in_vlan_enable else 0

        for udata in underlay_data:
            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=customer_data["customer_mac"],
                                    ip_dst=udata["vm_ip"],
                                    ip_src=customer_data["customer_ip"],
                                    ip_id=108,
                                    dl_vlan_enable=in_vlan_enable,
                                    vlan_vid=in_vlan_no,
                                    ip_ttl=64,
                                    pktlen=100 + in_len_inc)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=udata["vm_ip"],
                                          ip_src=customer_data["customer_ip"],
                                          ip_id=108,
                                          ip_ttl=63,
                                          pktlen=100)

            rcv_pkt_list = []
            for rcv_udata in underlay_data:
                out_vlan_enable = False
                out_vlan_no = 0
                if "vlan_no" in rcv_udata:
                    out_vlan_no = rcv_udata["vlan_no"]
                    out_vlan_enable = True if out_vlan_no else False

                if self.ipv6 is False:
                    vxlan_pkt = Mask(
                        simple_vxlan_packet(eth_dst=rcv_udata["unbor_mac"],
                                            eth_src=ROUTER_MAC,
                                            ip_dst=udata["tun_ip"],
                                            ip_src=self.lpb_ip,
                                            ip_id=0,
                                            dl_vlan_enable=out_vlan_enable,
                                            vlan_vid=out_vlan_no,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt))
                else:
                    vxlan_pkt = Mask(
                        simple_vxlanv6_packet(eth_dst=rcv_udata["unbor_mac"],
                                              eth_src=ROUTER_MAC,
                                              ipv6_dst=udata["tun_ip"],
                                              ipv6_src=self.lpb_ip,
                                              dl_vlan_enable=out_vlan_enable,
                                              vlan_vid=out_vlan_no,
                                              ipv6_hlim=64,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt))
                vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')
                rcv_pkt_list.append(vxlan_pkt)

            print("Sending IPv4 packet port %d -> %s ECMP"
                  % (src_port, udata["vm_ip"]))
            send_packet(self, src_port, pkt)
            verify_any_packet_any_port(self, rcv_pkt_list, dst_ports)
            print("\tOK")

    def _v6EcmpEncapTest(self, src_port, dst_ports, customer_data,
                         underlay_data):
        '''
        A helper function for checking IPv6 packets encapsulation with underlay
        ECMP

        Args:
            src_port (int): an overlay device port number
            dst_ports (list): a list of underlay destination ECMP device port
                              numbers
            customer_data (dict): a dictionary with overlay (customer) data
                                  required keys are:
                                      customer_mac - customer MAC
                                      customer_ipv6 - customer IP
                                      vlan_no - (if required) VLAN number
            underlay_data (list): a list of dictionaries with underlay (VM)
                                  data; required keys are:
                                      unbor_mac - underlay neighbour MAC
                                      vm_ipv6 - VM IP
                                      tun_ip - tunnel IP
                                      vlan_no - (if required) VLAN number
        '''
        customer_data = customer_data.copy()
        for key in list(customer_data.keys()):
            if key not in ["customer_mac", "customer_ip", "customer_ipv6",
                           "vlan_no"]:
                customer_data.pop(key)

        for udata in underlay_data:
            udata = udata.copy()
            for key in list(udata.keys()):
                if key not in ["unbor_mac", "vm_ip", "vm_ipv6", "tun_ip",
                               "vlan_no"]:
                    udata.pop(key)

        in_vlan_enable = False
        in_vlan_no = 0
        in_len_inc = 0
        if "vlan_no" in customer_data:
            in_vlan_no = customer_data["vlan_no"]
            in_vlan_enable = True if in_vlan_no else False
            in_len_inc = 4 if in_vlan_enable else 0

        for udata in underlay_data:
            pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                      eth_src=customer_data["customer_mac"],
                                      ipv6_dst=udata["vm_ipv6"],
                                      ipv6_src=customer_data["customer_ipv6"],
                                      dl_vlan_enable=in_vlan_enable,
                                      vlan_vid=in_vlan_no,
                                      ipv6_hlim=64,
                                      pktlen=100 + in_len_inc)
            inner_pkt = simple_udpv6_packet(
                eth_dst=self.inner_dmac,
                eth_src=ROUTER_MAC,
                ipv6_dst=udata["vm_ipv6"],
                ipv6_src=customer_data["customer_ipv6"],
                ipv6_hlim=63,
                pktlen=100)

            rcv_pkt_list = []
            for rcv_udata in underlay_data:
                out_vlan_enable = False
                out_vlan_no = 0
                if "vlan_no" in rcv_udata:
                    out_vlan_no = rcv_udata["vlan_no"]
                    out_vlan_enable = True if out_vlan_no else False

                if self.ipv6 is False:
                    vxlan_pkt = Mask(
                        simple_vxlan_packet(eth_dst=rcv_udata["unbor_mac"],
                                            eth_src=ROUTER_MAC,
                                            ip_dst=udata["tun_ip"],
                                            ip_src=self.lpb_ip,
                                            ip_id=0,
                                            dl_vlan_enable=out_vlan_enable,
                                            vlan_vid=out_vlan_no,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt))
                else:
                    vxlan_pkt = Mask(
                        simple_vxlanv6_packet(eth_dst=rcv_udata["unbor_mac"],
                                              eth_src=ROUTER_MAC,
                                              ipv6_dst=udata["tun_ip"],
                                              ipv6_src=self.lpb_ip,
                                              dl_vlan_enable=out_vlan_enable,
                                              vlan_vid=out_vlan_no,
                                              ipv6_hlim=64,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt))
                vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')
                rcv_pkt_list.append(vxlan_pkt)

            print("Sending IPv6 packet port %d -> %s ECMP"
                  % (src_port, udata["vm_ipv6"]))
            send_packet(self, src_port, pkt)
            verify_any_packet_any_port(self, rcv_pkt_list, dst_ports)
            print("\tOK")

    def _v4OverlayEcmpEncapTest(self, src_port, dst_ports, customer_data,
                                underlay_data):
        '''
        A helper function for checking IPv4 packets encapsulation with overlay
        ECMP

        Args:
            src_port (int): an overlay device port number
            dst_ports (list): a list of underlay destination ECMP device port
                              numbers
            customer_data (dict): a dictionary with overlay (customer) data
                                  required keys are:
                                      customer_mac - customer MAC
                                      customer_ip - customer IP
                                      vm_ip - VM IP
                                      vlan_no - (if required) VLAN number
            underlay_data (list): a list of dictionaries with underlay (VM)
                                  data; required keys are:
                                      unbor_mac - underlay neighbour MAC
                                      tun_ip - tunnel IP
                                      vlan_no - (if required) VLAN number
        '''
        customer_data = customer_data.copy()
        for key in list(customer_data.keys()):
            if key not in ["customer_mac", "customer_ip", "vm_ip"]:
                customer_data.pop(key)

        for udata in underlay_data:
            udata = udata.copy()
            for key in list(udata.keys()):
                if key not in ["unbor_mac", "tun_ip", "vlan_no"]:
                    udata.pop(key)

        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=customer_data["customer_mac"],
                                ip_dst=customer_data["vm_ip"],
                                ip_src=customer_data["customer_ip"],
                                ip_id=108,
                                ip_ttl=64)
        inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=customer_data["vm_ip"],
                                      ip_src=customer_data["customer_ip"],
                                      ip_id=108,
                                      ip_ttl=63)

        rcv_pkt_list = []
        for udata in underlay_data:
            out_vlan_enable = False
            out_vlan_no = 0
            if "vlan_no" in udata:
                out_vlan_no = udata["vlan_no"]
                out_vlan_enable = True if out_vlan_no else False

            if self.ipv6 is False:
                vxlan_pkt = Mask(
                    simple_vxlan_packet(eth_dst=udata["unbor_mac"],
                                        eth_src=ROUTER_MAC,
                                        ip_dst=udata["tun_ip"],
                                        ip_src=self.lpb_ip,
                                        ip_id=0,
                                        dl_vlan_enable=out_vlan_enable,
                                        vlan_vid=out_vlan_no,
                                        ip_ttl=64,
                                        ip_flags=0x2,
                                        with_udp_chksum=False,
                                        vxlan_vni=self.vni,
                                        inner_frame=inner_pkt))
            else:
                vxlan_pkt = Mask(
                    simple_vxlanv6_packet(eth_dst=udata["unbor_mac"],
                                          eth_src=ROUTER_MAC,
                                          ipv6_dst=udata["tun_ip"],
                                          ipv6_src=self.lpb_ip,
                                          dl_vlan_enable=out_vlan_enable,
                                          vlan_vid=out_vlan_no,
                                          ipv6_hlim=64,
                                          with_udp_chksum=False,
                                          vxlan_vni=self.vni,
                                          inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')
            rcv_pkt_list.append(vxlan_pkt)

        print("Sending IPv4 packet port %d -> %s ECMP"
              % (src_port, udata["vm_ip"]))
        send_packet(self, src_port, pkt)
        verify_any_packet_any_port(self, rcv_pkt_list, dst_ports)
        print("\tOK")

    def _v6OverlayEcmpEncapTest(self, src_port, dst_ports, customer_data,
                                underlay_data):
        '''
        A helper function for checking IPv6 packets encapsulation with overlay
        ECMP

        Args:
            src_port (int): an overlay device port number
            dst_ports (list): a list of underlay destination ECMP device port
                              numbers
            customer_data (dict): a dictionary with overlay (customer) data
                                  required keys are:
                                      customer_mac - customer MAC
                                      customer_ipv6 - customer IPv6
                                      vm_ipv6 - VM IPv6
                                      vlan_no - (if required) VLAN number
            underlay_data (list): a list of dictionaries with underlay (VM)
                                  data; required keys are:
                                      unbor_mac - underlay neighbour MAC
                                      tun_ip - tunnel IP
                                      vlan_no - (if required) VLAN number
        '''
        customer_data = customer_data.copy()
        for key in list(customer_data.keys()):
            if key not in ["customer_mac", "customer_ipv6", "vm_ipv6"]:
                customer_data.pop(key)

        for udata in underlay_data:
            udata = udata.copy()
            for key in list(udata.keys()):
                if key not in ["unbor_mac", "tun_ip", "vlan_no"]:
                    udata.pop(key)

        pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                  eth_src=customer_data["customer_mac"],
                                  ipv6_dst=customer_data["vm_ipv6"],
                                  ipv6_src=customer_data["customer_ipv6"],
                                  ipv6_hlim=64)
        inner_pkt = simple_udpv6_packet(
            eth_dst=self.inner_dmac,
            eth_src=ROUTER_MAC,
            ipv6_dst=customer_data["vm_ipv6"],
            ipv6_src=customer_data["customer_ipv6"],
            ipv6_hlim=63)

        rcv_pkt_list = []
        for udata in underlay_data:
            out_vlan_enable = False
            out_vlan_no = 0
            if "vlan_no" in udata:
                out_vlan_no = udata["vlan_no"]
                out_vlan_enable = True if out_vlan_no else False

            if self.ipv6 is False:
                vxlan_pkt = Mask(
                    simple_vxlan_packet(eth_dst=udata["unbor_mac"],
                                        eth_src=ROUTER_MAC,
                                        ip_dst=udata["tun_ip"],
                                        ip_src=self.lpb_ip,
                                        ip_id=0,
                                        dl_vlan_enable=out_vlan_enable,
                                        vlan_vid=out_vlan_no,
                                        ip_ttl=64,
                                        ip_flags=0x2,
                                        with_udp_chksum=False,
                                        vxlan_vni=self.vni,
                                        inner_frame=inner_pkt))
            else:
                vxlan_pkt = Mask(
                    simple_vxlanv6_packet(eth_dst=udata["unbor_mac"],
                                          eth_src=ROUTER_MAC,
                                          ipv6_dst=udata["tun_ip"],
                                          ipv6_src=self.lpb_ip,
                                          dl_vlan_enable=out_vlan_enable,
                                          vlan_vid=out_vlan_no,
                                          ipv6_hlim=64,
                                          with_udp_chksum=False,
                                          vxlan_vni=self.vni,
                                          inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')
            rcv_pkt_list.append(vxlan_pkt)

        print("Sending IPv6 packet port %d -> %s ECMP"
              % (src_port, udata["vm_ipv6"]))
        send_packet(self, src_port, pkt)
        verify_any_packet_any_port(self, rcv_pkt_list, dst_ports)
        print("\tOK")

    def _v4BothEcmpEncapTest(self, src_port, dst_ports, customer_data,
                             underlay_data):
        '''
        A helper function for checking IPv4 packets encapsulation with overlay
        and underlay ECMP

        Args:
            src_port (int): an overlay device port number
            dst_ports (list): a list of underlay destination ECMP device port
                              numbers
            customer_data (dict): a dictionary with overlay (customer) data
                                  required keys are:
                                      customer_mac - customer MAC
                                      customer_ip - customer IP
                                      vm_ip - VM IP
                                      vlan_no - (if required) VLAN number
            underlay_data (list): a list of dictionaries with underlay (VM)
                                  data; required keys are:
                                      unbor_mac - underlay neighbour MAC
                                      tun_ip - tunnel IP
                                      vlan_no - (if required) VLAN number
        '''
        customer_data = customer_data.copy()
        for key in list(customer_data.keys()):
            if key not in ["customer_mac", "customer_ip", "vm_ip"]:
                customer_data.pop(key)

        for udata in underlay_data:
            udata = udata.copy()
            for key in list(udata.keys()):
                if key not in ["unbor_mac", "tun_ip", "vlan_no"]:
                    udata.pop(key)

        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src=customer_data["customer_mac"],
                                ip_dst=customer_data["vm_ip"],
                                ip_src=customer_data["customer_ip"],
                                ip_id=108,
                                ip_ttl=64)
        inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=customer_data["vm_ip"],
                                      ip_src=customer_data["customer_ip"],
                                      ip_id=108,
                                      ip_ttl=63)

        rcv_pkt_list = []
        for udata in underlay_data:
            out_vlan_enable = False
            out_vlan_no = 0
            if "vlan_no" in udata:
                out_vlan_no = udata["vlan_no"]
                out_vlan_enable = True if out_vlan_no else False

            for rcv_udata in underlay_data:
                if self.ipv6 is False:
                    vxlan_pkt = Mask(
                        simple_vxlan_packet(eth_dst=udata["unbor_mac"],
                                            eth_src=ROUTER_MAC,
                                            ip_dst=rcv_udata["tun_ip"],
                                            ip_src=self.lpb_ip,
                                            ip_id=0,
                                            dl_vlan_enable=out_vlan_enable,
                                            vlan_vid=out_vlan_no,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt))
                else:
                    vxlan_pkt = Mask(
                        simple_vxlanv6_packet(eth_dst=udata["unbor_mac"],
                                              eth_src=ROUTER_MAC,
                                              ipv6_dst=rcv_udata["tun_ip"],
                                              ipv6_src=self.lpb_ip,
                                              dl_vlan_enable=out_vlan_enable,
                                              vlan_vid=out_vlan_no,
                                              ipv6_hlim=64,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt))
                vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')
                rcv_pkt_list.append(vxlan_pkt)

        print("Sending IPv4 packet port %d -> %s ECMP"
              % (src_port, udata["vm_ip"]))
        send_packet(self, src_port, pkt)
        verify_any_packet_any_port(self, rcv_pkt_list, dst_ports)
        print("\tOK")

    def _v6BothEcmpEncapTest(self, src_port, dst_ports, customer_data,
                             underlay_data):
        '''
        A helper function for checking IPv6 packets encapsulation with overlay
        and underlay ECMP

        Args:
            src_port (int): an overlay device port number
            dst_ports (list): a list of underlay destination ECMP device port
                              numbers
            customer_data (dict): a dictionary with overlay (customer) data
                                  required keys are:
                                      customer_mac - customer MAC
                                      customer_ipv6 - customer IPv6
                                      vm_ipv6 - VM IPv6
                                      vlan_no - (if required) VLAN number
            underlay_data (list): a list of dictionaries with underlay (VM)
                                  data; required keys are:
                                      unbor_mac - underlay neighbour MAC
                                      tun_ip - tunnel IP
                                      vlan_no - (if required) VLAN number
        '''
        customer_data = customer_data.copy()
        for key in list(customer_data.keys()):
            if key not in ["customer_mac", "customer_ipv6", "vm_ipv6"]:
                customer_data.pop(key)

        for udata in underlay_data:
            udata = udata.copy()
            for key in list(udata.keys()):
                if key not in ["unbor_mac", "tun_ip", "vlan_no"]:
                    udata.pop(key)

        pkt = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                  eth_src=customer_data["customer_mac"],
                                  ipv6_dst=customer_data["vm_ipv6"],
                                  ipv6_src=customer_data["customer_ipv6"],
                                  ipv6_hlim=64)
        inner_pkt = simple_udpv6_packet(
            eth_dst=self.inner_dmac,
            eth_src=ROUTER_MAC,
            ipv6_dst=customer_data["vm_ipv6"],
            ipv6_src=customer_data["customer_ipv6"],
            ipv6_hlim=63)

        rcv_pkt_list = []
        for udata in underlay_data:
            out_vlan_enable = False
            out_vlan_no = 0
            if "vlan_no" in udata:
                out_vlan_no = udata["vlan_no"]
                out_vlan_enable = True if out_vlan_no else False

            for rcv_udata in underlay_data:
                if self.ipv6 is False:
                    vxlan_pkt = Mask(
                        simple_vxlan_packet(eth_dst=udata["unbor_mac"],
                                            eth_src=ROUTER_MAC,
                                            ip_dst=rcv_udata["tun_ip"],
                                            ip_src=self.lpb_ip,
                                            ip_id=0,
                                            dl_vlan_enable=out_vlan_enable,
                                            vlan_vid=out_vlan_no,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt))
                else:
                    vxlan_pkt = Mask(
                        simple_vxlanv6_packet(eth_dst=udata["unbor_mac"],
                                              eth_src=ROUTER_MAC,
                                              ipv6_dst=rcv_udata["tun_ip"],
                                              ipv6_src=self.lpb_ip,
                                              dl_vlan_enable=out_vlan_enable,
                                              vlan_vid=out_vlan_no,
                                              ipv6_hlim=64,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt))
                vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')
                rcv_pkt_list.append(vxlan_pkt)

        print("Sending IPv6 packet port %d -> %s ECMP"
              % (src_port, udata["vm_ipv6"]))
        send_packet(self, src_port, pkt)
        verify_any_packet_any_port(self, rcv_pkt_list, dst_ports)
        print("\tOK")

    def _verifyEcmpEncap(self, src_port, dst_ports, pkt_data, mode=None):
        '''
        A helper function for preparing data for encapsulation verification
        with underlay ECMP

        Args:
            src_port (int_or_list): an overlay device port number(s)
            dst_ports (list): a list of underlay destination ECMP device port
                              numbers
            pkt_data (list): a list with overlay and underlay data:
                customer_data (dict): a dictionary with overlay (customer) data
                                      required keys are:
                                        customer_mac - customer MAC
                                        customer_ip - customer IP
                                        vlan_no - (if required) VLAN number
                underlay_data (list): a list of dictionaries with underlay (VM)
                                      data; required keys are:
                                        unbor_mac - underlay neighbour MAC
                                        vm_ip - VM IP
                                        tun_ip - tunnel IP
                                        vlan_no - (if required) VLAN number
            mode (str): ECMP verification mode:
                            "overlay" - for overlay ECMP configured
                            "both" - for overlay and underlay ECMP configured
        '''
        customer_data = pkt_data[0]
        underlay_data = pkt_data[1]

        underlay_data = self._prepareUnderlayData(underlay_data)
        dst_ports = self._prepareDstPortList(dst_ports)

        v4_encap_checker = self._v4EcmpEncapTest
        v6_encap_checker = self._v6EcmpEncapTest

        if mode == "overlay":
            v4_encap_checker = self._v4OverlayEcmpEncapTest
            v6_encap_checker = self._v6OverlayEcmpEncapTest
        elif mode == "both":
            v4_encap_checker = self._v4BothEcmpEncapTest
            v6_encap_checker = self._v6BothEcmpEncapTest

        if not isinstance(src_port, list):  # L3 Port or Subport
            v4_encap_checker(src_port, dst_ports, customer_data, underlay_data)
            v6_encap_checker(src_port, dst_ports, customer_data, underlay_data)
        elif not isinstance(src_port[0], list):  # L3 LAG
            for port in src_port:
                v4_encap_checker(port, dst_ports, customer_data, underlay_data)
                v6_encap_checker(port, dst_ports, customer_data, underlay_data)
        else:  # SVI
            for i, sport in enumerate(src_port):
                odata = {}
                for key, value in customer_data.items():
                    if isinstance(value, list):
                        odata[key] = value[i]
                for port in sport:
                    v4_encap_checker(port, dst_ports, odata, underlay_data)
                    v6_encap_checker(port, dst_ports, odata, underlay_data)

    def _addDelEcmpMemberTest(self, oport, uports, pkt_data, member_list):
        '''
        A helper function for removing a random ECMP or adding given member
        from a passed list of ECMP members

        Args:
            oport (int): an overlay device port number
            uports (list): a list of underlay ECMP port numbers
            pkt_data (list): a list with overlay and underlay data:
                customer_data (dict): a dictionary with overlay (customer) data
                                      required keys are:
                                        customer_mac - customer MAC
                                        customer_ip - customer IP
                                        vlan_no - (if required) VLAN number
                underlay_data (list): a list of dictionaries with underlay (VM)
                                      data; required keys are:
                                        unbor_mac - underlay neighbour MAC
                                        vm_ip - VM IP
                                        tun_ip - tunnel IP
                                        vlan_no - (if required) VLAN number
            member_list (list): a list of ECMP members IDs
        '''
        print("Verifying ECMP member deletion and addition")

        odata = pkt_data[0]
        udata = pkt_data[1]

        underlay_ports = []
        for uport in uports:
            if not isinstance(uport, list):
                underlay_ports.append(uport)
            else:
                for port in uport:
                    if isinstance(port, list):
                        underlay_ports.append(port)
                    else:
                        underlay_ports.append(uport)
                        break

        underlay_data = self._prepareUnderlayData(udata)

        index = random.randrange(len(member_list))

        ecmp_id = sai_thrift_get_next_hop_group_member_attribute(
            self.client,
            member_list[index], next_hop_group_id=True)["next_hop_group_id"]
        nhop_id = sai_thrift_get_next_hop_group_member_attribute(
            self.client,
            member_list[index], next_hop_id=True)["next_hop_id"]

        print("Removing ECMP member")
        sai_thrift_remove_next_hop_group_member(self.client,
                                                member_list[index])

        member_list.pop(index)
        del_uport = underlay_ports.pop(index)
        del_udata = underlay_data.pop(index)

        self._verifyEcmpEncap(oport, underlay_ports, [odata, underlay_data])

        print("Adding ECMP member")

        ecmp_member = sai_thrift_create_next_hop_group_member(
            self.client, next_hop_group_id=ecmp_id, next_hop_id=nhop_id)

        member_list.insert(index, ecmp_member)
        underlay_ports.insert(index, del_uport)
        underlay_data.insert(index, del_udata)

        self._verifyEcmpEncap(oport, underlay_ports, [odata, underlay_data])

    def _loadBalancingTest(self, src_port, dst_ports, customer_data,
                           underlay_data):
        '''
        A helper function for ECMP load balancing verification

        Args:
            src_port (int): an overlay device port number
            dst_ports (list): a list of underlay destination ECMP device port
                              numbers
            customer_data (dict): a dictionary with overlay (customer) data
                                  required keys are:
                                      customer_mac - customer MAC
                                      customer_ip - customer IP
                                      vlan_no - (if required) VLAN number
            underlay_data (list): a list of dictionaries with underlay (VM)
                                  data; required keys are:
                                      unbor_mac - underlay neighbour MAC
                                      vm_ip - VM IP
                                      tun_ip - tunnel IP
                                      vlan_no - (if required) VLAN number
        '''
        print("Verifying ECMP load balancing")

        port_groups = self._determinePortGroups(dst_ports)

        underlay_data = self._prepareUnderlayData(underlay_data)
        dst_ports = self._prepareDstPortList(dst_ports)

        in_vlan_enable = False
        in_vlan_no = 0
        in_len_inc = 0
        if "vlan_no" in customer_data:
            in_vlan_no = customer_data["vlan_no"]
            in_vlan_enable = True if in_vlan_no else False
            in_len_inc = 4 if in_vlan_enable else 0

        # random underlay start data
        index = random.randrange(len(underlay_data))
        udata = underlay_data[index]
        dst_ip_addr = int(
            binascii.hexlify(
                socket.inet_aton(
                    udata["vm_ip"])), 16)
        src_ip_addr = int(binascii.hexlify(socket.inet_aton(
            customer_data["customer_ip"])), 16)

        rcv_count = [0] * len(dst_ports)
        max_itrs = 200
        for _ in range(max_itrs):
            dst_ip = socket.inet_ntoa(
                binascii.unhexlify(format(dst_ip_addr, "x").zfill(8)))
            src_ip = socket.inet_ntoa(
                binascii.unhexlify(format(src_ip_addr, "x").zfill(8)))
            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=customer_data["customer_mac"],
                                    ip_dst=dst_ip,
                                    ip_src=src_ip,
                                    ip_id=108,
                                    dl_vlan_enable=in_vlan_enable,
                                    vlan_vid=in_vlan_no,
                                    ip_ttl=64,
                                    pktlen=100 + in_len_inc)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=dst_ip,
                                          ip_src=src_ip,
                                          ip_id=108,
                                          ip_ttl=63,
                                          pktlen=100)

            rcv_pkt_list = []
            for rcv_udata in underlay_data:
                out_vlan_enable = False
                out_vlan_no = 0
                if "vlan_no" in rcv_udata:
                    out_vlan_no = rcv_udata["vlan_no"]
                    out_vlan_enable = True if out_vlan_no else False

                if self.ipv6 is False:
                    vxlan_pkt = Mask(
                        simple_vxlan_packet(eth_dst=rcv_udata["unbor_mac"],
                                            eth_src=ROUTER_MAC,
                                            ip_dst=udata["tun_ip"],
                                            ip_src=self.lpb_ip,
                                            ip_id=0,
                                            dl_vlan_enable=out_vlan_enable,
                                            vlan_vid=out_vlan_no,
                                            ip_ttl=64,
                                            ip_flags=0x2,
                                            with_udp_chksum=False,
                                            vxlan_vni=self.vni,
                                            inner_frame=inner_pkt))
                else:
                    vxlan_pkt = Mask(
                        simple_vxlanv6_packet(eth_dst=rcv_udata["unbor_mac"],
                                              eth_src=ROUTER_MAC,
                                              ipv6_dst=udata["tun_ip"],
                                              ipv6_src=self.lpb_ip,
                                              dl_vlan_enable=out_vlan_enable,
                                              vlan_vid=out_vlan_no,
                                              ipv6_hlim=64,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni,
                                              inner_frame=inner_pkt))
                vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')
                rcv_pkt_list.append(vxlan_pkt)

            dst_ip_addr += 1
            src_ip_addr += 1

            print("Sending IPv4 packet port %d -> %s ECMP"
                  % (src_port, dst_ip))
            send_packet(self, src_port, pkt)
            rcv_idx = verify_any_packet_any_port(self, rcv_pkt_list,
                                                 dst_ports)
            rcv_count[rcv_idx] += 1
            print("\tOK")

        count = [0] * (max(port_groups) + 1)

        for grp, counter in zip(port_groups, rcv_count):
            count[grp] += counter

        for counter in count:
            self.assertTrue(counter >= (max_itrs / len(count) * 0.6),
                            "ECMP paths not equally balanced")

    @classmethod
    def _prepareUnderlayData(cls, underlay_data):
        '''
        A helper function for preparing underlay data. It operates on a list
        of dictionaries and in case when some of them have a value of type list
        it brokes it into a list of dictionaries.

        Args:
            underlay_data (list): a list of dictionaries with underlay data

        Return:
            result: modified list of dicionaries with data corresponding to
                    particular ECMP members
        '''
        result = []
        for udata in underlay_data:
            if isinstance(udata["tun_ip"], list):
                for i in range(len(udata["tun_ip"])):
                    data = {}
                    for key, value in udata.items():
                        data[key] = value[i] if isinstance(value, list) \
                            else value
                    result.append(data)
            else:
                result.append(udata)

        return result

    @classmethod
    def _prepareDstPortList(cls, port_list):
        '''
        A helper function for preparing port list for ECMP verification.
        It flattens a list in case when it includes a list of lists
        (SVI interfaces).

        Args:
            port_list (list): a list of underlay port numbers

        Return:
            result: modified list of port numbers with ports corresponding to
                    particular ECMP members
        '''
        result = []
        for ports in port_list:
            if not isinstance(ports, list):
                result.append(ports)
            else:
                for port in ports:
                    if not isinstance(port, list):
                        result.append(port)
                    else:
                        result.extend(port)

        return result

    @classmethod
    def _determinePortGroups(cls, port_list):
        '''
        A helper function for determining if verified ports belong to some
        LAG groups as this is necessary for correct counter verification while
        load balancing is checked

        Args:
            port_list (list): an unmodified list of underlay port numbers
                              conataining ports grouped in LAGs or SVIs

        Return:
            port_groups: list of group numbers which says to what group given
                         port is belonging
        '''
        port_groups = []
        for i, port in enumerate(port_list):
            if not isinstance(port, list):  # L3 port or subport
                port_groups.append(i)
                i += 1
            else:
                if not isinstance(port[0], list):  # LAG
                    port_groups.extend([i] * len(port))
                    i += 1
                else:  # SVI
                    for subport in port:
                        if len(subport) == 1:  # L3 port or subport in SVI
                            port_groups.append(i)
                        else:  # LAG in SVI
                            port_groups.extend([i] * len(subport))
                        i += 1

        return port_groups


@group("draft")
class VxLanRifsConfigTunnelIpv4UnderlayOportsTest(VxLanRifsConfigBaseSetup):
    '''
    Multipoint-to-multipoint tunnel tests regarding different overlay-underlay
    interfaces configutrations with IPv4 underlay layer and different
    types of RIFs as an overlay ports: L3 Port, L3 LAG, L3 Subport,
    SVI: [Tagged & Untagged, Port & LAG]
    '''

    def setUp(self):
        super(VxLanRifsConfigTunnelIpv4UnderlayOportsTest, self).setUp()

        customer1_ip = "100.1.2.1"
        customer2_ip = "100.2.2.1"
        customer3_ip = "100.3.2.1"
        customer4_ips = ["100.41.2.1", "100.42.2.1",
                         "100.43.2.1", "100.44.2.1"]
        customer1_ipv6 = "2001:0db8::1:2:1"
        customer2_ipv6 = "2001:0db8::2:2:1"
        customer3_ipv6 = "2001:0db8::3:2:1"
        customer4_ipsv6 = ["2001:0db8::41:2:1", "2001:0db8::42:2:1",
                           "2001:0db8::43:2:1", "2001:0db8::44:2:1"]
        customer1_mac = "00:22:22:22:22:01"
        customer2_mac = "00:22:22:22:22:02"
        customer3_mac = "00:22:22:22:22:03"
        customer4_macs = ["00:22:22:22:22:41", "00:22:22:22:22:42",
                          "00:22:22:22:22:43", "00:22:22:22:22:44"]

        self.orif_list = []
        self.onhop_list = []
        self.onbor_list = []
        self.customer_route_list = []

        #########################
        # overlay configuration #
        #########################

        # orif1 - regular L3 port (port0)
        self.oport1 = self.port0
        self.oport1_dev = self.dev_port0

        self.odata1 = {"oname": "L3 Port",
                       "customer_mac": customer1_mac,
                       "customer_ip": customer1_ip,
                       "customer_ipv6": customer1_ipv6}

        orif, onhop, onbor, customer_route = self._configureOrif(self.oport1,
                                                                 self.odata1)

        self.orif_list.append(orif)
        self.onhop_list.extend(onhop)
        self.onbor_list.extend(onbor)
        self.customer_route_list.extend(customer_route)

        # orif2 - L3 subport (port1)
        self.oport2 = self.port1
        self.oport2_dev = self.dev_port1
        o2_vlan_no = 201

        self.odata2 = {"oname": "L3 Subport",
                       "customer_mac": customer2_mac,
                       "customer_ip": customer2_ip,
                       "customer_ipv6": customer2_ipv6,
                       "vlan_no": o2_vlan_no}

        orif, onhop, onbor, customer_route = self._configureOrif(
            self.oport2, self.odata2,
            rif_type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT)

        self.orif_list.append(orif)
        self.onhop_list.extend(onhop)
        self.onbor_list.extend(onbor)
        self.customer_route_list.extend(customer_route)

        # orif3 - L3 LAG (port2, port3)
        self.oports3 = [self.port2, self.port3]
        self.oports3_dev = [self.dev_port2, self.dev_port3]

        self.odata3 = {"oname": "L3 LAG",
                       "customer_mac": customer3_mac,
                       "customer_ip": customer3_ip,
                       "customer_ipv6": customer3_ipv6}

        self.olag1 = sai_thrift_create_lag(self.client)
        self.olag1_member1 = sai_thrift_create_lag_member(
            self.client, lag_id=self.olag1, port_id=self.oports3[0])
        self.olag1_member2 = sai_thrift_create_lag_member(
            self.client, lag_id=self.olag1, port_id=self.oports3[1])

        orif, onhop, onbor, customer_route = self._configureOrif(self.olag1,
                                                                 self.odata3)

        self.orif_list.append(orif)
        self.onhop_list.extend(onhop)
        self.onbor_list.extend(onbor)
        self.customer_route_list.extend(customer_route)

        # orif4 - SVI (port4, port5, [port6, port7], [port8, port9])
        # [untagged port, tagged port, untagged LAG, tagged LAG]
        self.oports4 = [self.port4, self.port5, [self.port6, self.port7],
                        [self.port8, self.port9]]
        self.oports4_dev = [[self.dev_port4], [self.dev_port5],
                            [self.dev_port6, self.dev_port7],
                            [self.dev_port8, self.dev_port9]]
        o4_vlan_no = 401

        self.odata4 = {"oname": "SVI",
                       "customer_mac": customer4_macs,
                       "customer_ip": customer4_ips,
                       "customer_ipv6": customer4_ipsv6,
                       "vlan_no": [0, o4_vlan_no, 0, o4_vlan_no]}

        self.olag2 = sai_thrift_create_lag(self.client)
        self.olag2_member1 = sai_thrift_create_lag_member(
            self.client, lag_id=self.olag2, port_id=self.oports4[2][0])
        self.olag2_member2 = sai_thrift_create_lag_member(
            self.client, lag_id=self.olag2, port_id=self.oports4[2][1])

        self.olag3 = sai_thrift_create_lag(self.client)
        self.olag3_member1 = sai_thrift_create_lag_member(
            self.client, lag_id=self.olag3, port_id=self.oports4[3][0])
        self.olag3_member2 = sai_thrift_create_lag_member(
            self.client, lag_id=self.olag3, port_id=self.oports4[3][1])

        self.oport_bp1 = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.oports4[0],
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.oport_bp2 = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.oports4[1],
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.olag2_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.olag2,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.olag3_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.olag3,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.ovlan = sai_thrift_create_vlan(self.client, vlan_id=o4_vlan_no)
        self.ovlan_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.ovlan,
            bridge_port_id=self.oport_bp1,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        sai_thrift_set_port_attribute(self.client, self.oports4[0],
                                      port_vlan_id=o4_vlan_no)
        self.ovlan_member2 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.ovlan,
            bridge_port_id=self.oport_bp2,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)
        self.ovlan_member3 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.ovlan,
            bridge_port_id=self.olag2_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        sai_thrift_set_lag_attribute(self.client, self.olag2,
                                     port_vlan_id=o4_vlan_no)
        self.ovlan_member4 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.ovlan,
            bridge_port_id=self.olag3_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        orif, onhops, onbors, customer_routes = self._configureOrif(
            self.ovlan, self.odata4, rif_type=SAI_ROUTER_INTERFACE_TYPE_VLAN,
            bridge_ports=[self.oport_bp1, self.oport_bp2,
                          self.olag2_bp, self.olag3_bp])

        self.orif_list.append(orif)
        self.onhop_list.extend(onhops)
        self.onbor_list.extend(onbors)
        self.customer_route_list.extend(customer_routes)

    def runTest(self):
        self.portsToPortsConfigTest()
        self.portsToEcmpConfigTest()
        self.portsToPortsEcmpConfigTest()

    def tearDown(self):
        sai_thrift_flush_fdb_entries(
            self.client, entry_type=SAI_FDB_FLUSH_ENTRY_TYPE_ALL)

        for customer_route, onbor, onhop in zip(
                self.customer_route_list, self.onbor_list, self.onhop_list):
            sai_thrift_remove_route_entry(self.client, customer_route)
            sai_thrift_remove_neighbor_entry(self.client, onbor)
            sai_thrift_remove_next_hop(self.client, onhop)

        for orif in self.orif_list:
            sai_thrift_remove_router_interface(self.client, orif)

        sai_thrift_remove_vlan_member(self.client, self.ovlan_member4)
        sai_thrift_set_lag_attribute(self.client, self.olag2, port_vlan_id=0)
        sai_thrift_remove_vlan_member(self.client, self.ovlan_member3)
        sai_thrift_remove_vlan_member(self.client, self.ovlan_member2)
        sai_thrift_set_port_attribute(self.client, self.oports4[0],
                                      port_vlan_id=0)
        sai_thrift_remove_vlan_member(self.client, self.ovlan_member1)
        sai_thrift_remove_vlan(self.client, self.ovlan)
        sai_thrift_remove_bridge_port(self.client, self.olag3_bp)
        sai_thrift_remove_bridge_port(self.client, self.olag2_bp)
        sai_thrift_remove_bridge_port(self.client, self.oport_bp2)
        sai_thrift_remove_bridge_port(self.client, self.oport_bp1)
        sai_thrift_remove_lag_member(self.client, self.olag3_member2)
        sai_thrift_remove_lag_member(self.client, self.olag3_member1)
        sai_thrift_remove_lag(self.client, self.olag3)
        sai_thrift_remove_lag_member(self.client, self.olag2_member2)
        sai_thrift_remove_lag_member(self.client, self.olag2_member1)
        sai_thrift_remove_lag(self.client, self.olag2)

        sai_thrift_remove_lag_member(self.client, self.olag1_member2)
        sai_thrift_remove_lag_member(self.client, self.olag1_member1)
        sai_thrift_remove_lag(self.client, self.olag1)

        super(VxLanRifsConfigTunnelIpv4UnderlayOportsTest, self).tearDown()

    def portsToPortsConfigTest(self):
        '''
        Verify tunnel encap/decap for following underlay configuration:
            L3 Port, L3 LAG, L3 Subport, SVI: [Tagged & Untagged, Port & LAG]
        '''
        print("\nportsToPortsConfigTest()")

        vm1_ip = "100.1.1.1"
        vm2_ip = "100.2.1.1"
        vm3_ip = "100.3.1.1"
        vm4_ips = ["100.41.1.1", "100.42.1.1", "100.43.1.1", "100.44.1.1"]
        vm1_ipv6 = "2001:0db8::1:1:1"
        vm2_ipv6 = "2001:0db8::2:1:1"
        vm3_ipv6 = "2001:0db8::3:1:1"
        vm4_ipsv6 = ["2001:0db8::41:1:1", "2001:0db8::42:1:1",
                     "2001:0db8::43:1:1", "2001:0db8::44:1:1"]
        tun_ip1 = "10.10.1.1"
        tun_ip2 = "10.10.2.1"
        tun_ip3 = "10.10.3.1"
        tun_ips4 = ["10.10.41.1", "10.10.42.1", "10.10.43.1", "10.10.44.1"]
        lpb_ip1 = "10.10.1.10"
        lpb_ip2 = "10.10.2.10"
        lpb_ip3 = "10.10.3.10"
        lpb_ips4 = ["10.10.41.10", "10.10.42.10", "10.10.43.10", "10.10.44.10"]
        unbor1_mac = "00:33:33:33:33:01"
        unbor2_mac = "00:33:33:33:33:02"
        unbor3_mac = "00:33:33:33:33:03"
        unbor4_macs = ["00:33:33:33:33:41", "00:33:33:33:33:42",
                       "00:33:33:33:33:43", "00:33:33:33:33:44"]

        urif_list = []
        unhop_list = []
        unbor_list = []
        tunnel_term_list = []
        tunnel_route_list = []
        tunnel_nhop_list = []
        vm_route_list = []

        try:
            ##########################
            # underlay configuration #
            ##########################

            # urif1 - regular L3 (port10)
            uport1 = self.port10
            uport1_dev = self.dev_port10

            udata1 = {"uname": "L3 Port",
                      "vm_ip": vm1_ip,
                      "vm_ipv6": vm1_ipv6,
                      "unbor_mac": unbor1_mac,
                      "tun_ip": tun_ip1,
                      "lpb_ip": lpb_ip1,
                      "tunnel_route": True,
                      "vm_route": True}

            urif, unhop, unbor, tunnel_nhop, vm_route, tunnel_term, \
                tunnel_route = self._configureUrif(uport1, udata1)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif2 - L3 subport (port11)
            uport2 = self.port11
            uport2_dev = self.dev_port11
            u2_vlan_no = 202

            udata2 = {"uname": "L3 Subport",
                      "vm_ip": vm2_ip,
                      "vm_ipv6": vm2_ipv6,
                      "unbor_mac": unbor2_mac,
                      "tun_ip": tun_ip2,
                      "lpb_ip": lpb_ip2,
                      "vlan_no": u2_vlan_no,
                      "tunnel_route": True,
                      "vm_route": True}

            urif, unhop, unbor, tunnel_nhop, vm_route, tunnel_term,\
                tunnel_route = self._configureUrif(
                    uport2, udata2,
                    rif_type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif3 - L3 LAG (port12, port13)
            uports3 = [self.port12, self.port13]
            uports3_dev = [self.dev_port12, self.dev_port13]

            udata3 = {"uname": "L3 LAG",
                      "vm_ip": vm3_ip,
                      "vm_ipv6": vm3_ipv6,
                      "unbor_mac": unbor3_mac,
                      "tun_ip": tun_ip3,
                      "lpb_ip": lpb_ip3,
                      "tunnel_route": True,
                      "vm_route": True}

            ulag1 = sai_thrift_create_lag(self.client)
            ulag1_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports3[0])
            ulag1_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports3[1])

            urif, unhop, unbor, tunnel_nhop, vm_route, tunnel_term, \
                tunnel_route = self._configureUrif(ulag1, udata3)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif4 - SVI (port14, port15, [port16, port17], [port18, port19])
            # (untagged port, tagged port, untagged LAG, tagged LAG)
            uports4 = [self.port14, self.port15, [self.port16, self.port17],
                       [self.port18, self.port19]]
            uports4_dev = [[self.dev_port14], [self.dev_port15],
                           [self.dev_port16, self.dev_port17],
                           [self.dev_port18, self.dev_port19]]
            u4_vlan_no = 402

            udata4 = {"uname": "SVI",
                      "vm_ip": vm4_ips,
                      "vm_ipv6": vm4_ipsv6,
                      "unbor_mac": unbor4_macs,
                      "tun_ip": tun_ips4,
                      "lpb_ip": lpb_ips4,
                      "vlan_no": [0, u4_vlan_no, 0, u4_vlan_no],
                      "tunnel_route": True,
                      "vm_route": True}

            ulag2 = sai_thrift_create_lag(self.client)
            ulag2_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports4[2][0])
            ulag2_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports4[2][1])

            ulag3 = sai_thrift_create_lag(self.client)
            ulag3_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports4[3][0])
            ulag3_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports4[3][1])

            uport_bp1 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports4[0],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uport_bp2 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports4[1],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag2_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag2,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag3_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag3,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uvlan = sai_thrift_create_vlan(self.client, vlan_id=u4_vlan_no)
            uvlan_member1 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp1,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_port_attribute(self.client, uports4[0],
                                          port_vlan_id=u4_vlan_no)
            uvlan_member2 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp2,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)
            uvlan_member3 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag2_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=u4_vlan_no)
            uvlan_member4 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag3_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

            urif, unhops, unbors, tunnel_nhops, vm_routes, tunnel_terms, \
                tunnel_routes = self._configureUrif(
                    uvlan, udata4,
                    bridge_ports=[uport_bp1, uport_bp2, ulag2_bp, ulag3_bp],
                    rif_type=SAI_ROUTER_INTERFACE_TYPE_VLAN)

            urif_list.append(urif)
            unhop_list.extend(unhops)
            unbor_list.extend(unbors)
            tunnel_nhop_list.extend(tunnel_nhops)
            vm_route_list.extend(vm_routes)
            tunnel_term_list.extend(tunnel_terms)
            tunnel_route_list.extend(tunnel_routes)

            for oport, odata in zip([self.oport1_dev, self.oport2_dev,
                                     self.oports3_dev, self.oports4_dev],
                                    [self.odata1, self.odata2,
                                     self.odata3, self.odata4]):
                for uport, udata in zip([uport1_dev, uport2_dev,
                                         uports3_dev, uports4_dev],
                                        [udata1, udata2, udata3, udata4]):
                    self._verifyEncap(oport, uport, odata, udata)
                    self._verifyDecap(oport, uport, odata, udata)

        finally:
            sai_thrift_flush_fdb_entries(
                self.client, entry_type=SAI_FDB_FLUSH_ENTRY_TYPE_ALL)

            for vm_route in vm_route_list:
                sai_thrift_remove_route_entry(self.client, vm_route)

            for tunnel_route, tunnel_term, tunnel_nhop, unbor, \
                unhop in zip(tunnel_route_list, tunnel_term_list,
                             tunnel_nhop_list, unbor_list,
                             unhop_list):
                sai_thrift_remove_route_entry(self.client, tunnel_route)
                sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                          tunnel_term)
                sai_thrift_remove_next_hop(self.client, tunnel_nhop)
                sai_thrift_remove_neighbor_entry(self.client, unbor)
                sai_thrift_remove_next_hop(self.client, unhop)

            for urif in urif_list:
                sai_thrift_remove_router_interface(self.client, urif)

            sai_thrift_remove_vlan_member(self.client, uvlan_member4)
            sai_thrift_set_lag_attribute(self.client, ulag2, port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member3)
            sai_thrift_set_port_attribute(self.client, uports4[0],
                                          port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member2)
            sai_thrift_remove_vlan_member(self.client, uvlan_member1)
            sai_thrift_remove_vlan(self.client, uvlan)
            sai_thrift_remove_bridge_port(self.client, ulag3_bp)
            sai_thrift_remove_bridge_port(self.client, ulag2_bp)
            sai_thrift_remove_bridge_port(self.client, uport_bp2)
            sai_thrift_remove_bridge_port(self.client, uport_bp1)
            sai_thrift_remove_lag_member(self.client, ulag3_member2)
            sai_thrift_remove_lag_member(self.client, ulag3_member1)
            sai_thrift_remove_lag(self.client, ulag3)
            sai_thrift_remove_lag_member(self.client, ulag2_member2)
            sai_thrift_remove_lag_member(self.client, ulag2_member1)
            sai_thrift_remove_lag(self.client, ulag2)

            sai_thrift_remove_lag_member(self.client, ulag1_member2)
            sai_thrift_remove_lag_member(self.client, ulag1_member1)
            sai_thrift_remove_lag(self.client, ulag1)

    def portsToEcmpConfigTest(self):
        '''
        Verify tunnel encap/decap for following underlay configuration:
            ECMP: (L3 Port, L3 Subport, L3LAG,  SVI: [Tagged & Untagged,
            Port & LAG])
        '''
        print("\nportsToEcmpConfigTest()")

        vm1_ip = "100.1.1.1"
        vm2_ip = "100.2.1.1"
        vm3_ip = "100.3.1.1"
        vm4_ips = ["100.41.1.1", "100.42.1.1", "100.43.1.1", "100.44.1.1"]
        vm1_ipv6 = "2001:0db8::1:1:1"
        vm2_ipv6 = "2001:0db8::2:1:1"
        vm3_ipv6 = "2001:0db8::3:1:1"
        vm4_ipsv6 = ["2001:0db8::41:1:1", "2001:0db8::42:1:1",
                     "2001:0db8::43:1:1", "2001:0db8::44:1:1"]
        tun_ip1 = "10.10.1.1"
        tun_ip2 = "10.10.2.1"
        tun_ip3 = "10.10.3.1"
        tun_ips4 = ["10.10.41.1", "10.10.42.1", "10.10.43.1", "10.10.44.1"]
        unbor1_mac = "00:33:33:33:33:01"
        unbor2_mac = "00:33:33:33:33:02"
        unbor3_mac = "00:33:33:33:33:03"
        unbor4_macs = ["00:33:33:33:33:41", "00:33:33:33:33:42",
                       "00:33:33:33:33:43", "00:33:33:33:33:44"]

        urif_list = []
        unhop_list = []
        unbor_list = []
        tunnel_nhop_list = []
        vm_route_list = []
        uecmp_member_list = []

        try:
            ##########################
            # underlay configuration #
            ##########################

            # urif1 - regular L3 (port10)
            uport1 = self.port10
            uport1_dev = self.dev_port10

            udata1 = {"uname": "L3 Port",
                      "vm_ip": vm1_ip,
                      "vm_ipv6": vm1_ipv6,
                      "unbor_mac": unbor1_mac,
                      "tun_ip": tun_ip1,
                      "tunnel_route": False,
                      "vm_route": True}

            urif, unhop, unbor, tunnel_nhop, vm_route, _, _ = \
                self._configureUrif(uport1, udata1)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)

            # urif2 - L3 subport (port11)
            uport2 = self.port11
            uport2_dev = self.dev_port11
            u2_vlan_no = 202

            udata2 = {"uname": "L3 Subport",
                      "vm_ip": vm2_ip,
                      "vm_ipv6": vm2_ipv6,
                      "unbor_mac": unbor2_mac,
                      "tun_ip": tun_ip2,
                      "vlan_no": u2_vlan_no,
                      "tunnel_route": False,
                      "vm_route": True}

            urif, unhop, unbor, tunnel_nhop, vm_route, _, _ = \
                self._configureUrif(
                    uport2, udata2,
                    rif_type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)

            # urif3 - L3 LAG (port12, port13)
            uports3 = [self.port12, self.port13]
            uports3_dev = [self.dev_port12, self.dev_port13]

            udata3 = {"uname": "L3 LAG",
                      "vm_ip": vm3_ip,
                      "vm_ipv6": vm3_ipv6,
                      "unbor_mac": unbor3_mac,
                      "tun_ip": tun_ip3,
                      "tunnel_route": False,
                      "vm_route": True}

            ulag1 = sai_thrift_create_lag(self.client)
            ulag1_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports3[0])
            ulag1_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports3[1])

            urif, unhop, unbor, tunnel_nhop, vm_route, _, _ = \
                self._configureUrif(ulag1, udata3)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)

            # urif4 - SVI (port14, port15, [port16, port17], [port18, port19])
            # (untagged port, tagged port, untagged LAG, tagged LAG)
            uports4 = [self.port14, self.port15, [self.port16, self.port17],
                       [self.port18, self.port19]]
            uports4_dev = [[self.dev_port14], [self.dev_port15],
                           [self.dev_port16, self.dev_port17],
                           [self.dev_port18, self.dev_port19]]
            u4_vlan_no = 402

            udata4 = {"uname": "SVI",
                      "vm_ip": vm4_ips,
                      "vm_ipv6": vm4_ipsv6,
                      "unbor_mac": unbor4_macs,
                      "tun_ip": tun_ips4,
                      "vlan_no": [0, u4_vlan_no, 0, u4_vlan_no],
                      "tunnel_route": False,
                      "vm_route": True}

            ulag2 = sai_thrift_create_lag(self.client)
            ulag2_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports4[2][0])
            ulag2_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports4[2][1])

            ulag3 = sai_thrift_create_lag(self.client)
            ulag3_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports4[3][0])
            ulag3_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports4[3][1])

            uport_bp1 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports4[0],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uport_bp2 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports4[1],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag2_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag2,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag3_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag3,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uvlan = sai_thrift_create_vlan(self.client, vlan_id=u4_vlan_no)
            uvlan_member1 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp1,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_port_attribute(self.client, uports4[0],
                                          port_vlan_id=u4_vlan_no)
            uvlan_member2 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp2,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)
            uvlan_member3 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag2_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=u4_vlan_no)
            uvlan_member4 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag3_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

            urif, unhops, unbors, tunnel_nhops, vm_routes, _, _ = \
                self._configureUrif(uvlan, udata4,
                                    bridge_ports=[uport_bp1, uport_bp2,
                                                  ulag2_bp, ulag3_bp],
                                    rif_type=SAI_ROUTER_INTERFACE_TYPE_VLAN)

            urif_list.append(urif)
            unhop_list.extend(unhops)
            unbor_list.extend(unbors)
            tunnel_nhop_list.extend(tunnel_nhops)
            vm_route_list.extend(vm_routes)

            uecmp = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            for unhop in unhop_list:
                uecmp_member = sai_thrift_create_next_hop_group_member(
                    self.client, next_hop_group_id=uecmp, next_hop_id=unhop)
                uecmp_member_list.append(uecmp_member)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(tun_ip1 + '/16'))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=uecmp)

            uports = [uport1_dev, uport2_dev, uports3_dev, uports4_dev]
            underlay_data = [udata1, udata2, udata3, udata4]
            oports = [self.oport1_dev, self.oport2_dev,
                      self.oports3_dev, self.oports4_dev]
            overlay_data = [self.odata1, self.odata2, self.odata3, self.odata4]

            for oport, odata in zip(oports, overlay_data):
                self._verifyEcmpEncap(oport, uports, [odata, underlay_data])

                for uport, udata in zip(uports, underlay_data):
                    self._verifyDecap(oport, uport, odata, udata)

            # random add/delete ECMP member verification
            index = random.randrange(len(oports))
            self._addDelEcmpMemberTest(oports[index], uports,
                                       [overlay_data[index], underlay_data],
                                       uecmp_member_list)

            # load balancing test
            self._loadBalancingTest(self.oport1_dev, uports,
                                    self.odata1, underlay_data)

        finally:
            sai_thrift_flush_fdb_entries(
                self.client, entry_type=SAI_FDB_FLUSH_ENTRY_TYPE_ALL)

            sai_thrift_remove_route_entry(self.client, tunnel_route)

            for vm_route in vm_route_list:
                sai_thrift_remove_route_entry(self.client, vm_route)

            for ecmp_member, tunnel_nhop, unbor, unhop in zip(
                    uecmp_member_list, tunnel_nhop_list, unbor_list,
                    unhop_list):
                sai_thrift_remove_next_hop_group_member(self.client,
                                                        ecmp_member)
                sai_thrift_remove_next_hop(self.client, tunnel_nhop)
                sai_thrift_remove_neighbor_entry(self.client, unbor)
                sai_thrift_remove_next_hop(self.client, unhop)

            sai_thrift_remove_next_hop_group(self.client, uecmp)

            for urif in urif_list:
                sai_thrift_remove_router_interface(self.client, urif)

            sai_thrift_remove_vlan_member(self.client, uvlan_member4)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member3)
            sai_thrift_set_port_attribute(self.client, uports4[0],
                                          port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member2)
            sai_thrift_remove_vlan_member(self.client, uvlan_member1)
            sai_thrift_remove_vlan(self.client, uvlan)
            sai_thrift_remove_bridge_port(self.client, ulag3_bp)
            sai_thrift_remove_bridge_port(self.client, ulag2_bp)
            sai_thrift_remove_bridge_port(self.client, uport_bp2)
            sai_thrift_remove_bridge_port(self.client, uport_bp1)
            sai_thrift_remove_lag_member(self.client, ulag3_member2)
            sai_thrift_remove_lag_member(self.client, ulag3_member1)
            sai_thrift_remove_lag(self.client, ulag3)
            sai_thrift_remove_lag_member(self.client, ulag2_member2)
            sai_thrift_remove_lag_member(self.client, ulag2_member1)
            sai_thrift_remove_lag(self.client, ulag2)

            sai_thrift_remove_lag_member(self.client, ulag1_member2)
            sai_thrift_remove_lag_member(self.client, ulag1_member1)
            sai_thrift_remove_lag(self.client, ulag1)

    def portsToPortsEcmpConfigTest(self):
        '''
        Verify tunnel encap/decap for following underlay configuration:
            ECMP of L3 Ports, L3 Subport, L3 LAG, SVI: [Tagged & Untagged,
            Port & LAG]
        '''
        print("\nportsToPortsEcmpConfigTest()")

        vm1_ip = "100.1.1.1"
        vm2_ip = "100.2.1.1"
        vm3_ip = "100.3.1.1"
        vm4_ip = "100.4.1.1"
        vm5_ip = "100.5.1.1"
        vm6_ips = ["100.61.1.1", "100.62.1.1", "100.63.1.1", "100.64.1.1"]
        vm1_ipv6 = "2001:0db8::1:1:1"
        vm2_ipv6 = "2001:0db8::2:1:1"
        vm3_ipv6 = "2001:0db8::3:1:1"
        vm4_ipv6 = "2001:0db8::4:1:1"
        vm5_ipv6 = "2001:0db8::5:1:1"
        vm6_ipsv6 = ["2001:0db8::61:1:1", "2001:0db8::62:1:1",
                     "2001:0db8::63:1:1", "2001:0db8::64:1:1"]
        tun_ip1 = "10.10.1.1"
        tun_ip2 = "10.10.2.1"
        tun_ip3 = "10.10.3.1"
        tun_ip4 = "10.10.4.1"
        tun_ip5 = "10.10.5.1"
        tun_ips6 = ["10.10.61.1", "10.10.62.1", "10.10.63.1", "10.10.64.1"]
        lpb_ip4 = "10.10.4.10"
        lpb_ip5 = "10.10.5.10"
        lpb_ips6 = ["10.10.61.10", "10.10.62.10", "10.10.63.10", "10.10.64.10"]
        unbor1_mac = "00:33:33:33:33:01"
        unbor2_mac = "00:33:33:33:33:02"
        unbor3_mac = "00:33:33:33:33:03"
        unbor4_mac = "00:33:33:33:33:04"
        unbor5_mac = "00:33:33:33:33:05"
        unbor6_macs = ["00:33:33:33:33:61", "00:33:33:33:33:62",
                       "00:33:33:33:33:63", "00:33:33:33:33:64"]

        urif_list = []
        unhop_list = []
        unbor_list = []
        tunnel_term_list = []
        tunnel_route_list = []
        tunnel_nhop_list = []
        vm_route_list = []
        uecmp_member_list = []

        try:
            ##########################
            # underlay configuration #
            ##########################

            # urif1 - regular L3 (port10)
            uport1 = self.port10
            uport1_dev = self.dev_port10

            udata1 = {"uname": "L3 Port ECMP",
                      "vm_ip": vm1_ip,
                      "vm_ipv6": vm1_ipv6,
                      "unbor_mac": unbor1_mac,
                      "tun_ip": tun_ip1,
                      "tunnel_route": False,
                      "vm_route": True}

            urif, unhop, unbor, tunnel_nhop, vm_route, _, _ = \
                self._configureUrif(uport1, udata1)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)

            # urif2 - regular L3 (port11)
            uport2 = self.port11
            uport2_dev = self.dev_port11

            udata2 = {"uname": "L3 Port ECMP",
                      "vm_ip": vm2_ip,
                      "vm_ipv6": vm2_ipv6,
                      "unbor_mac": unbor2_mac,
                      "tun_ip": tun_ip2,
                      "tunnel_route": False,
                      "vm_route": True}

            urif, unhop, unbor, tunnel_nhop, vm_route, _, _ = \
                self._configureUrif(uport2, udata2)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)

            # urif3 - regular L3 (port12)
            uport3 = self.port12
            uport3_dev = self.dev_port12

            udata3 = {"uname": "L3 Port ECMP",
                      "vm_ip": vm3_ip,
                      "vm_ipv6": vm3_ipv6,
                      "unbor_mac": unbor3_mac,
                      "tun_ip": tun_ip3,
                      "tunnel_route": False,
                      "vm_route": True}

            urif, unhop, unbor, tunnel_nhop, vm_route, _, _ = \
                self._configureUrif(uport3, udata3)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)

            uecmp = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            for unhop in unhop_list:
                uecmp_member = sai_thrift_create_next_hop_group_member(
                    self.client, next_hop_group_id=uecmp, next_hop_id=unhop)
                uecmp_member_list.append(uecmp_member)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(tun_ip1 + '/16'))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=uecmp)
            tunnel_route_list.append(tunnel_route)

            # urif4 - L3 subport (port13)
            uport4 = self.port13
            uport4_dev = self.dev_port13
            u4_vlan_no = 402

            udata4 = {"uname": "L3 Subport",
                      "vm_ip": vm4_ip,
                      "vm_ipv6": vm4_ipv6,
                      "unbor_mac": unbor4_mac,
                      "tun_ip": tun_ip4,
                      "lpb_ip": lpb_ip4,
                      "vlan_no": u4_vlan_no,
                      "tunnel_route": True,
                      "vm_route": True}

            urif, unhop, unbor, tunnel_nhop, vm_route, tunnel_term,\
                tunnel_route = self._configureUrif(
                    uport4, udata4,
                    rif_type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif5 - L3 LAG (port14, port15)
            uports5 = [self.port14, self.port15]
            uports5_dev = [self.dev_port14, self.dev_port15]

            udata5 = {"uname": "L3 LAG",
                      "vm_ip": vm5_ip,
                      "vm_ipv6": vm5_ipv6,
                      "unbor_mac": unbor5_mac,
                      "tun_ip": tun_ip5,
                      "lpb_ip": lpb_ip5,
                      "tunnel_route": True,
                      "vm_route": True}

            ulag1 = sai_thrift_create_lag(self.client)
            ulag1_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports5[0])
            ulag1_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports5[1])

            urif, unhop, unbor, tunnel_nhop, vm_route, tunnel_term, \
                tunnel_route = self._configureUrif(ulag1, udata5)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif6 - SVI (port16, port17, [port18, port19], [port20, port21])
            # (untagged port, tagged port, untagged LAG, tagged LAG)
            uports6 = [self.port16, self.port17, [self.port18, self.port19],
                       [self.port20, self.port21]]
            uports6_dev = [[self.dev_port16], [self.dev_port17],
                           [self.dev_port18, self.dev_port19],
                           [self.dev_port20, self.dev_port21]]
            u6_vlan_no = 602

            udata6 = {"uname": "SVI",
                      "vm_ip": vm6_ips,
                      "vm_ipv6": vm6_ipsv6,
                      "unbor_mac": unbor6_macs,
                      "tun_ip": tun_ips6,
                      "lpb_ip": lpb_ips6,
                      "vlan_no": [0, u6_vlan_no, 0, u6_vlan_no],
                      "tunnel_route": True,
                      "vm_route": True}

            ulag2 = sai_thrift_create_lag(self.client)
            ulag2_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports6[2][0])
            ulag2_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports6[2][1])

            ulag3 = sai_thrift_create_lag(self.client)
            ulag3_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports6[3][0])
            ulag3_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports6[3][1])

            uport_bp1 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports6[0],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uport_bp2 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports6[1],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag2_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag2,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag3_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag3,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uvlan = sai_thrift_create_vlan(self.client, vlan_id=u6_vlan_no)
            uvlan_member1 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp1,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_port_attribute(self.client, uports6[0],
                                          port_vlan_id=u6_vlan_no)
            uvlan_member2 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp2,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)
            uvlan_member3 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag2_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=u6_vlan_no)
            uvlan_member4 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag3_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

            urif, unhops, unbors, tunnel_nhops, vm_routes, tunnel_terms, \
                tunnel_routes = self._configureUrif(
                    uvlan, udata6,
                    bridge_ports=[uport_bp1, uport_bp2, ulag2_bp, ulag3_bp],
                    rif_type=SAI_ROUTER_INTERFACE_TYPE_VLAN)

            urif_list.append(urif)
            unhop_list.extend(unhops)
            unbor_list.extend(unbors)
            tunnel_nhop_list.extend(tunnel_nhops)
            vm_route_list.extend(vm_routes)
            tunnel_term_list.extend(tunnel_terms)
            tunnel_route_list.extend(tunnel_routes)

            ecmp_uports = [uport1_dev, uport2_dev, uport3_dev]
            ecmp_udata = [udata1, udata2, udata3]
            oports = [self.oport1_dev, self.oport2_dev,
                      self.oports3_dev, self.oports4_dev]
            overlay_data = [self.odata1, self.odata2, self.odata3, self.odata4]

            for oport, odata in zip(oports, overlay_data):
                for uport, udata in zip([uport4_dev, uports5_dev, uports6_dev],
                                        [udata4, udata5, udata6]):
                    self._verifyEncap(oport, uport, odata, udata)
                    self._verifyDecap(oport, uport, odata, udata)

                self._verifyEcmpEncap(oport, ecmp_uports, [odata, ecmp_udata])

                for uport, udata in zip(
                        [uport1_dev, uport2_dev, uport3_dev],
                        [udata1, udata2, udata3]):
                    self._verifyDecap(oport, uport, odata, udata)

            # random add/delete ECMP member verification
            index = random.randrange(len(oports))
            self._addDelEcmpMemberTest(oports[index], ecmp_uports,
                                       [overlay_data[index], ecmp_udata],
                                       uecmp_member_list)

        finally:
            sai_thrift_flush_fdb_entries(
                self.client, entry_type=SAI_FDB_FLUSH_ENTRY_TYPE_ALL)

            for tunnel_route in tunnel_route_list:
                sai_thrift_remove_route_entry(self.client, tunnel_route)

            for tunnel_term in tunnel_term_list:
                sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                          tunnel_term)

            for ecmp_member in uecmp_member_list:
                sai_thrift_remove_next_hop_group_member(self.client,
                                                        ecmp_member)

            sai_thrift_remove_next_hop_group(self.client, uecmp)

            for vm_route in vm_route_list:
                sai_thrift_remove_route_entry(self.client, vm_route)

            for tunnel_nhop, unbor, unhop in zip(
                    tunnel_nhop_list, unbor_list, unhop_list):
                sai_thrift_remove_next_hop(self.client, tunnel_nhop)
                sai_thrift_remove_neighbor_entry(self.client, unbor)
                sai_thrift_remove_next_hop(self.client, unhop)

            for urif in urif_list:
                sai_thrift_remove_router_interface(self.client, urif)

            sai_thrift_remove_vlan_member(self.client, uvlan_member4)
            sai_thrift_set_lag_attribute(self.client, ulag2, port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member3)
            sai_thrift_set_port_attribute(self.client, uports6[0],
                                          port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member2)
            sai_thrift_remove_vlan_member(self.client, uvlan_member1)
            sai_thrift_remove_vlan(self.client, uvlan)
            sai_thrift_remove_bridge_port(self.client, ulag3_bp)
            sai_thrift_remove_bridge_port(self.client, ulag2_bp)
            sai_thrift_remove_bridge_port(self.client, uport_bp1)
            sai_thrift_remove_bridge_port(self.client, uport_bp2)
            sai_thrift_remove_lag_member(self.client, ulag3_member2)
            sai_thrift_remove_lag_member(self.client, ulag3_member1)
            sai_thrift_remove_lag(self.client, ulag3)
            sai_thrift_remove_lag_member(self.client, ulag2_member2)
            sai_thrift_remove_lag_member(self.client, ulag2_member1)
            sai_thrift_remove_lag(self.client, ulag2)

            sai_thrift_remove_lag_member(self.client, ulag1_member2)
            sai_thrift_remove_lag_member(self.client, ulag1_member1)
            sai_thrift_remove_lag(self.client, ulag1)


@group("draft")
class VxLanRifsConfigTunnelIpv4UnderlayOecmpTest(VxLanRifsConfigBaseSetup):
    '''
    Multipoint-to-multipoint tunnel tests regarding different overlay-underlay
    interfaces configutrations with IPv4 underlay layer and overlay ECMP.
    '''

    def setUp(self):
        super(VxLanRifsConfigTunnelIpv4UnderlayOecmpTest, self).setUp()

        customer_ip = "100.1.2.1"
        customer_ipv6 = "2001:0db8::1:2:1"
        customer_mac = "00:22:22:22:22:01"
        self.vm_ip = "100.1.1.1"
        self.vm_ipv6 = "2001:0db8::1:1:1"

        #########################
        # overlay configuration #
        #########################

        # orif - L3 port (port0)
        self.oport = self.port0
        self.oport_dev = self.dev_port0
        self.odata = {"oname": "Overlay L3 port",
                      "customer_mac": customer_mac,
                      "customer_ip": customer_ip,
                      "customer_ipv6": customer_ipv6,
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6}

        self.tunnel_ecmp = sai_thrift_create_next_hop_group(
            self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

    def runTest(self):
        self.ecmpToPortsConfigTest()
        self.ecmpToEcmpConfigTest()
        self.ecmpToPortsEcmpConfigTest()

    def tearDown(self):
        sai_thrift_remove_next_hop_group(self.client, self.tunnel_ecmp)

        super(VxLanRifsConfigTunnelIpv4UnderlayOecmpTest, self).tearDown()

    def ecmpToPortsConfigTest(self):
        '''
        Verify tunnel encap/decap for following underlay configuration:
            L3 Port, L3 LAG, L3 Subport, SVI: [Tagged & Untagged, Port & LAG]
        '''
        print("\necmpToPortsConfigTest()")

        tun_ip1 = "10.10.1.1"
        tun_ip2 = "10.10.2.1"
        tun_ip3 = "10.10.3.1"
        tun_ips4 = ["10.10.41.1", "10.10.42.1", "10.10.43.1", "10.10.44.1"]
        lpb_ip1 = "10.10.1.10"
        lpb_ip2 = "10.10.2.10"
        lpb_ip3 = "10.10.3.10"
        lpb_ips4 = ["10.10.41.10", "10.10.42.10", "10.10.43.10", "10.10.44.10"]
        unbor1_mac = "00:33:33:33:33:01"
        unbor2_mac = "00:33:33:33:33:02"
        unbor3_mac = "00:33:33:33:33:03"
        unbor4_macs = ["00:33:33:33:33:41", "00:33:33:33:33:42",
                       "00:33:33:33:33:43", "00:33:33:33:33:44"]

        urif_list = []
        unhop_list = []
        unbor_list = []
        tunnel_term_list = []
        tunnel_route_list = []

        try:
            #########################
            # overlay configuration #
            #########################

            # orif1 - L3 port (port0)
            tunnel_data = [tun_ip1, tun_ip2, tun_ip3]
            tunnel_data.extend(tun_ips4)

            orif, onhops, onbors, customer_routes, tunnel_nhops, \
                ecmp_members, vm_routes = self._configureOverlayEcmp(
                    self.oport, self.odata, tunnel_data, self.tunnel_ecmp)

            ##########################
            # underlay configuration #
            ##########################

            # urif1 - regular L3 (port1)
            uport1 = self.port1
            uport1_dev = self.dev_port1

            udata1 = {"uname": "L3 Port",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor1_mac,
                      "tun_ip": tun_ip1,
                      "lpb_ip": lpb_ip1,
                      "tunnel_route": True,
                      "vm_route": False}

            urif, unhop, unbor, _, _, tunnel_term, tunnel_route = \
                self._configureUrif(uport1, udata1)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif2 - L3 subport (port2)
            uport2 = self.port2
            uport2_dev = self.dev_port2
            u2_vlan_no = 202

            udata2 = {"uname": "L3 Subport",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor2_mac,
                      "tun_ip": tun_ip2,
                      "lpb_ip": lpb_ip2,
                      "vlan_no": u2_vlan_no,
                      "tunnel_route": True,
                      "vm_route": False}

            urif, unhop, unbor, _, _, tunnel_term, tunnel_route = \
                self._configureUrif(
                    uport2, udata2,
                    rif_type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif3 - L3 LAG (port3, port4)
            uports3 = [self.port3, self.port4]
            uports3_dev = [self.dev_port3, self.dev_port4]

            udata3 = {"uname": "L3 LAG",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor3_mac,
                      "tun_ip": tun_ip3,
                      "lpb_ip": lpb_ip3,
                      "tunnel_route": True,
                      "vm_route": False}

            ulag1 = sai_thrift_create_lag(self.client)
            ulag1_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports3[0])
            ulag1_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports3[1])

            urif, unhop, unbor, _, _, tunnel_term, tunnel_route = \
                self._configureUrif(ulag1, udata3)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif4 - SVI (port5, port6, [port7, port8], [port9, port10])
            # (untagged port, tagged port, untagged LAG, tagged LAG)
            uports4 = [self.port5, self.port6, [self.port7, self.port8],
                       [self.port9, self.port10]]
            uports4_dev = [[self.dev_port5], [self.dev_port6],
                           [self.dev_port7, self.dev_port8],
                           [self.dev_port9, self.dev_port10]]
            u4_vlan_no = 402

            udata4 = {"uname": "SVI",
                      "unbor_mac": unbor4_macs,
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "tun_ip": tun_ips4,
                      "lpb_ip": lpb_ips4,
                      "vlan_no": [0, u4_vlan_no, 0, u4_vlan_no],
                      "tunnel_route": True,
                      "vm_route": False}

            ulag2 = sai_thrift_create_lag(self.client)
            ulag2_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports4[2][0])
            ulag2_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports4[2][1])

            ulag3 = sai_thrift_create_lag(self.client)
            ulag3_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports4[3][0])
            ulag3_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports4[3][1])

            uport_bp1 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports4[0],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uport_bp2 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports4[1],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag2_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag2,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag3_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag3,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uvlan = sai_thrift_create_vlan(self.client, vlan_id=u4_vlan_no)
            uvlan_member1 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp1,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_port_attribute(self.client, uports4[0],
                                          port_vlan_id=u4_vlan_no)
            uvlan_member2 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp2,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)
            uvlan_member3 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag2_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=u4_vlan_no)
            uvlan_member4 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag3_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

            urif, unhops, unbors, _, _, tunnel_terms, tunnel_routes = \
                self._configureUrif(uvlan, udata4,
                                    bridge_ports=[uport_bp1, uport_bp2,
                                                  ulag2_bp, ulag3_bp],
                                    rif_type=SAI_ROUTER_INTERFACE_TYPE_VLAN)

            urif_list.append(urif)
            unhop_list.extend(unhops)
            unbor_list.extend(unbors)
            tunnel_term_list.extend(tunnel_terms)
            tunnel_route_list.extend(tunnel_routes)

            uports = [uport1_dev, uport2_dev]
            uports.extend(uports3_dev)
            uports.extend([port for sublist in uports4_dev
                           for port in sublist])

            underlay_data = [udata1, udata2, udata3]
            for i in range(len(uports4)):
                udata = {}
                for key, value in udata4.items():
                    udata[key] = value[i] if isinstance(value, list) else value
                underlay_data.append(udata)

            self._verifyEcmpEncap(self.oport_dev, uports,
                                  [self.odata, underlay_data],
                                  mode="overlay")

            for uport, udata in zip(
                    [uport1_dev, uport2_dev, uports3_dev, uports4_dev],
                    [udata1, udata2, udata3, udata4]):
                self._verifyDecap(self.oport_dev, uport, self.odata, udata)

        finally:
            sai_thrift_flush_fdb_entries(
                self.client, entry_type=SAI_FDB_FLUSH_ENTRY_TYPE_ALL)

            for tunnel_route, tunnel_term, unbor, unhop in zip(
                    tunnel_route_list, tunnel_term_list, unbor_list,
                    unhop_list):
                sai_thrift_remove_route_entry(self.client, tunnel_route)
                sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                          tunnel_term)
                sai_thrift_remove_neighbor_entry(self.client, unbor)
                sai_thrift_remove_next_hop(self.client, unhop)

            for urif in urif_list:
                sai_thrift_remove_router_interface(self.client, urif)

            sai_thrift_remove_vlan_member(self.client, uvlan_member4)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member3)
            sai_thrift_set_port_attribute(self.client, uports4[0],
                                          port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member2)
            sai_thrift_remove_vlan_member(self.client, uvlan_member1)
            sai_thrift_remove_vlan(self.client, uvlan)
            sai_thrift_remove_bridge_port(self.client, ulag3_bp)
            sai_thrift_remove_bridge_port(self.client, ulag2_bp)
            sai_thrift_remove_bridge_port(self.client, uport_bp2)
            sai_thrift_remove_bridge_port(self.client, uport_bp1)
            sai_thrift_remove_lag_member(self.client, ulag3_member2)
            sai_thrift_remove_lag_member(self.client, ulag3_member1)
            sai_thrift_remove_lag(self.client, ulag3)
            sai_thrift_remove_lag_member(self.client, ulag2_member2)
            sai_thrift_remove_lag_member(self.client, ulag2_member1)
            sai_thrift_remove_lag(self.client, ulag2)

            sai_thrift_remove_lag_member(self.client, ulag1_member2)
            sai_thrift_remove_lag_member(self.client, ulag1_member1)
            sai_thrift_remove_lag(self.client, ulag1)

        for vm_route, customer_route, onbor, onhop in zip(
                vm_routes, customer_routes, onbors, onhops):
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_route_entry(self.client, customer_route)
            sai_thrift_remove_neighbor_entry(self.client, onbor)
            sai_thrift_remove_next_hop(self.client, onhop)

        sai_thrift_remove_router_interface(self.client, orif)

        for ecmp_member, tunnel_nhop in zip(ecmp_members, tunnel_nhops):
            sai_thrift_remove_next_hop_group_member(self.client,
                                                    ecmp_member)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def ecmpToEcmpConfigTest(self):
        '''
        Verify tunnel encap/decap for following underlay configuration:
            ECMP: (L3 Port, L3 Subport, L3 LAG SVI: [Tagged & Untagged,
            Port & LAG])
        '''
        print("\necmpToEcmpConfigTest()")

        tun_ip1 = "10.10.1.1"
        tun_ip2 = "10.10.2.1"
        tun_ip3 = "10.10.3.1"
        tun_ips4 = ["10.10.41.1", "10.10.42.1", "10.10.43.1", "10.10.44.1"]
        unbor1_mac = "00:33:33:33:33:01"
        unbor2_mac = "00:33:33:33:33:02"
        unbor3_mac = "00:33:33:33:33:03"
        unbor4_macs = ["00:33:33:33:33:41", "00:33:33:33:33:42",
                       "00:33:33:33:33:43", "00:33:33:33:33:44"]

        urif_list = []
        unhop_list = []
        unbor_list = []
        uecmp_member_list = []

        try:
            #########################
            # overlay configuration #
            #########################

            # orif1 - L3 port (port0)
            tunnel_data = [tun_ip1, tun_ip2, tun_ip3]
            tunnel_data.extend(tun_ips4)

            orif, onhops, onbors, customer_routes, tunnel_nhops, \
                ecmp_members, vm_routes = self._configureOverlayEcmp(
                    self.oport, self.odata, tunnel_data, self.tunnel_ecmp)

            ##########################
            # underlay configuration #
            ##########################

            # urif1 - regular L3 (port1)
            uport1 = self.port1
            uport1_dev = self.dev_port1

            udata1 = {"uname": "L3 Port",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor1_mac,
                      "tun_ip": tun_ip1,
                      "tunnel_route": False,
                      "vm_route": False}

            urif, unhop, unbor, _, _, _, _ = self._configureUrif(uport1,
                                                                 udata1)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)

            # urif2 - L3 subport (port11)
            uport2 = self.port2
            uport2_dev = self.dev_port2
            u2_vlan_no = 202

            udata2 = {"uname": "L3 Subport",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor2_mac,
                      "tun_ip": tun_ip2,
                      "vlan_no": u2_vlan_no,
                      "tunnel_route": False,
                      "vm_route": False}

            urif, unhop, unbor, _, _, _, _ = self._configureUrif(
                uport2, udata2, rif_type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)

            # urif3 - L3 LAG (port3, port4)
            uports3 = [self.port3, self.port4]
            uports3_dev = [self.dev_port3, self.dev_port4]

            udata3 = {"uname": "L3 LAG",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor3_mac,
                      "tun_ip": tun_ip3,
                      "tunnel_route": False,
                      "vm_route": False}

            ulag1 = sai_thrift_create_lag(self.client)
            ulag1_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports3[0])
            ulag1_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports3[1])

            urif, unhop, unbor, _, _, _, _ = self._configureUrif(ulag1, udata3)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)

            # urif4 - SVI (port5, port6, [port7, port8], [port9, port10])
            # (untagged port, tagged port, untagged LAG, tagged LAG)
            uports4 = [self.port5, self.port6, [self.port7, self.port8],
                       [self.port9, self.port10]]
            uports4_dev = [[self.dev_port5], [self.dev_port6],
                           [self.dev_port7, self.dev_port8],
                           [self.dev_port9, self.dev_port10]]
            u4_vlan_no = 402

            udata4 = {"uname": "SVI",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor4_macs,
                      "tun_ip": tun_ips4,
                      "vlan_no": [0, u4_vlan_no, 0, u4_vlan_no],
                      "tunnel_route": False,
                      "vm_route": False}

            ulag2 = sai_thrift_create_lag(self.client)
            ulag2_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports4[2][0])
            ulag2_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports4[2][1])

            ulag3 = sai_thrift_create_lag(self.client)
            ulag3_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports4[3][0])
            ulag3_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports4[3][1])

            uport_bp1 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports4[0],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uport_bp2 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports4[1],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag2_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag2,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag3_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag3,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uvlan = sai_thrift_create_vlan(self.client, vlan_id=u4_vlan_no)
            uvlan_member1 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp1,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_port_attribute(self.client, uports4[0],
                                          port_vlan_id=u4_vlan_no)
            uvlan_member2 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp2,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)
            uvlan_member3 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag2_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=u4_vlan_no)
            uvlan_member4 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag3_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

            urif, unhops, unbors, _, _, _, _ = self._configureUrif(
                uvlan, udata4,
                bridge_ports=[uport_bp1, uport_bp2, ulag2_bp, ulag3_bp],
                rif_type=SAI_ROUTER_INTERFACE_TYPE_VLAN)

            urif_list.append(urif)
            unhop_list.extend(unhops)
            unbor_list.extend(unbors)

            uecmp = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            for unhop in unhop_list:
                uecmp_member = sai_thrift_create_next_hop_group_member(
                    self.client, next_hop_group_id=uecmp, next_hop_id=unhop)
                uecmp_member_list.append(uecmp_member)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(tun_ip1 + '/16'))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=uecmp)

            uports = [uport1_dev, uport2_dev]
            uports.extend(uports3_dev)
            uports.extend([port for sublist in uports4_dev
                           for port in sublist])

            underlay_data = [udata1, udata2, udata3]
            for i in range(len(uports4)):
                udata = {}
                for key, value in udata4.items():
                    udata[key] = value[i] if isinstance(value, list) else value
                underlay_data.append(udata)

            self._verifyEcmpEncap(self.oport_dev, uports,
                                  [self.odata, underlay_data],
                                  mode="both")

            for uport, udata in zip(
                    [uport1_dev, uport2_dev, uports3_dev, uports4_dev],
                    [udata1, udata2, udata3, udata4]):
                self._verifyDecap(self.oport_dev, uport, self.odata, udata)

        finally:
            sai_thrift_flush_fdb_entries(
                self.client, entry_type=SAI_FDB_FLUSH_ENTRY_TYPE_ALL)

            sai_thrift_remove_route_entry(self.client, tunnel_route)

            for ecmp_member, unbor, unhop in zip(uecmp_member_list,
                                                 unbor_list, unhop_list):
                sai_thrift_remove_next_hop_group_member(self.client,
                                                        ecmp_member)
                sai_thrift_remove_neighbor_entry(self.client, unbor)
                sai_thrift_remove_next_hop(self.client, unhop)

            sai_thrift_remove_next_hop_group(self.client, uecmp)

            for urif in urif_list:
                sai_thrift_remove_router_interface(self.client, urif)

            sai_thrift_remove_vlan_member(self.client, uvlan_member4)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member3)
            sai_thrift_set_port_attribute(self.client, uports4[0],
                                          port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member2)
            sai_thrift_remove_vlan_member(self.client, uvlan_member1)
            sai_thrift_remove_vlan(self.client, uvlan)
            sai_thrift_remove_bridge_port(self.client, ulag3_bp)
            sai_thrift_remove_bridge_port(self.client, ulag2_bp)
            sai_thrift_remove_bridge_port(self.client, uport_bp2)
            sai_thrift_remove_bridge_port(self.client, uport_bp1)
            sai_thrift_remove_lag_member(self.client, ulag3_member2)
            sai_thrift_remove_lag_member(self.client, ulag3_member1)
            sai_thrift_remove_lag(self.client, ulag3)
            sai_thrift_remove_lag_member(self.client, ulag2_member2)
            sai_thrift_remove_lag_member(self.client, ulag2_member1)
            sai_thrift_remove_lag(self.client, ulag2)

            sai_thrift_remove_lag_member(self.client, ulag1_member2)
            sai_thrift_remove_lag_member(self.client, ulag1_member1)
            sai_thrift_remove_lag(self.client, ulag1)

            for vm_route, customer_route, onbor, onhop in zip(
                    vm_routes, customer_routes, onbors, onhops):
                sai_thrift_remove_route_entry(self.client, vm_route)
                sai_thrift_remove_route_entry(self.client, customer_route)
                sai_thrift_remove_neighbor_entry(self.client, onbor)
                sai_thrift_remove_next_hop(self.client, onhop)

            sai_thrift_remove_router_interface(self.client, orif)

            for ecmp_member, tunnel_nhop in zip(ecmp_members, tunnel_nhops):
                sai_thrift_remove_next_hop_group_member(self.client,
                                                        ecmp_member)
                sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def ecmpToPortsEcmpConfigTest(self):
        '''
        Verify tunnel encap/decap for following underlay configuration:
            ECMP of L3 Ports, L3 Subport, L3 LAG,  SVI: [Tagged & Untagged,
            Port & LAG]
        '''
        print("\necmpToPortsEcmpConfigTest()")

        tun_ip1 = "10.10.1.1"
        tun_ip2 = "10.10.2.1"
        tun_ip3 = "10.10.3.1"
        tun_ip4 = "10.10.4.1"
        tun_ip5 = "10.10.5.1"
        tun_ips6 = ["10.10.61.1", "10.10.62.1", "10.10.63.1", "10.10.64.1"]
        lpb_ip4 = "10.10.4.10"
        lpb_ip5 = "10.10.5.10"
        lpb_ips6 = ["10.10.61.10", "10.10.62.10", "10.10.63.10", "10.10.64.10"]
        tun_ip4 = "10.10.4.1"
        tun_ip5 = "10.10.5.1"
        tun_ips6 = ["10.10.61.1", "10.10.62.1", "10.10.63.1", "10.10.64.1"]
        unbor1_mac = "00:33:33:33:33:01"
        unbor2_mac = "00:33:33:33:33:02"
        unbor3_mac = "00:33:33:33:33:03"
        unbor4_mac = "00:33:33:33:33:04"
        unbor5_mac = "00:33:33:33:33:05"
        unbor6_macs = ["00:33:33:33:33:61", "00:33:33:33:33:62",
                       "00:33:33:33:33:63", "00:33:33:33:33:64"]

        urif_list = []
        unhop_list = []
        unbor_list = []
        tunnel_term_list = []
        tunnel_route_list = []
        uecmp_member_list = []

        try:
            #########################
            # overlay configuration #
            #########################

            # orif - L3 port (port0)
            tunnel_data = [tun_ip1, tun_ip2, tun_ip3, tun_ip4, tun_ip5]
            tunnel_data.extend(tun_ips6)

            orif, onhops, onbors, customer_routes, tunnel_nhops, \
                ecmp_members, vm_routes = self._configureOverlayEcmp(
                    self.oport, self.odata, tunnel_data, self.tunnel_ecmp)

            ##########################
            # underlay configuration #
            ##########################

            # urif1 - regular L3 (port1)
            uport1 = self.port1
            uport1_dev = self.dev_port1

            udata1 = {"uname": "L3 Port ECMP",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor1_mac,
                      "tun_ip": tun_ip1,
                      "tunnel_route": False,
                      "vm_route": False}

            urif, unhop, unbor, _, _, _, _ = self._configureUrif(uport1,
                                                                 udata1)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)

            # urif2 - regular L3 (port2)
            uport2 = self.port2
            uport2_dev = self.dev_port2

            udata2 = {"uname": "L3 Port ECMP",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor2_mac,
                      "tun_ip": tun_ip2,
                      "tunnel_route": False,
                      "vm_route": False}

            urif, unhop, unbor, _, _, _, _ = self._configureUrif(uport2,
                                                                 udata2)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)

            # urif3 - regular L3 (port3)
            uport3 = self.port3
            uport3_dev = self.dev_port3

            udata3 = {"uname": "L3 Port ECMP",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor3_mac,
                      "tun_ip": tun_ip3,
                      "tunnel_route": False,
                      "vm_route": False}

            urif, unhop, unbor, _, _, _, _ = self._configureUrif(uport3,
                                                                 udata3)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)

            uecmp = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            for unhop in unhop_list:
                uecmp_member = sai_thrift_create_next_hop_group_member(
                    self.client, next_hop_group_id=uecmp, next_hop_id=unhop)
                uecmp_member_list.append(uecmp_member)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(tun_ip1 + '/16'))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=uecmp)
            tunnel_route_list.append(tunnel_route)

            # urif4 - L3 subport (port4)
            uport4 = self.port4
            uport4_dev = self.dev_port4
            u4_vlan_no = 402

            udata4 = {"uname": "L3 Subport",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor4_mac,
                      "tun_ip": tun_ip4,
                      "lpb_ip": lpb_ip4,
                      "vlan_no": u4_vlan_no,
                      "tunnel_route": True,
                      "vm_route": False}

            urif, unhop, unbor, _, _, tunnel_term, tunnel_route = \
                self._configureUrif(
                    uport4, udata4,
                    rif_type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif5 - L3 LAG (port5, port6)
            uports5 = [self.port5, self.port6]
            uports5_dev = [self.dev_port5, self.dev_port6]

            udata5 = {"uname": "L3 LAG",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor5_mac,
                      "tun_ip": tun_ip5,
                      "lpb_ip": lpb_ip5,
                      "tunnel_route": True,
                      "vm_route": False}

            ulag1 = sai_thrift_create_lag(self.client)
            ulag1_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports5[0])
            ulag1_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports5[1])

            urif, unhop, unbor, _, _, tunnel_term, tunnel_route = \
                self._configureUrif(ulag1, udata5)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif6 - SVI (port7, port8, [port9, port10], [port11, port12])
            # (untagged port, tagged port, untagged LAG, tagged LAG)
            uports6 = [self.port7, self.port8, [self.port9, self.port10],
                       [self.port11, self.port12]]
            uports6_dev = [[self.dev_port7], [self.dev_port8],
                           [self.dev_port9, self.dev_port10],
                           [self.dev_port11, self.dev_port12]]
            u6_vlan_no = 602

            udata6 = {"uname": "SVI",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor6_macs,
                      "tun_ip": tun_ips6,
                      "lpb_ip": lpb_ips6,
                      "vlan_no": [0, u6_vlan_no, 0, u6_vlan_no],
                      "tunnel_route": True,
                      "vm_route": False}

            ulag2 = sai_thrift_create_lag(self.client)
            ulag2_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports6[2][0])
            ulag2_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports6[2][1])

            ulag3 = sai_thrift_create_lag(self.client)
            ulag3_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports6[3][0])
            ulag3_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports6[3][1])

            uport_bp1 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports6[0],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uport_bp2 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports6[1],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag2_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag2,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag3_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag3,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uvlan = sai_thrift_create_vlan(self.client, vlan_id=u6_vlan_no)
            uvlan_member1 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp1,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_port_attribute(self.client, uports6[0],
                                          port_vlan_id=u6_vlan_no)
            uvlan_member2 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp2,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)
            uvlan_member3 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag2_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=u6_vlan_no)
            uvlan_member4 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag3_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

            urif, unhops, unbors, _, _, tunnel_terms, tunnel_routes = \
                self._configureUrif(uvlan, udata6,
                                    bridge_ports=[uport_bp1, uport_bp2,
                                                  ulag2_bp, ulag3_bp],
                                    rif_type=SAI_ROUTER_INTERFACE_TYPE_VLAN)

            urif_list.append(urif)
            unhop_list.extend(unhops)
            unbor_list.extend(unbors)
            tunnel_term_list.extend(tunnel_terms)
            tunnel_route_list.extend(tunnel_routes)

            underlay_data = [udata1, udata2, udata3, udata4, udata5]
            # split a dictionary with lists into a list of dictionaries
            mapped_udata6 = map(dict, zip(*[[(k, v) for v in value]
                                            for k, value in udata6.items()
                                            if isinstance(value, list)]))

            for entry in mapped_udata6:
                entry = dict(udata6, **entry)
                underlay_data.append(entry)

            uports = [uport1_dev, uport2_dev, uport3_dev, uport4_dev]
            uports.extend(uports5_dev)
            uports.extend([port for sublist in uports6_dev
                           for port in sublist])

            self._verifyEcmpEncap(self.oport_dev, uports,
                                  [self.odata, underlay_data],
                                  mode="both")

            for uport, udata in zip(
                    [uport1_dev, uport2_dev, uport3_dev, uport4_dev,
                     uports5_dev, uports6_dev],
                    [udata1, udata2, udata3, udata4, udata5, udata6]):
                self._verifyDecap(self.oport_dev, uport, self.odata, udata)

        finally:
            sai_thrift_flush_fdb_entries(
                self.client, entry_type=SAI_FDB_FLUSH_ENTRY_TYPE_ALL)

            for tunnel_route in tunnel_route_list:
                sai_thrift_remove_route_entry(self.client, tunnel_route)

            for tunnel_term in tunnel_term_list:
                sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                          tunnel_term)

            for ecmp_member in uecmp_member_list:
                sai_thrift_remove_next_hop_group_member(self.client,
                                                        ecmp_member)

            sai_thrift_remove_next_hop_group(self.client, uecmp)

            for unbor, unhop in zip(unbor_list, unhop_list):
                sai_thrift_remove_neighbor_entry(self.client, unbor)
                sai_thrift_remove_next_hop(self.client, unhop)

            for urif in urif_list:
                sai_thrift_remove_router_interface(self.client, urif)

            sai_thrift_remove_vlan_member(self.client, uvlan_member4)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member3)
            sai_thrift_set_port_attribute(self.client, uports6[0],
                                          port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member2)
            sai_thrift_remove_vlan_member(self.client, uvlan_member1)
            sai_thrift_remove_vlan(self.client, uvlan)
            sai_thrift_remove_bridge_port(self.client, ulag3_bp)
            sai_thrift_remove_bridge_port(self.client, ulag2_bp)
            sai_thrift_remove_bridge_port(self.client, uport_bp1)
            sai_thrift_remove_bridge_port(self.client, uport_bp2)
            sai_thrift_remove_lag_member(self.client, ulag3_member2)
            sai_thrift_remove_lag_member(self.client, ulag3_member1)
            sai_thrift_remove_lag(self.client, ulag3)
            sai_thrift_remove_lag_member(self.client, ulag2_member2)
            sai_thrift_remove_lag_member(self.client, ulag2_member1)
            sai_thrift_remove_lag(self.client, ulag2)

            sai_thrift_remove_lag_member(self.client, ulag1_member2)
            sai_thrift_remove_lag_member(self.client, ulag1_member1)
            sai_thrift_remove_lag(self.client, ulag1)

            for vm_route, customer_route, onbor, onhop in zip(
                    vm_routes, customer_routes, onbors, onhops):
                sai_thrift_remove_route_entry(self.client, vm_route)
                sai_thrift_remove_route_entry(self.client, customer_route)
                sai_thrift_remove_neighbor_entry(self.client, onbor)
                sai_thrift_remove_next_hop(self.client, onhop)

            sai_thrift_remove_router_interface(self.client, orif)

            for ecmp_member, tunnel_nhop in zip(ecmp_members, tunnel_nhops):
                sai_thrift_remove_next_hop_group_member(self.client,
                                                        ecmp_member)
                sai_thrift_remove_next_hop(self.client, tunnel_nhop)


@group("draft")
class VxLanRifsConfigTunnelIpv6UnderlayOportsTest(VxLanRifsConfigBaseSetup):
    '''
    Multipoint-to-multipoint tunnel tests regarding different overlay-underlay
    interfaces configutrations with IPv6 underlay layer and different
    types of RIFs as an overlay ports: L3 Port, L3 LAG, L3 Subport,
    SVI: [Tagged & Untagged, Port & LAG]
    '''

    def __init__(self):
        super(VxLanRifsConfigTunnelIpv6UnderlayOportsTest, self).__init__(
            ipv6=True)

    def setUp(self):
        super(VxLanRifsConfigTunnelIpv6UnderlayOportsTest, self).setUp()

        customer1_ip = "100.1.2.1"
        customer2_ip = "100.2.2.1"
        customer3_ip = "100.3.2.1"
        customer4_ips = ["100.41.2.1", "100.42.2.1",
                         "100.43.2.1", "100.44.2.1"]
        customer1_ipv6 = "2001:0db8::1:2:1"
        customer2_ipv6 = "2001:0db8::2:2:1"
        customer3_ipv6 = "2001:0db8::3:2:1"
        customer4_ipsv6 = ["2001:0db8::41:2:1", "2001:0db8::42:2:1",
                           "2001:0db8::43:2:1", "2001:0db8::44:2:1"]
        customer1_mac = "00:22:22:22:22:01"
        customer2_mac = "00:22:22:22:22:02"
        customer3_mac = "00:22:22:22:22:03"
        customer4_macs = ["00:22:22:22:22:41", "00:22:22:22:22:42",
                          "00:22:22:22:22:43", "00:22:22:22:22:44"]

        self.orif_list = []
        self.onhop_list = []
        self.onbor_list = []
        self.customer_route_list = []

        #########################
        # overlay configuration #
        #########################

        # orif1 - regular L3 port (port0)
        self.oport1 = self.port0
        self.oport1_dev = self.dev_port0

        self.odata1 = {"oname": "L3 Port",
                       "customer_mac": customer1_mac,
                       "customer_ip": customer1_ip,
                       "customer_ipv6": customer1_ipv6}

        orif, onhop, onbor, customer_route = self._configureOrif(self.oport1,
                                                                 self.odata1)

        self.orif_list.append(orif)
        self.onhop_list.extend(onhop)
        self.onbor_list.extend(onbor)
        self.customer_route_list.extend(customer_route)

        # orif2 - L3 subport (port1)
        self.oport2 = self.port1
        self.oport2_dev = self.dev_port1
        o2_vlan_no = 201

        self.odata2 = {"oname": "L3 Subport",
                       "customer_mac": customer2_mac,
                       "customer_ip": customer2_ip,
                       "customer_ipv6": customer2_ipv6,
                       "vlan_no": o2_vlan_no}

        orif, onhop, onbor, customer_route = self._configureOrif(
            self.oport2, self.odata2,
            rif_type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT)

        self.orif_list.append(orif)
        self.onhop_list.extend(onhop)
        self.onbor_list.extend(onbor)
        self.customer_route_list.extend(customer_route)

        # orif3 - L3 LAG (port2, port3)
        self.oports3 = [self.port2, self.port3]
        self.oports3_dev = [self.dev_port2, self.dev_port3]

        self.odata3 = {"oname": "L3 LAG",
                       "customer_mac": customer3_mac,
                       "customer_ip": customer3_ip,
                       "customer_ipv6": customer3_ipv6}

        self.olag1 = sai_thrift_create_lag(self.client)
        self.olag1_member1 = sai_thrift_create_lag_member(
            self.client, lag_id=self.olag1, port_id=self.oports3[0])
        self.olag1_member2 = sai_thrift_create_lag_member(
            self.client, lag_id=self.olag1, port_id=self.oports3[1])

        orif, onhop, onbor, customer_route = self._configureOrif(self.olag1,
                                                                 self.odata3)

        self.orif_list.append(orif)
        self.onhop_list.extend(onhop)
        self.onbor_list.extend(onbor)
        self.customer_route_list.extend(customer_route)

        # orif4 - SVI (port4, port5, [port6, port7], [port8, port9])
        # [untagged port, tagged port, untagged LAG, tagged LAG]
        self.oports4 = [self.port4, self.port5, [self.port6, self.port7],
                        [self.port8, self.port9]]
        self.oports4_dev = [[self.dev_port4], [self.dev_port5],
                            [self.dev_port6, self.dev_port7],
                            [self.dev_port8, self.dev_port9]]
        o4_vlan_no = 401

        self.odata4 = {"oname": "SVI",
                       "customer_mac": customer4_macs,
                       "customer_ip": customer4_ips,
                       "customer_ipv6": customer4_ipsv6,
                       "vlan_no": [0, o4_vlan_no, 0, o4_vlan_no]}

        self.olag2 = sai_thrift_create_lag(self.client)
        self.olag2_member1 = sai_thrift_create_lag_member(
            self.client, lag_id=self.olag2, port_id=self.oports4[2][0])
        self.olag2_member2 = sai_thrift_create_lag_member(
            self.client, lag_id=self.olag2, port_id=self.oports4[2][1])

        self.olag3 = sai_thrift_create_lag(self.client)
        self.olag3_member1 = sai_thrift_create_lag_member(
            self.client, lag_id=self.olag3, port_id=self.oports4[3][0])
        self.olag3_member2 = sai_thrift_create_lag_member(
            self.client, lag_id=self.olag3, port_id=self.oports4[3][1])

        self.oport_bp1 = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.oports4[0],
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.oport_bp2 = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.oports4[1],
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.olag2_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.olag2,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.olag3_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.olag3,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.ovlan = sai_thrift_create_vlan(self.client, vlan_id=o4_vlan_no)
        self.ovlan_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.ovlan,
            bridge_port_id=self.oport_bp1,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        sai_thrift_set_port_attribute(self.client, self.oports4[0],
                                      port_vlan_id=o4_vlan_no)
        self.ovlan_member2 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.ovlan,
            bridge_port_id=self.oport_bp2,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)
        self.ovlan_member3 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.ovlan,
            bridge_port_id=self.olag2_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        sai_thrift_set_lag_attribute(self.client, self.olag2,
                                     port_vlan_id=o4_vlan_no)
        self.ovlan_member4 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.ovlan,
            bridge_port_id=self.olag3_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        orif, onhops, onbors, customer_routes = self._configureOrif(
            self.ovlan, self.odata4, rif_type=SAI_ROUTER_INTERFACE_TYPE_VLAN,
            bridge_ports=[self.oport_bp1, self.oport_bp2,
                          self.olag2_bp, self.olag3_bp])

        self.orif_list.append(orif)
        self.onhop_list.extend(onhops)
        self.onbor_list.extend(onbors)
        self.customer_route_list.extend(customer_routes)

    def runTest(self):
        self.portsToPortsConfigTest()
        self.portsToEcmpConfigTest()
        self.portsToPortsEcmpConfigTest()

    def tearDown(self):
        sai_thrift_flush_fdb_entries(
            self.client, entry_type=SAI_FDB_FLUSH_ENTRY_TYPE_ALL)

        for customer_route, onbor, onhop in zip(
                self.customer_route_list, self.onbor_list, self.onhop_list):
            sai_thrift_remove_route_entry(self.client, customer_route)
            sai_thrift_remove_neighbor_entry(self.client, onbor)
            sai_thrift_remove_next_hop(self.client, onhop)

        for orif in self.orif_list:
            sai_thrift_remove_router_interface(self.client, orif)

        sai_thrift_remove_vlan_member(self.client, self.ovlan_member4)
        sai_thrift_set_lag_attribute(self.client, self.olag2, port_vlan_id=0)
        sai_thrift_remove_vlan_member(self.client, self.ovlan_member3)
        sai_thrift_remove_vlan_member(self.client, self.ovlan_member2)
        sai_thrift_set_port_attribute(self.client, self.oports4[0],
                                      port_vlan_id=0)
        sai_thrift_remove_vlan_member(self.client, self.ovlan_member1)
        sai_thrift_remove_vlan(self.client, self.ovlan)
        sai_thrift_remove_bridge_port(self.client, self.olag3_bp)
        sai_thrift_remove_bridge_port(self.client, self.olag2_bp)
        sai_thrift_remove_bridge_port(self.client, self.oport_bp2)
        sai_thrift_remove_bridge_port(self.client, self.oport_bp1)
        sai_thrift_remove_lag_member(self.client, self.olag3_member2)
        sai_thrift_remove_lag_member(self.client, self.olag3_member1)
        sai_thrift_remove_lag(self.client, self.olag3)
        sai_thrift_remove_lag_member(self.client, self.olag2_member2)
        sai_thrift_remove_lag_member(self.client, self.olag2_member1)
        sai_thrift_remove_lag(self.client, self.olag2)

        sai_thrift_remove_lag_member(self.client, self.olag1_member2)
        sai_thrift_remove_lag_member(self.client, self.olag1_member1)
        sai_thrift_remove_lag(self.client, self.olag1)

        super(VxLanRifsConfigTunnelIpv6UnderlayOportsTest, self).tearDown()

    def portsToPortsConfigTest(self):
        '''
        Verify tunnel encap/decap for following underlay configuration:
            L3 Port, L3 LAG, L3 Subport, SVI: [Tagged & Untagged, Port & LAG]
        '''
        print("\nportsToPortsConfigTest()")

        vm1_ip = "100.1.1.1"
        vm2_ip = "100.2.1.1"
        vm3_ip = "100.3.1.1"
        vm4_ips = ["100.41.1.1", "100.42.1.1", "100.43.1.1", "100.44.1.1"]
        vm1_ipv6 = "2001:0db8::1:1:1"
        vm2_ipv6 = "2001:0db8::2:1:1"
        vm3_ipv6 = "2001:0db8::3:1:1"
        vm4_ipsv6 = ["2001:0db8::41:1:1", "2001:0db8::42:1:1",
                     "2001:0db8::43:1:1", "2001:0db8::44:1:1"]
        tun_ip1 = "2001:0db8::1:10:1"
        tun_ip2 = "2001:0db8::2:10:1"
        tun_ip3 = "2001:0db8::3:10:1"
        tun_ips4 = ["2001:0db8::41:10:1", "2001:0db8::42:10:1",
                    "2001:0db8::43:10:1", "2001:0db8::44:10:1"]
        lpb_ip1 = "2001:0db8::1:10:10"
        lpb_ip2 = "2001:0db8::2:10:10"
        lpb_ip3 = "2001:0db8::3:10:10"
        lpb_ips4 = ["2001:0db8::41:10:10", "2001:0db8::42:10:10",
                    "2001:0db8::43:10:10", "2001:0db8::44:10:10"]
        unbor1_mac = "00:33:33:33:33:01"
        unbor2_mac = "00:33:33:33:33:02"
        unbor3_mac = "00:33:33:33:33:03"
        unbor4_macs = ["00:33:33:33:33:41", "00:33:33:33:33:42",
                       "00:33:33:33:33:43", "00:33:33:33:33:44"]

        urif_list = []
        unhop_list = []
        unbor_list = []
        tunnel_term_list = []
        tunnel_route_list = []
        tunnel_nhop_list = []
        vm_route_list = []

        try:
            ##########################
            # underlay configuration #
            ##########################

            # urif1 - regular L3 (port10)
            uport1 = self.port10
            uport1_dev = self.dev_port10

            udata1 = {"uname": "L3 Port",
                      "vm_ip": vm1_ip,
                      "vm_ipv6": vm1_ipv6,
                      "unbor_mac": unbor1_mac,
                      "tun_ip": tun_ip1,
                      "lpb_ip": lpb_ip1,
                      "tunnel_route": True,
                      "vm_route": True}

            urif, unhop, unbor, tunnel_nhop, vm_route, tunnel_term, \
                tunnel_route = self._configureUrif(uport1, udata1)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif2 - L3 subport (port11)
            uport2 = self.port11
            uport2_dev = self.dev_port11
            u2_vlan_no = 202

            udata2 = {"uname": "L3 Subport",
                      "vm_ip": vm2_ip,
                      "vm_ipv6": vm2_ipv6,
                      "unbor_mac": unbor2_mac,
                      "tun_ip": tun_ip2,
                      "lpb_ip": lpb_ip2,
                      "vlan_no": u2_vlan_no,
                      "tunnel_route": True,
                      "vm_route": True}

            urif, unhop, unbor, tunnel_nhop, vm_route, tunnel_term,\
                tunnel_route = self._configureUrif(
                    uport2, udata2,
                    rif_type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif3 - L3 LAG (port12, port13)
            uports3 = [self.port12, self.port13]
            uports3_dev = [self.dev_port12, self.dev_port13]

            udata3 = {"uname": "L3 LAG",
                      "vm_ip": vm3_ip,
                      "vm_ipv6": vm3_ipv6,
                      "unbor_mac": unbor3_mac,
                      "tun_ip": tun_ip3,
                      "lpb_ip": lpb_ip3,
                      "tunnel_route": True,
                      "vm_route": True}

            ulag1 = sai_thrift_create_lag(self.client)
            ulag1_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports3[0])
            ulag1_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports3[1])

            urif, unhop, unbor, tunnel_nhop, vm_route, tunnel_term, \
                tunnel_route = self._configureUrif(ulag1, udata3)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif4 - SVI (port14, port15, [port16, port17], [port18, port19])
            # (untagged port, tagged port, untagged LAG, tagged LAG)
            uports4 = [self.port14, self.port15, [self.port16, self.port17],
                       [self.port18, self.port19]]
            uports4_dev = [[self.dev_port14], [self.dev_port15],
                           [self.dev_port16, self.dev_port17],
                           [self.dev_port18, self.dev_port19]]
            u4_vlan_no = 402

            udata4 = {"uname": "SVI",
                      "vm_ip": vm4_ips,
                      "vm_ipv6": vm4_ipsv6,
                      "unbor_mac": unbor4_macs,
                      "tun_ip": tun_ips4,
                      "lpb_ip": lpb_ips4,
                      "vlan_no": [0, u4_vlan_no, 0, u4_vlan_no],
                      "tunnel_route": True,
                      "vm_route": True}

            ulag2 = sai_thrift_create_lag(self.client)
            ulag2_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports4[2][0])
            ulag2_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports4[2][1])

            ulag3 = sai_thrift_create_lag(self.client)
            ulag3_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports4[3][0])
            ulag3_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports4[3][1])

            uport_bp1 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports4[0],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uport_bp2 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports4[1],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag2_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag2,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag3_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag3,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uvlan = sai_thrift_create_vlan(self.client, vlan_id=u4_vlan_no)
            uvlan_member1 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp1,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_port_attribute(self.client, uports4[0],
                                          port_vlan_id=u4_vlan_no)
            uvlan_member2 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp2,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)
            uvlan_member3 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag2_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=u4_vlan_no)
            uvlan_member4 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag3_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

            urif, unhops, unbors, tunnel_nhops, vm_routes, tunnel_terms, \
                tunnel_routes = self._configureUrif(
                    uvlan, udata4,
                    bridge_ports=[uport_bp1, uport_bp2, ulag2_bp, ulag3_bp],
                    rif_type=SAI_ROUTER_INTERFACE_TYPE_VLAN)

            urif_list.append(urif)
            unhop_list.extend(unhops)
            unbor_list.extend(unbors)
            tunnel_nhop_list.extend(tunnel_nhops)
            vm_route_list.extend(vm_routes)
            tunnel_term_list.extend(tunnel_terms)
            tunnel_route_list.extend(tunnel_routes)

            for oport, odata in zip([self.oport1_dev, self.oport2_dev,
                                     self.oports3_dev, self.oports4_dev],
                                    [self.odata1, self.odata2,
                                     self.odata3, self.odata4]):
                for uport, udata in zip([uport1_dev, uport2_dev,
                                         uports3_dev, uports4_dev],
                                        [udata1, udata2, udata3, udata4]):
                    self._verifyEncap(oport, uport, odata, udata)
                    self._verifyDecap(oport, uport, odata, udata)

        finally:
            sai_thrift_flush_fdb_entries(
                self.client, entry_type=SAI_FDB_FLUSH_ENTRY_TYPE_ALL)

            for vm_route in vm_route_list:
                sai_thrift_remove_route_entry(self.client, vm_route)

            for tunnel_route, tunnel_term, tunnel_nhop, unbor, \
                unhop in zip(tunnel_route_list, tunnel_term_list,
                             tunnel_nhop_list, unbor_list,
                             unhop_list):
                sai_thrift_remove_route_entry(self.client, tunnel_route)
                sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                          tunnel_term)
                sai_thrift_remove_next_hop(self.client, tunnel_nhop)
                sai_thrift_remove_neighbor_entry(self.client, unbor)
                sai_thrift_remove_next_hop(self.client, unhop)

            for urif in urif_list:
                sai_thrift_remove_router_interface(self.client, urif)

            sai_thrift_remove_vlan_member(self.client, uvlan_member4)
            sai_thrift_set_lag_attribute(self.client, ulag2, port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member3)
            sai_thrift_set_port_attribute(self.client, uports4[0],
                                          port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member2)
            sai_thrift_remove_vlan_member(self.client, uvlan_member1)
            sai_thrift_remove_vlan(self.client, uvlan)
            sai_thrift_remove_bridge_port(self.client, ulag3_bp)
            sai_thrift_remove_bridge_port(self.client, ulag2_bp)
            sai_thrift_remove_bridge_port(self.client, uport_bp2)
            sai_thrift_remove_bridge_port(self.client, uport_bp1)
            sai_thrift_remove_lag_member(self.client, ulag3_member2)
            sai_thrift_remove_lag_member(self.client, ulag3_member1)
            sai_thrift_remove_lag(self.client, ulag3)
            sai_thrift_remove_lag_member(self.client, ulag2_member2)
            sai_thrift_remove_lag_member(self.client, ulag2_member1)
            sai_thrift_remove_lag(self.client, ulag2)

            sai_thrift_remove_lag_member(self.client, ulag1_member2)
            sai_thrift_remove_lag_member(self.client, ulag1_member1)
            sai_thrift_remove_lag(self.client, ulag1)

    def portsToEcmpConfigTest(self):
        '''
        Verify tunnel encap/decap for following underlay configuration:
            ECMP: (L3 Port, L3 Subport, L3LAG,  SVI: [Tagged & Untagged,
            Port & LAG])
        '''
        print("\nportsToEcmpConfigTest()")

        vm1_ip = "100.1.1.1"
        vm2_ip = "100.2.1.1"
        vm3_ip = "100.3.1.1"
        vm4_ips = ["100.41.1.1", "100.42.1.1", "100.43.1.1", "100.44.1.1"]
        vm1_ipv6 = "2001:0db8::1:1:1"
        vm2_ipv6 = "2001:0db8::2:1:1"
        vm3_ipv6 = "2001:0db8::3:1:1"
        vm4_ipsv6 = ["2001:0db8::41:1:1", "2001:0db8::42:1:1",
                     "2001:0db8::43:1:1", "2001:0db8::44:1:1"]
        tun_ip1 = "2001:0db8::1:10:1"
        tun_ip2 = "2001:0db8::2:10:1"
        tun_ip3 = "2001:0db8::3:10:1"
        tun_ips4 = ["2001:0db8::41:10:1", "2001:0db8::42:10:1",
                    "2001:0db8::43:10:1", "2001:0db8::44:10:1"]
        unbor1_mac = "00:33:33:33:33:01"
        unbor2_mac = "00:33:33:33:33:02"
        unbor3_mac = "00:33:33:33:33:03"
        unbor4_macs = ["00:33:33:33:33:41", "00:33:33:33:33:42",
                       "00:33:33:33:33:43", "00:33:33:33:33:44"]

        urif_list = []
        unhop_list = []
        unbor_list = []
        tunnel_nhop_list = []
        vm_route_list = []
        uecmp_member_list = []

        try:
            ##########################
            # underlay configuration #
            ##########################

            # urif1 - regular L3 (port10)
            uport1 = self.port10
            uport1_dev = self.dev_port10

            udata1 = {"uname": "L3 Port",
                      "vm_ip": vm1_ip,
                      "vm_ipv6": vm1_ipv6,
                      "unbor_mac": unbor1_mac,
                      "tun_ip": tun_ip1,
                      "tunnel_route": False,
                      "vm_route": True}

            urif, unhop, unbor, tunnel_nhop, vm_route, _, _ = \
                self._configureUrif(uport1, udata1)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)

            # urif2 - L3 subport (port11)
            uport2 = self.port11
            uport2_dev = self.dev_port11
            u2_vlan_no = 202

            udata2 = {"uname": "L3 Subport",
                      "vm_ip": vm2_ip,
                      "vm_ipv6": vm2_ipv6,
                      "unbor_mac": unbor2_mac,
                      "tun_ip": tun_ip2,
                      "vlan_no": u2_vlan_no,
                      "tunnel_route": False,
                      "vm_route": True}

            urif, unhop, unbor, tunnel_nhop, vm_route, _, _ = \
                self._configureUrif(
                    uport2, udata2,
                    rif_type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)

            # urif3 - L3 LAG (port12, port13)
            uports3 = [self.port12, self.port13]
            uports3_dev = [self.dev_port12, self.dev_port13]

            udata3 = {"uname": "L3 LAG",
                      "vm_ip": vm3_ip,
                      "vm_ipv6": vm3_ipv6,
                      "unbor_mac": unbor3_mac,
                      "tun_ip": tun_ip3,
                      "tunnel_route": False,
                      "vm_route": True}

            ulag1 = sai_thrift_create_lag(self.client)
            ulag1_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports3[0])
            ulag1_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports3[1])

            urif, unhop, unbor, tunnel_nhop, vm_route, _, _ = \
                self._configureUrif(ulag1, udata3)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)

            # urif4 - SVI (port14, port15, [port16, port17], [port18, port19])
            # (untagged port, tagged port, untagged LAG, tagged LAG)
            uports4 = [self.port14, self.port15, [self.port16, self.port17],
                       [self.port18, self.port19]]
            uports4_dev = [[self.dev_port14], [self.dev_port15],
                           [self.dev_port16, self.dev_port17],
                           [self.dev_port18, self.dev_port19]]
            u4_vlan_no = 402

            udata4 = {"uname": "SVI",
                      "vm_ip": vm4_ips,
                      "vm_ipv6": vm4_ipsv6,
                      "unbor_mac": unbor4_macs,
                      "tun_ip": tun_ips4,
                      "vlan_no": [0, u4_vlan_no, 0, u4_vlan_no],
                      "tunnel_route": False,
                      "vm_route": True}

            ulag2 = sai_thrift_create_lag(self.client)
            ulag2_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports4[2][0])
            ulag2_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports4[2][1])

            ulag3 = sai_thrift_create_lag(self.client)
            ulag3_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports4[3][0])
            ulag3_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports4[3][1])

            uport_bp1 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports4[0],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uport_bp2 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports4[1],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag2_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag2,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag3_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag3,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uvlan = sai_thrift_create_vlan(self.client, vlan_id=u4_vlan_no)
            uvlan_member1 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp1,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_port_attribute(self.client, uports4[0],
                                          port_vlan_id=u4_vlan_no)
            uvlan_member2 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp2,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)
            uvlan_member3 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag2_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=u4_vlan_no)
            uvlan_member4 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag3_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

            urif, unhops, unbors, tunnel_nhops, vm_routes, _, _ = \
                self._configureUrif(uvlan, udata4,
                                    bridge_ports=[uport_bp1, uport_bp2,
                                                  ulag2_bp, ulag3_bp],
                                    rif_type=SAI_ROUTER_INTERFACE_TYPE_VLAN)

            urif_list.append(urif)
            unhop_list.extend(unhops)
            unbor_list.extend(unbors)
            tunnel_nhop_list.extend(tunnel_nhops)
            vm_route_list.extend(vm_routes)

            uecmp = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            for unhop in unhop_list:
                uecmp_member = sai_thrift_create_next_hop_group_member(
                    self.client, next_hop_group_id=uecmp, next_hop_id=unhop)
                uecmp_member_list.append(uecmp_member)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(tun_ip1 + '/80'))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=uecmp)

            uports = [uport1_dev, uport2_dev, uports3_dev, uports4_dev]
            underlay_data = [udata1, udata2, udata3, udata4]
            oports = [self.oport1_dev, self.oport2_dev,
                      self.oports3_dev, self.oports4_dev]
            overlay_data = [self.odata1, self.odata2, self.odata3, self.odata4]

            for oport, odata in zip(oports, overlay_data):
                self._verifyEcmpEncap(oport, uports, [odata, underlay_data])

                for uport, udata in zip(uports, underlay_data):
                    self._verifyDecap(oport, uport, odata, udata)

            # random add/delete ECMP member verification
            index = random.randrange(len(oports))
            self._addDelEcmpMemberTest(oports[index], uports,
                                       [overlay_data[index], underlay_data],
                                       uecmp_member_list)

            # load balancing test
            self._loadBalancingTest(self.oport1_dev, uports,
                                    self.odata1, underlay_data)

        finally:
            sai_thrift_flush_fdb_entries(
                self.client, entry_type=SAI_FDB_FLUSH_ENTRY_TYPE_ALL)

            sai_thrift_remove_route_entry(self.client, tunnel_route)

            for vm_route in vm_route_list:
                sai_thrift_remove_route_entry(self.client, vm_route)

            for ecmp_member, tunnel_nhop, unbor, unhop in zip(
                    uecmp_member_list, tunnel_nhop_list, unbor_list,
                    unhop_list):
                sai_thrift_remove_next_hop_group_member(self.client,
                                                        ecmp_member)
                sai_thrift_remove_next_hop(self.client, tunnel_nhop)
                sai_thrift_remove_neighbor_entry(self.client, unbor)
                sai_thrift_remove_next_hop(self.client, unhop)

            sai_thrift_remove_next_hop_group(self.client, uecmp)

            for urif in urif_list:
                sai_thrift_remove_router_interface(self.client, urif)

            sai_thrift_remove_vlan_member(self.client, uvlan_member4)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member3)
            sai_thrift_set_port_attribute(self.client, uports4[0],
                                          port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member2)
            sai_thrift_remove_vlan_member(self.client, uvlan_member1)
            sai_thrift_remove_vlan(self.client, uvlan)
            sai_thrift_remove_bridge_port(self.client, ulag3_bp)
            sai_thrift_remove_bridge_port(self.client, ulag2_bp)
            sai_thrift_remove_bridge_port(self.client, uport_bp2)
            sai_thrift_remove_bridge_port(self.client, uport_bp1)
            sai_thrift_remove_lag_member(self.client, ulag3_member2)
            sai_thrift_remove_lag_member(self.client, ulag3_member1)
            sai_thrift_remove_lag(self.client, ulag3)
            sai_thrift_remove_lag_member(self.client, ulag2_member2)
            sai_thrift_remove_lag_member(self.client, ulag2_member1)
            sai_thrift_remove_lag(self.client, ulag2)

            sai_thrift_remove_lag_member(self.client, ulag1_member2)
            sai_thrift_remove_lag_member(self.client, ulag1_member1)
            sai_thrift_remove_lag(self.client, ulag1)

    def portsToPortsEcmpConfigTest(self):
        '''
        Verify tunnel encap/decap for following underlay configuration:
            ECMP of L3 Ports, L3 Subport, L3 LAG, SVI: [Tagged & Untagged,
            Port & LAG]
        '''
        print("\nportsToPortsEcmpConfigTest()")

        vm1_ip = "100.1.1.1"
        vm2_ip = "100.2.1.1"
        vm3_ip = "100.3.1.1"
        vm4_ip = "100.4.1.1"
        vm5_ip = "100.5.1.1"
        vm6_ips = ["100.61.1.1", "100.62.1.1", "100.63.1.1", "100.64.1.1"]
        vm1_ipv6 = "2001:0db8::1:1:1"
        vm2_ipv6 = "2001:0db8::2:1:1"
        vm3_ipv6 = "2001:0db8::3:1:1"
        vm4_ipv6 = "2001:0db8::4:1:1"
        vm5_ipv6 = "2001:0db8::5:1:1"
        vm6_ipsv6 = ["2001:0db8::61:1:1", "2001:0db8::62:1:1",
                     "2001:0db8::63:1:1", "2001:0db8::64:1:1"]
        tun_ip1 = "2001:0db8::1:10:1"
        tun_ip2 = "2001:0db8::2:10:1"
        tun_ip3 = "2001:0db8::3:10:1"
        tun_ip4 = "2001:0db8::4:10:1"
        tun_ip5 = "2001:0db8::5:10:1"
        tun_ips6 = ["2001:0db8::61:10:1", "2001:0db8::62:10:1",
                    "2001:0db8::63:10:1", "2001:0db8::64:10:1"]
        lpb_ip4 = "2001:0db8::4:10"
        lpb_ip5 = "2001:0db8::5:10"
        lpb_ips6 = ["2001:0db8::61:10", "2001:0db8::62:10",
                    "2001:0db8::63:10", "2001:0db8::64:10"]
        unbor1_mac = "00:33:33:33:33:01"
        unbor2_mac = "00:33:33:33:33:02"
        unbor3_mac = "00:33:33:33:33:03"
        unbor4_mac = "00:33:33:33:33:04"
        unbor5_mac = "00:33:33:33:33:05"
        unbor6_macs = ["00:33:33:33:33:61", "00:33:33:33:33:62",
                       "00:33:33:33:33:63", "00:33:33:33:33:64"]

        urif_list = []
        unhop_list = []
        unbor_list = []
        tunnel_term_list = []
        tunnel_route_list = []
        tunnel_nhop_list = []
        vm_route_list = []
        uecmp_member_list = []

        try:
            ##########################
            # underlay configuration #
            ##########################

            # urif1 - regular L3 (port10)
            uport1 = self.port10
            uport1_dev = self.dev_port10

            udata1 = {"uname": "L3 Port ECMP",
                      "vm_ip": vm1_ip,
                      "vm_ipv6": vm1_ipv6,
                      "unbor_mac": unbor1_mac,
                      "tun_ip": tun_ip1,
                      "tunnel_route": False,
                      "vm_route": True}

            urif, unhop, unbor, tunnel_nhop, vm_route, _, _ = \
                self._configureUrif(uport1, udata1)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)

            # urif2 - regular L3 (port11)
            uport2 = self.port11
            uport2_dev = self.dev_port11

            udata2 = {"uname": "L3 Port ECMP",
                      "vm_ip": vm2_ip,
                      "vm_ipv6": vm2_ipv6,
                      "unbor_mac": unbor2_mac,
                      "tun_ip": tun_ip2,
                      "tunnel_route": False,
                      "vm_route": True}

            urif, unhop, unbor, tunnel_nhop, vm_route, _, _ = \
                self._configureUrif(uport2, udata2)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)

            # urif3 - regular L3 (port12)
            uport3 = self.port12
            uport3_dev = self.dev_port12

            udata3 = {"uname": "L3 Port ECMP",
                      "vm_ip": vm3_ip,
                      "vm_ipv6": vm3_ipv6,
                      "unbor_mac": unbor3_mac,
                      "tun_ip": tun_ip3,
                      "tunnel_route": False,
                      "vm_route": True}

            urif, unhop, unbor, tunnel_nhop, vm_route, _, _ = \
                self._configureUrif(uport3, udata3)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)

            uecmp = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            for unhop in unhop_list:
                uecmp_member = sai_thrift_create_next_hop_group_member(
                    self.client, next_hop_group_id=uecmp, next_hop_id=unhop)
                uecmp_member_list.append(uecmp_member)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(tun_ip1 + '/80'))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=uecmp)
            tunnel_route_list.append(tunnel_route)

            # urif4 - L3 subport (port13)
            uport4 = self.port13
            uport4_dev = self.dev_port13
            u4_vlan_no = 402

            udata4 = {"uname": "L3 Subport",
                      "vm_ip": vm4_ip,
                      "vm_ipv6": vm4_ipv6,
                      "unbor_mac": unbor4_mac,
                      "tun_ip": tun_ip4,
                      "lpb_ip": lpb_ip4,
                      "vlan_no": u4_vlan_no,
                      "tunnel_route": True,
                      "vm_route": True}

            urif, unhop, unbor, tunnel_nhop, vm_route, tunnel_term,\
                tunnel_route = self._configureUrif(
                    uport4, udata4,
                    rif_type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif5 - L3 LAG (port14, port15)
            uports5 = [self.port14, self.port15]
            uports5_dev = [self.dev_port14, self.dev_port15]

            udata5 = {"uname": "L3 LAG",
                      "vm_ip": vm5_ip,
                      "vm_ipv6": vm5_ipv6,
                      "unbor_mac": unbor5_mac,
                      "tun_ip": tun_ip5,
                      "lpb_ip": lpb_ip5,
                      "tunnel_route": True,
                      "vm_route": True}

            ulag1 = sai_thrift_create_lag(self.client)
            ulag1_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports5[0])
            ulag1_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports5[1])

            urif, unhop, unbor, tunnel_nhop, vm_route, tunnel_term, \
                tunnel_route = self._configureUrif(ulag1, udata5)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_nhop_list.extend(tunnel_nhop)
            vm_route_list.extend(vm_route)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif6 - SVI (port16, port17, [port18, port19], [port20, port21])
            # (untagged port, tagged port, untagged LAG, tagged LAG)
            uports6 = [self.port16, self.port17, [self.port18, self.port19],
                       [self.port20, self.port21]]
            uports6_dev = [[self.dev_port16], [self.dev_port17],
                           [self.dev_port18, self.dev_port19],
                           [self.dev_port20, self.dev_port21]]
            u6_vlan_no = 602

            udata6 = {"uname": "SVI",
                      "vm_ip": vm6_ips,
                      "vm_ipv6": vm6_ipsv6,
                      "unbor_mac": unbor6_macs,
                      "tun_ip": tun_ips6,
                      "lpb_ip": lpb_ips6,
                      "vlan_no": [0, u6_vlan_no, 0, u6_vlan_no],
                      "tunnel_route": True,
                      "vm_route": True}

            ulag2 = sai_thrift_create_lag(self.client)
            ulag2_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports6[2][0])
            ulag2_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports6[2][1])

            ulag3 = sai_thrift_create_lag(self.client)
            ulag3_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports6[3][0])
            ulag3_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports6[3][1])

            uport_bp1 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports6[0],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uport_bp2 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports6[1],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag2_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag2,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag3_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag3,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uvlan = sai_thrift_create_vlan(self.client, vlan_id=u6_vlan_no)
            uvlan_member1 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp1,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_port_attribute(self.client, uports6[0],
                                          port_vlan_id=u6_vlan_no)
            uvlan_member2 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp2,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)
            uvlan_member3 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag2_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=u6_vlan_no)
            uvlan_member4 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag3_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

            urif, unhops, unbors, tunnel_nhops, vm_routes, tunnel_terms, \
                tunnel_routes = self._configureUrif(
                    uvlan, udata6,
                    bridge_ports=[uport_bp1, uport_bp2, ulag2_bp, ulag3_bp],
                    rif_type=SAI_ROUTER_INTERFACE_TYPE_VLAN)

            urif_list.append(urif)
            unhop_list.extend(unhops)
            unbor_list.extend(unbors)
            tunnel_nhop_list.extend(tunnel_nhops)
            vm_route_list.extend(vm_routes)
            tunnel_term_list.extend(tunnel_terms)
            tunnel_route_list.extend(tunnel_routes)

            ecmp_uports = [uport1_dev, uport2_dev, uport3_dev]
            ecmp_udata = [udata1, udata2, udata3]
            oports = [self.oport1_dev, self.oport2_dev,
                      self.oports3_dev, self.oports4_dev]
            overlay_data = [self.odata1, self.odata2, self.odata3, self.odata4]

            for oport, odata in zip(oports, overlay_data):
                for uport, udata in zip([uport4_dev, uports5_dev, uports6_dev],
                                        [udata4, udata5, udata6]):
                    self._verifyEncap(oport, uport, odata, udata)
                    self._verifyDecap(oport, uport, odata, udata)

                self._verifyEcmpEncap(oport, ecmp_uports, [odata, ecmp_udata])

                for uport, udata in zip(
                        [uport1_dev, uport2_dev, uport3_dev],
                        [udata1, udata2, udata3]):
                    self._verifyDecap(oport, uport, odata, udata)

            # random add/delete ECMP member verification
            index = random.randrange(len(oports))
            self._addDelEcmpMemberTest(oports[index], ecmp_uports,
                                       [overlay_data[index], ecmp_udata],
                                       uecmp_member_list)

        finally:
            sai_thrift_flush_fdb_entries(
                self.client, entry_type=SAI_FDB_FLUSH_ENTRY_TYPE_ALL)

            for tunnel_route in tunnel_route_list:
                sai_thrift_remove_route_entry(self.client, tunnel_route)

            for tunnel_term in tunnel_term_list:
                sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                          tunnel_term)

            for ecmp_member in uecmp_member_list:
                sai_thrift_remove_next_hop_group_member(self.client,
                                                        ecmp_member)

            sai_thrift_remove_next_hop_group(self.client, uecmp)

            for vm_route in vm_route_list:
                sai_thrift_remove_route_entry(self.client, vm_route)

            for tunnel_nhop, unbor, unhop in zip(
                    tunnel_nhop_list, unbor_list, unhop_list):
                sai_thrift_remove_next_hop(self.client, tunnel_nhop)
                sai_thrift_remove_neighbor_entry(self.client, unbor)
                sai_thrift_remove_next_hop(self.client, unhop)

            for urif in urif_list:
                sai_thrift_remove_router_interface(self.client, urif)

            sai_thrift_remove_vlan_member(self.client, uvlan_member4)
            sai_thrift_set_lag_attribute(self.client, ulag2, port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member3)
            sai_thrift_set_port_attribute(self.client, uports6[0],
                                          port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member2)
            sai_thrift_remove_vlan_member(self.client, uvlan_member1)
            sai_thrift_remove_vlan(self.client, uvlan)
            sai_thrift_remove_bridge_port(self.client, ulag3_bp)
            sai_thrift_remove_bridge_port(self.client, ulag2_bp)
            sai_thrift_remove_bridge_port(self.client, uport_bp1)
            sai_thrift_remove_bridge_port(self.client, uport_bp2)
            sai_thrift_remove_lag_member(self.client, ulag3_member2)
            sai_thrift_remove_lag_member(self.client, ulag3_member1)
            sai_thrift_remove_lag(self.client, ulag3)
            sai_thrift_remove_lag_member(self.client, ulag2_member2)
            sai_thrift_remove_lag_member(self.client, ulag2_member1)
            sai_thrift_remove_lag(self.client, ulag2)

            sai_thrift_remove_lag_member(self.client, ulag1_member2)
            sai_thrift_remove_lag_member(self.client, ulag1_member1)
            sai_thrift_remove_lag(self.client, ulag1)


@group("draft")
class VxLanRifsConfigTunnelIpv6UnderlayOecmpTest(VxLanRifsConfigBaseSetup):
    '''
    Multipoint-to-multipoint tunnel tests regarding different overlay-underlay
    interfaces configutrations with IPv6 underlay layer and overlay ECMP.
    '''

    def __init__(self):
        super(VxLanRifsConfigTunnelIpv6UnderlayOecmpTest, self).__init__(
            ipv6=True)

    def setUp(self):
        super(VxLanRifsConfigTunnelIpv6UnderlayOecmpTest, self).setUp()

        customer_ip = "100.1.2.1"
        customer_ipv6 = "2001:0db8::1:2:1"
        customer_mac = "00:22:22:22:22:01"
        self.vm_ip = "100.1.1.1"
        self.vm_ipv6 = "2001:0db8::1:1:1"

        #########################
        # overlay configuration #
        #########################

        # orif - L3 port (port0)
        self.oport = self.port0
        self.oport_dev = self.dev_port0
        self.odata = {"oname": "Overlay L3 port",
                      "customer_mac": customer_mac,
                      "customer_ip": customer_ip,
                      "customer_ipv6": customer_ipv6,
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6}

        self.tunnel_ecmp = sai_thrift_create_next_hop_group(
            self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

    def runTest(self):
        self.ecmpToPortsConfigTest()
        self.ecmpToEcmpConfigTest()
        self.ecmpToPortsEcmpConfigTest()

    def tearDown(self):
        sai_thrift_remove_next_hop_group(self.client, self.tunnel_ecmp)

        super(VxLanRifsConfigTunnelIpv6UnderlayOecmpTest, self).tearDown()

    def ecmpToPortsConfigTest(self):
        '''
        Verify tunnel encap/decap for following underlay configuration:
            L3 Port, L3 LAG, L3 Subport, SVI: [Tagged & Untagged, Port & LAG]
        '''
        print("\necmpToPortsConfigTest()")

        tun_ip1 = "2001:0db8::1:10:1"
        tun_ip2 = "2001:0db8::2:10:1"
        tun_ip3 = "2001:0db8::3:10:1"
        tun_ips4 = ["2001:0db8::41:10:1", "2001:0db8::42:10:1",
                    "2001:0db8::43:10:1", "2001:0db8::44:10:1"]
        lpb_ip1 = "2001:0db8::1:10:10"
        lpb_ip2 = "2001:0db8::2:10:10"
        lpb_ip3 = "2001:0db8::3:10:10"
        lpb_ips4 = ["2001:0db8::41:10:10", "2001:0db8::42:10:10",
                    "2001:0db8::43:10:10", "2001:0db8::44:10:10"]
        unbor1_mac = "00:33:33:33:33:01"
        unbor2_mac = "00:33:33:33:33:02"
        unbor3_mac = "00:33:33:33:33:03"
        unbor4_macs = ["00:33:33:33:33:41", "00:33:33:33:33:42",
                       "00:33:33:33:33:43", "00:33:33:33:33:44"]

        urif_list = []
        unhop_list = []
        unbor_list = []
        tunnel_term_list = []
        tunnel_route_list = []

        try:
            #########################
            # overlay configuration #
            #########################

            # orif1 - L3 port (port0)
            tunnel_data = [tun_ip1, tun_ip2, tun_ip3]
            tunnel_data.extend(tun_ips4)

            orif, onhops, onbors, customer_routes, tunnel_nhops, \
                ecmp_members, vm_routes = self._configureOverlayEcmp(
                    self.oport, self.odata, tunnel_data, self.tunnel_ecmp)

            ##########################
            # underlay configuration #
            ##########################

            # urif1 - regular L3 (port1)
            uport1 = self.port1
            uport1_dev = self.dev_port1

            udata1 = {"uname": "L3 Port",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor1_mac,
                      "tun_ip": tun_ip1,
                      "lpb_ip": lpb_ip1,
                      "tunnel_route": True,
                      "vm_route": False}

            urif, unhop, unbor, _, _, tunnel_term, tunnel_route = \
                self._configureUrif(uport1, udata1)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif2 - L3 subport (port2)
            uport2 = self.port2
            uport2_dev = self.dev_port2
            u2_vlan_no = 202

            udata2 = {"uname": "L3 Subport",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor2_mac,
                      "tun_ip": tun_ip2,
                      "lpb_ip": lpb_ip2,
                      "vlan_no": u2_vlan_no,
                      "tunnel_route": True,
                      "vm_route": False}

            urif, unhop, unbor, _, _, tunnel_term, tunnel_route = \
                self._configureUrif(
                    uport2, udata2,
                    rif_type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif3 - L3 LAG (port3, port4)
            uports3 = [self.port3, self.port4]
            uports3_dev = [self.dev_port3, self.dev_port4]

            udata3 = {"uname": "L3 LAG",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor3_mac,
                      "tun_ip": tun_ip3,
                      "lpb_ip": lpb_ip3,
                      "tunnel_route": True,
                      "vm_route": False}

            ulag1 = sai_thrift_create_lag(self.client)
            ulag1_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports3[0])
            ulag1_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports3[1])

            urif, unhop, unbor, _, _, tunnel_term, tunnel_route = \
                self._configureUrif(ulag1, udata3)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif4 - SVI (port5, port6, [port7, port8], [port9, port10])
            # (untagged port, tagged port, untagged LAG, tagged LAG)
            uports4 = [self.port5, self.port6, [self.port7, self.port8],
                       [self.port9, self.port10]]
            uports4_dev = [[self.dev_port5], [self.dev_port6],
                           [self.dev_port7, self.dev_port8],
                           [self.dev_port9, self.dev_port10]]
            u4_vlan_no = 402

            udata4 = {"uname": "SVI",
                      "unbor_mac": unbor4_macs,
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "tun_ip": tun_ips4,
                      "lpb_ip": lpb_ips4,
                      "vlan_no": [0, u4_vlan_no, 0, u4_vlan_no],
                      "tunnel_route": True,
                      "vm_route": False}

            ulag2 = sai_thrift_create_lag(self.client)
            ulag2_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports4[2][0])
            ulag2_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports4[2][1])

            ulag3 = sai_thrift_create_lag(self.client)
            ulag3_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports4[3][0])
            ulag3_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports4[3][1])

            uport_bp1 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports4[0],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uport_bp2 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports4[1],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag2_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag2,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag3_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag3,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uvlan = sai_thrift_create_vlan(self.client, vlan_id=u4_vlan_no)
            uvlan_member1 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp1,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_port_attribute(self.client, uports4[0],
                                          port_vlan_id=u4_vlan_no)
            uvlan_member2 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp2,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)
            uvlan_member3 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag2_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=u4_vlan_no)
            uvlan_member4 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag3_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

            urif, unhops, unbors, _, _, tunnel_terms, tunnel_routes = \
                self._configureUrif(uvlan, udata4,
                                    bridge_ports=[uport_bp1, uport_bp2,
                                                  ulag2_bp, ulag3_bp],
                                    rif_type=SAI_ROUTER_INTERFACE_TYPE_VLAN)

            urif_list.append(urif)
            unhop_list.extend(unhops)
            unbor_list.extend(unbors)
            tunnel_term_list.extend(tunnel_terms)
            tunnel_route_list.extend(tunnel_routes)

            uports = [uport1_dev, uport2_dev]
            uports.extend(uports3_dev)
            uports.extend([port for sublist in uports4_dev
                           for port in sublist])

            underlay_data = [udata1, udata2, udata3]
            for i in range(len(uports4)):
                udata = {}
                for key, value in udata4.items():
                    udata[key] = value[i] if isinstance(value, list) else value
                underlay_data.append(udata)

            self._verifyEcmpEncap(self.oport_dev, uports,
                                  [self.odata, underlay_data],
                                  mode="overlay")

            for uport, udata in zip(
                    [uport1_dev, uport2_dev, uports3_dev, uports4_dev],
                    [udata1, udata2, udata3, udata4]):
                self._verifyDecap(self.oport_dev, uport, self.odata, udata)

        finally:
            sai_thrift_flush_fdb_entries(
                self.client, entry_type=SAI_FDB_FLUSH_ENTRY_TYPE_ALL)

            for tunnel_route, tunnel_term, unbor, unhop in zip(
                    tunnel_route_list, tunnel_term_list, unbor_list,
                    unhop_list):
                sai_thrift_remove_route_entry(self.client, tunnel_route)
                sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                          tunnel_term)
                sai_thrift_remove_neighbor_entry(self.client, unbor)
                sai_thrift_remove_next_hop(self.client, unhop)

            for urif in urif_list:
                sai_thrift_remove_router_interface(self.client, urif)

            sai_thrift_remove_vlan_member(self.client, uvlan_member4)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member3)
            sai_thrift_set_port_attribute(self.client, uports4[0],
                                          port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member2)
            sai_thrift_remove_vlan_member(self.client, uvlan_member1)
            sai_thrift_remove_vlan(self.client, uvlan)
            sai_thrift_remove_bridge_port(self.client, ulag3_bp)
            sai_thrift_remove_bridge_port(self.client, ulag2_bp)
            sai_thrift_remove_bridge_port(self.client, uport_bp2)
            sai_thrift_remove_bridge_port(self.client, uport_bp1)
            sai_thrift_remove_lag_member(self.client, ulag3_member2)
            sai_thrift_remove_lag_member(self.client, ulag3_member1)
            sai_thrift_remove_lag(self.client, ulag3)
            sai_thrift_remove_lag_member(self.client, ulag2_member2)
            sai_thrift_remove_lag_member(self.client, ulag2_member1)
            sai_thrift_remove_lag(self.client, ulag2)

            sai_thrift_remove_lag_member(self.client, ulag1_member2)
            sai_thrift_remove_lag_member(self.client, ulag1_member1)
            sai_thrift_remove_lag(self.client, ulag1)

        for vm_route, customer_route, onbor, onhop in zip(
                vm_routes, customer_routes, onbors, onhops):
            sai_thrift_remove_route_entry(self.client, vm_route)
            sai_thrift_remove_route_entry(self.client, customer_route)
            sai_thrift_remove_neighbor_entry(self.client, onbor)
            sai_thrift_remove_next_hop(self.client, onhop)

        sai_thrift_remove_router_interface(self.client, orif)

        for ecmp_member, tunnel_nhop in zip(ecmp_members, tunnel_nhops):
            sai_thrift_remove_next_hop_group_member(self.client,
                                                    ecmp_member)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def ecmpToEcmpConfigTest(self):
        '''
        Verify tunnel encap/decap for following underlay configuration:
            ECMP: (L3 Port, L3 Subport, L3 LAG SVI: [Tagged & Untagged,
            Port & LAG])
        '''
        print("\necmpToEcmpConfigTest()")

        tun_ip1 = "2001:0db8::1:10:1"
        tun_ip2 = "2001:0db8::2:10:1"
        tun_ip3 = "2001:0db8::3:10:1"
        tun_ips4 = ["2001:0db8::41:10:1", "2001:0db8::42:10:1",
                    "2001:0db8::43:10:1", "2001:0db8::44:10:1"]
        unbor1_mac = "00:33:33:33:33:01"
        unbor2_mac = "00:33:33:33:33:02"
        unbor3_mac = "00:33:33:33:33:03"
        unbor4_macs = ["00:33:33:33:33:41", "00:33:33:33:33:42",
                       "00:33:33:33:33:43", "00:33:33:33:33:44"]

        urif_list = []
        unhop_list = []
        unbor_list = []
        uecmp_member_list = []

        try:
            #########################
            # overlay configuration #
            #########################

            # orif1 - L3 port (port0)
            tunnel_data = [tun_ip1, tun_ip2, tun_ip3]
            tunnel_data.extend(tun_ips4)

            orif, onhops, onbors, customer_routes, tunnel_nhops, \
                ecmp_members, vm_routes = self._configureOverlayEcmp(
                    self.oport, self.odata, tunnel_data, self.tunnel_ecmp)

            ##########################
            # underlay configuration #
            ##########################

            # urif1 - regular L3 (port1)
            uport1 = self.port1
            uport1_dev = self.dev_port1

            udata1 = {"uname": "L3 Port",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor1_mac,
                      "tun_ip": tun_ip1,
                      "tunnel_route": False,
                      "vm_route": False}

            urif, unhop, unbor, _, _, _, _ = self._configureUrif(uport1,
                                                                 udata1)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)

            # urif2 - L3 subport (port11)
            uport2 = self.port2
            uport2_dev = self.dev_port2
            u2_vlan_no = 202

            udata2 = {"uname": "L3 Subport",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor2_mac,
                      "tun_ip": tun_ip2,
                      "vlan_no": u2_vlan_no,
                      "tunnel_route": False,
                      "vm_route": False}

            urif, unhop, unbor, _, _, _, _ = self._configureUrif(
                uport2, udata2, rif_type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)

            # urif3 - L3 LAG (port3, port4)
            uports3 = [self.port3, self.port4]
            uports3_dev = [self.dev_port3, self.dev_port4]

            udata3 = {"uname": "L3 LAG",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor3_mac,
                      "tun_ip": tun_ip3,
                      "tunnel_route": False,
                      "vm_route": False}

            ulag1 = sai_thrift_create_lag(self.client)
            ulag1_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports3[0])
            ulag1_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports3[1])

            urif, unhop, unbor, _, _, _, _ = self._configureUrif(ulag1,
                                                                 udata3)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)

            # urif4 - SVI (port5, port6, [port7, port8], [port9, port10])
            # (untagged port, tagged port, untagged LAG, tagged LAG)
            uports4 = [self.port5, self.port6, [self.port7, self.port8],
                       [self.port9, self.port10]]
            uports4_dev = [[self.dev_port5], [self.dev_port6],
                           [self.dev_port7, self.dev_port8],
                           [self.dev_port9, self.dev_port10]]
            u4_vlan_no = 402

            udata4 = {"uname": "SVI",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor4_macs,
                      "tun_ip": tun_ips4,
                      "vlan_no": [0, u4_vlan_no, 0, u4_vlan_no],
                      "tunnel_route": False,
                      "vm_route": False}

            ulag2 = sai_thrift_create_lag(self.client)
            ulag2_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports4[2][0])
            ulag2_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports4[2][1])

            ulag3 = sai_thrift_create_lag(self.client)
            ulag3_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports4[3][0])
            ulag3_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports4[3][1])

            uport_bp1 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports4[0],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uport_bp2 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports4[1],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag2_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag2,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag3_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag3,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uvlan = sai_thrift_create_vlan(self.client, vlan_id=u4_vlan_no)
            uvlan_member1 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp1,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_port_attribute(self.client, uports4[0],
                                          port_vlan_id=u4_vlan_no)
            uvlan_member2 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp2,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)
            uvlan_member3 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag2_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=u4_vlan_no)
            uvlan_member4 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag3_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

            urif, unhops, unbors, _, _, _, _ = self._configureUrif(
                uvlan, udata4,
                bridge_ports=[uport_bp1, uport_bp2, ulag2_bp, ulag3_bp],
                rif_type=SAI_ROUTER_INTERFACE_TYPE_VLAN)

            urif_list.append(urif)
            unhop_list.extend(unhops)
            unbor_list.extend(unbors)

            uecmp = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            for unhop in unhop_list:
                uecmp_member = sai_thrift_create_next_hop_group_member(
                    self.client, next_hop_group_id=uecmp, next_hop_id=unhop)
                uecmp_member_list.append(uecmp_member)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(tun_ip1 + '/80'))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=uecmp)

            uports = [uport1_dev, uport2_dev]
            uports.extend(uports3_dev)
            uports.extend([port for sublist in uports4_dev
                           for port in sublist])

            underlay_data = [udata1, udata2, udata3]
            for i in range(len(uports4)):
                udata = {}
                for key, value in udata4.items():
                    udata[key] = value[i] if isinstance(value, list) else value
                underlay_data.append(udata)

            self._verifyEcmpEncap(self.oport_dev, uports,
                                  [self.odata, underlay_data],
                                  mode="both")

            for uport, udata in zip(
                    [uport1_dev, uport2_dev, uports3_dev, uports4_dev],
                    [udata1, udata2, udata3, udata4]):
                self._verifyDecap(self.oport_dev, uport, self.odata, udata)

        finally:
            sai_thrift_flush_fdb_entries(
                self.client, entry_type=SAI_FDB_FLUSH_ENTRY_TYPE_ALL)

            sai_thrift_remove_route_entry(self.client, tunnel_route)

            for ecmp_member, unbor, unhop in zip(uecmp_member_list,
                                                 unbor_list, unhop_list):
                sai_thrift_remove_next_hop_group_member(self.client,
                                                        ecmp_member)
                sai_thrift_remove_neighbor_entry(self.client, unbor)
                sai_thrift_remove_next_hop(self.client, unhop)

            sai_thrift_remove_next_hop_group(self.client, uecmp)

            for urif in urif_list:
                sai_thrift_remove_router_interface(self.client, urif)

            sai_thrift_remove_vlan_member(self.client, uvlan_member4)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member3)
            sai_thrift_set_port_attribute(self.client, uports4[0],
                                          port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member2)
            sai_thrift_remove_vlan_member(self.client, uvlan_member1)
            sai_thrift_remove_vlan(self.client, uvlan)
            sai_thrift_remove_bridge_port(self.client, ulag3_bp)
            sai_thrift_remove_bridge_port(self.client, ulag2_bp)
            sai_thrift_remove_bridge_port(self.client, uport_bp2)
            sai_thrift_remove_bridge_port(self.client, uport_bp1)
            sai_thrift_remove_lag_member(self.client, ulag3_member2)
            sai_thrift_remove_lag_member(self.client, ulag3_member1)
            sai_thrift_remove_lag(self.client, ulag3)
            sai_thrift_remove_lag_member(self.client, ulag2_member2)
            sai_thrift_remove_lag_member(self.client, ulag2_member1)
            sai_thrift_remove_lag(self.client, ulag2)

            sai_thrift_remove_lag_member(self.client, ulag1_member2)
            sai_thrift_remove_lag_member(self.client, ulag1_member1)
            sai_thrift_remove_lag(self.client, ulag1)

            for vm_route, customer_route, onbor, onhop in zip(
                    vm_routes, customer_routes, onbors, onhops):
                sai_thrift_remove_route_entry(self.client, vm_route)
                sai_thrift_remove_route_entry(self.client, customer_route)
                sai_thrift_remove_neighbor_entry(self.client, onbor)
                sai_thrift_remove_next_hop(self.client, onhop)

            sai_thrift_remove_router_interface(self.client, orif)

            for ecmp_member, tunnel_nhop in zip(ecmp_members, tunnel_nhops):
                sai_thrift_remove_next_hop_group_member(self.client,
                                                        ecmp_member)
                sai_thrift_remove_next_hop(self.client, tunnel_nhop)

    def ecmpToPortsEcmpConfigTest(self):
        '''
        Verify tunnel encap/decap for following underlay configuration:
            ECMP of L3 Ports, L3 Subport, L3 LAG,  SVI: [Tagged & Untagged,
            Port & LAG]
        '''
        print("\necmpToPortsEcmpConfigTest()")

        tun_ip1 = "2001:0db8::1:10:1"
        tun_ip2 = "2001:0db8::2:10:1"
        tun_ip3 = "2001:0db8::3:10:1"
        tun_ip4 = "2001:0db8::4:10:1"
        tun_ip5 = "2001:0db8::5:10:1"
        tun_ips6 = ["2001:0db8::61:10:1", "2001:0db8::62:10:1",
                    "2001:0db8::63:10:1", "2001:0db8::64:10:1"]
        lpb_ip4 = "2001:0db8::4:10"
        lpb_ip5 = "2001:0db8::5:10"
        lpb_ips6 = ["2001:0db8::61:10", "2001:0db8::62:10",
                    "2001:0db8::63:10", "2001:0db8::64:10"]
        unbor1_mac = "00:33:33:33:33:01"
        unbor2_mac = "00:33:33:33:33:02"
        unbor3_mac = "00:33:33:33:33:03"
        unbor4_mac = "00:33:33:33:33:04"
        unbor5_mac = "00:33:33:33:33:05"
        unbor6_macs = ["00:33:33:33:33:61", "00:33:33:33:33:62",
                       "00:33:33:33:33:63", "00:33:33:33:33:64"]

        urif_list = []
        unhop_list = []
        unbor_list = []
        tunnel_term_list = []
        tunnel_route_list = []
        uecmp_member_list = []

        try:
            #########################
            # overlay configuration #
            #########################

            # orif - L3 port (port0)
            tunnel_data = [tun_ip1, tun_ip2, tun_ip3, tun_ip4, tun_ip5]
            tunnel_data.extend(tun_ips6)

            orif, onhops, onbors, customer_routes, tunnel_nhops, \
                ecmp_members, vm_routes = self._configureOverlayEcmp(
                    self.oport, self.odata, tunnel_data, self.tunnel_ecmp)

            ##########################
            # underlay configuration #
            ##########################

            # urif1 - regular L3 (port1)
            uport1 = self.port1
            uport1_dev = self.dev_port1

            udata1 = {"uname": "L3 Port ECMP",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor1_mac,
                      "tun_ip": tun_ip1,
                      "tunnel_route": False,
                      "vm_route": False}

            urif, unhop, unbor, _, _, _, _ = self._configureUrif(uport1,
                                                                 udata1)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)

            # urif2 - regular L3 (port2)
            uport2 = self.port2
            uport2_dev = self.dev_port2

            udata2 = {"uname": "L3 Port ECMP",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor2_mac,
                      "tun_ip": tun_ip2,
                      "tunnel_route": False,
                      "vm_route": False}

            urif, unhop, unbor, _, _, _, _ = self._configureUrif(uport2,
                                                                 udata2)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)

            # urif3 - regular L3 (port3)
            uport3 = self.port3
            uport3_dev = self.dev_port3

            udata3 = {"uname": "L3 Port ECMP",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor3_mac,
                      "tun_ip": tun_ip3,
                      "tunnel_route": False,
                      "vm_route": False}

            urif, unhop, unbor, _, _, _, _ = self._configureUrif(uport3,
                                                                 udata3)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)

            uecmp = sai_thrift_create_next_hop_group(
                self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)

            for unhop in unhop_list:
                uecmp_member = sai_thrift_create_next_hop_group_member(
                    self.client, next_hop_group_id=uecmp, next_hop_id=unhop)
                uecmp_member_list.append(uecmp_member)

            tunnel_route = sai_thrift_route_entry_t(
                vr_id=self.uvrf,
                destination=sai_ipprefix(tun_ip1 + '/80'))
            sai_thrift_create_route_entry(self.client,
                                          tunnel_route,
                                          next_hop_id=uecmp)
            tunnel_route_list.append(tunnel_route)

            # urif4 - L3 subport (port4)
            uport4 = self.port4
            uport4_dev = self.dev_port4
            u4_vlan_no = 402

            udata4 = {"uname": "L3 Subport",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor4_mac,
                      "tun_ip": tun_ip4,
                      "lpb_ip": lpb_ip4,
                      "vlan_no": u4_vlan_no,
                      "tunnel_route": True,
                      "vm_route": False}

            urif, unhop, unbor, _, _, tunnel_term, tunnel_route = \
                self._configureUrif(
                    uport4, udata4,
                    rif_type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif5 - L3 LAG (port5, port6)
            uports5 = [self.port5, self.port6]
            uports5_dev = [self.dev_port5, self.dev_port6]

            udata5 = {"uname": "L3 LAG",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor5_mac,
                      "tun_ip": tun_ip5,
                      "lpb_ip": lpb_ip5,
                      "tunnel_route": True,
                      "vm_route": False}

            ulag1 = sai_thrift_create_lag(self.client)
            ulag1_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports5[0])
            ulag1_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag1, port_id=uports5[1])

            urif, unhop, unbor, _, _, tunnel_term, tunnel_route = \
                self._configureUrif(ulag1, udata5)

            urif_list.append(urif)
            unhop_list.extend(unhop)
            unbor_list.extend(unbor)
            tunnel_term_list.extend(tunnel_term)
            tunnel_route_list.extend(tunnel_route)

            # urif6 - SVI (port7, port8, [port9, port10], [port11, port12])
            # (untagged port, tagged port, untagged LAG, tagged LAG)
            uports6 = [self.port7, self.port8, [self.port9, self.port10],
                       [self.port11, self.port12]]
            uports6_dev = [[self.dev_port7], [self.dev_port8],
                           [self.dev_port9, self.dev_port10],
                           [self.dev_port11, self.dev_port12]]
            u6_vlan_no = 602

            udata6 = {"uname": "SVI",
                      "vm_ip": self.vm_ip,
                      "vm_ipv6": self.vm_ipv6,
                      "unbor_mac": unbor6_macs,
                      "tun_ip": tun_ips6,
                      "lpb_ip": lpb_ips6,
                      "vlan_no": [0, u6_vlan_no, 0, u6_vlan_no],
                      "tunnel_route": True,
                      "vm_route": False}

            ulag2 = sai_thrift_create_lag(self.client)
            ulag2_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports6[2][0])
            ulag2_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag2, port_id=uports6[2][1])

            ulag3 = sai_thrift_create_lag(self.client)
            ulag3_member1 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports6[3][0])
            ulag3_member2 = sai_thrift_create_lag_member(
                self.client, lag_id=ulag3, port_id=uports6[3][1])

            uport_bp1 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports6[0],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uport_bp2 = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=uports6[1],
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag2_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag2,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            ulag3_bp = sai_thrift_create_bridge_port(
                self.client,
                bridge_id=self.default_1q_bridge,
                port_id=ulag3,
                type=SAI_BRIDGE_PORT_TYPE_PORT,
                admin_state=True)

            uvlan = sai_thrift_create_vlan(self.client, vlan_id=u6_vlan_no)
            uvlan_member1 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp1,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_port_attribute(self.client, uports6[0],
                                          port_vlan_id=u6_vlan_no)
            uvlan_member2 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=uport_bp2,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)
            uvlan_member3 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag2_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=u6_vlan_no)
            uvlan_member4 = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=uvlan,
                bridge_port_id=ulag3_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

            urif, unhops, unbors, _, _, tunnel_terms, tunnel_routes = \
                self._configureUrif(uvlan, udata6,
                                    bridge_ports=[uport_bp1, uport_bp2,
                                                  ulag2_bp, ulag3_bp],
                                    rif_type=SAI_ROUTER_INTERFACE_TYPE_VLAN)

            urif_list.append(urif)
            unhop_list.extend(unhops)
            unbor_list.extend(unbors)
            tunnel_term_list.extend(tunnel_terms)
            tunnel_route_list.extend(tunnel_routes)

            underlay_data = [udata1, udata2, udata3, udata4, udata5]
            # split a dictionary with lists into a list of dictionaries
            mapped_udata6 = map(dict, zip(*[[(k, v) for v in value]
                                            for k, value in udata6.items()
                                            if isinstance(value, list)]))

            for entry in mapped_udata6:
                entry = dict(udata6, **entry)
                underlay_data.append(entry)

            uports = [uport1_dev, uport2_dev, uport3_dev, uport4_dev]
            uports.extend(uports5_dev)
            uports.extend([port for sublist in uports6_dev
                           for port in sublist])

            self._verifyEcmpEncap(self.oport_dev, uports,
                                  [self.odata, underlay_data],
                                  mode="both")

            for uport, udata in zip(
                    [uport1_dev, uport2_dev, uport3_dev, uport4_dev,
                     uports5_dev, uports6_dev],
                    [udata1, udata2, udata3, udata4, udata5, udata6]):
                self._verifyDecap(self.oport_dev, uport, self.odata, udata)

        finally:
            sai_thrift_flush_fdb_entries(
                self.client, entry_type=SAI_FDB_FLUSH_ENTRY_TYPE_ALL)

            for tunnel_route in tunnel_route_list:
                sai_thrift_remove_route_entry(self.client, tunnel_route)

            for tunnel_term in tunnel_term_list:
                sai_thrift_remove_tunnel_term_table_entry(self.client,
                                                          tunnel_term)

            for ecmp_member in uecmp_member_list:
                sai_thrift_remove_next_hop_group_member(self.client,
                                                        ecmp_member)

            sai_thrift_remove_next_hop_group(self.client, uecmp)

            for unbor, unhop in zip(unbor_list, unhop_list):
                sai_thrift_remove_neighbor_entry(self.client, unbor)
                sai_thrift_remove_next_hop(self.client, unhop)

            for urif in urif_list:
                sai_thrift_remove_router_interface(self.client, urif)

            sai_thrift_remove_vlan_member(self.client, uvlan_member4)
            sai_thrift_set_lag_attribute(self.client, ulag2,
                                         port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member3)
            sai_thrift_set_port_attribute(self.client, uports6[0],
                                          port_vlan_id=0)
            sai_thrift_remove_vlan_member(self.client, uvlan_member2)
            sai_thrift_remove_vlan_member(self.client, uvlan_member1)
            sai_thrift_remove_vlan(self.client, uvlan)
            sai_thrift_remove_bridge_port(self.client, ulag3_bp)
            sai_thrift_remove_bridge_port(self.client, ulag2_bp)
            sai_thrift_remove_bridge_port(self.client, uport_bp1)
            sai_thrift_remove_bridge_port(self.client, uport_bp2)
            sai_thrift_remove_lag_member(self.client, ulag3_member2)
            sai_thrift_remove_lag_member(self.client, ulag3_member1)
            sai_thrift_remove_lag(self.client, ulag3)
            sai_thrift_remove_lag_member(self.client, ulag2_member2)
            sai_thrift_remove_lag_member(self.client, ulag2_member1)
            sai_thrift_remove_lag(self.client, ulag2)

            sai_thrift_remove_lag_member(self.client, ulag1_member2)
            sai_thrift_remove_lag_member(self.client, ulag1_member1)
            sai_thrift_remove_lag(self.client, ulag1)

            for vm_route, customer_route, onbor, onhop in zip(
                    vm_routes, customer_routes, onbors, onhops):
                sai_thrift_remove_route_entry(self.client, vm_route)
                sai_thrift_remove_route_entry(self.client, customer_route)
                sai_thrift_remove_neighbor_entry(self.client, onbor)
                sai_thrift_remove_next_hop(self.client, onhop)

            sai_thrift_remove_router_interface(self.client, orif)

            for ecmp_member, tunnel_nhop in zip(ecmp_members, tunnel_nhops):
                sai_thrift_remove_next_hop_group_member(self.client,
                                                        ecmp_member)
                sai_thrift_remove_next_hop(self.client, tunnel_nhop)


# # # # # # # # # # # # # # VxLAN EVPN Tests follow # # # # # # # # # # # # # #
@group("draft")
class VxLanEvpnTest(SaiHelper):
    '''
    Tests for EVPN support
    '''

    def __init__(self):
        super(VxLanEvpnTest, self).__init__()

        self.tun1_ip = "10.0.0.65"
        self.lpb_ip = "10.1.0.32"
        self.tun_ip_mask = "/32"
        self.uport1_myip = "10.0.0.64"
        self.uport1_mask = "/31"

    def setUp(self):
        super(VxLanEvpnTest, self).setUp()

        self.oport1 = self.port0
        self.oport1_dev = self.dev_port0
        self.oport1_bp = self.port0_bp
        self.uport1 = self.port10
        self.uport1_dev = self.dev_port10
        self.uport1_rif = self.port10_rif

        self.vni1 = 1000
        self.vni_for_ovrf = 5000
        self.dummy_vlan_id = 50
        self.vlan10_myip = "192.168.100.254"
        self.vlan10_dir_br = "192.168.100.255"
        self.vlan20_myip = "192.168.200.254"
        self.vlan20_dir_br = "192.168.200.255"
        self.customer1_ip = "192.168.100.1"
        self.customer1_ipv6 = "2001:0db8::100:2"
        self.customer2_ip = "192.168.250.1"
        self.customer2_ipv6 = "2001:0db8::200:2"
        self.inner_dmac = "00:11:11:11:11:11"
        self.customer1_mac = "00:22:22:22:22:11"
        self.customer2_mac = "00:22:22:22:22:22"
        self.unbor1_mac = "00:33:33:33:33:11"
        self.bcast_mac = "ff:ff:ff:ff:ff:ff"

        # underlay loopback rif for tunnels
        self.urif_lpb = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_LOOPBACK,
            virtual_router_id=self.default_vrf,
            mtu=9100)

        # underlay my ip address + prefix
        self.uport1_my_route = sai_thrift_route_entry_t(
            destination=sai_ipprefix(self.uport1_myip + '/32'),
            switch_id=self.switch_id,
            vr_id=self.default_vrf)
        sai_thrift_create_route_entry(self.client,
                                      self.uport1_my_route,
                                      packet_action=SAI_PACKET_ACTION_FORWARD,
                                      next_hop_id=self.cpu_port_hdl)

        self.uport1_prefix_route = sai_thrift_route_entry_t(
            destination=sai_ipprefix(self.uport1_myip + self.uport1_mask),
            switch_id=self.switch_id,
            vr_id=self.default_vrf)
        sai_thrift_create_route_entry(self.client,
                                      self.uport1_prefix_route,
                                      next_hop_id=self.uport1_rif)

        # underlay neighbor
        self.unbor = sai_thrift_neighbor_entry_t(
            ip_address=sai_ipaddress(self.tun1_ip),
            rif_id=self.uport1_rif,
            switch_id=self.switch_id)
        sai_thrift_create_neighbor_entry(self.client,
                                         self.unbor,
                                         dst_mac_address=self.unbor1_mac)

        # underlay nexthop
        self.unhop = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_IP,
            ip=sai_ipaddress(self.tun1_ip),
            router_interface_id=self.uport1_rif)

        # create overlay vrf
        self.ovrf = sai_thrift_create_virtual_router(self.client)

        # create vlan10 rif, ip address, prefix
        self.vlan10_rif = sai_thrift_create_router_interface(
            self.client,
            virtual_router_id=self.ovrf,
            src_mac_address=ROUTER_MAC,
            type=SAI_ROUTER_INTERFACE_TYPE_VLAN,
            vlan_id=self.vlan10,
            mtu=9100,
            nat_zone_id=0)

        self.vlan10_my_route = sai_thrift_route_entry_t(
            destination=sai_ipprefix(self.vlan10_myip + '/32'),
            switch_id=self.switch_id,
            vr_id=self.ovrf)
        sai_thrift_create_route_entry(self.client,
                                      self.vlan10_my_route,
                                      packet_action=SAI_PACKET_ACTION_FORWARD,
                                      next_hop_id=self.cpu_port_hdl)

        self.vlan10_nbor_dir_br = sai_thrift_neighbor_entry_t(
            ip_address=sai_ipaddress(self.vlan10_dir_br),
            rif_id=self.vlan10_rif,
            switch_id=self.switch_id)
        sai_thrift_create_neighbor_entry(self.client,
                                         self.vlan10_nbor_dir_br,
                                         dst_mac_address=self.bcast_mac)

        self.vlan10_prefix_route = sai_thrift_route_entry_t(
            destination=sai_ipprefix(self.vlan10_myip + '/24'),
            switch_id=self.switch_id,
            vr_id=self.ovrf)
        sai_thrift_create_route_entry(self.client,
                                      self.vlan10_prefix_route,
                                      next_hop_id=self.vlan10_rif)

        # create vlan20 rif, ip address, prefix
        self.vlan20_rif = sai_thrift_create_router_interface(
            self.client,
            virtual_router_id=self.ovrf,
            src_mac_address=ROUTER_MAC,
            type=SAI_ROUTER_INTERFACE_TYPE_VLAN,
            vlan_id=self.vlan20,
            mtu=9100,
            nat_zone_id=0)

        self.vlan20_my_route = sai_thrift_route_entry_t(
            destination=sai_ipprefix(self.vlan20_myip + '/32'),
            switch_id=self.switch_id,
            vr_id=self.ovrf)
        sai_thrift_create_route_entry(self.client,
                                      self.vlan20_my_route,
                                      packet_action=SAI_PACKET_ACTION_FORWARD,
                                      next_hop_id=self.cpu_port_hdl)

        self.vlan20_nbor_dir_br = sai_thrift_neighbor_entry_t(
            ip_address=sai_ipaddress(self.vlan20_dir_br),
            rif_id=self.vlan20_rif,
            switch_id=self.switch_id)
        sai_thrift_create_neighbor_entry(self.client,
                                         self.vlan20_nbor_dir_br,
                                         dst_mac_address=self.bcast_mac)

        self.vlan20_prefix_route = sai_thrift_route_entry_t(
            destination=sai_ipprefix(self.vlan20_myip + '/24'),
            switch_id=self.switch_id,
            vr_id=self.ovrf)
        sai_thrift_create_route_entry(self.client,
                                      self.vlan20_prefix_route,
                                      next_hop_id=self.vlan20_rif)

        # create fdb entry, neighbor, nexthop for customer 1 on port0, vlan 10
        self.customer1_fdb_entry = sai_thrift_fdb_entry_t(
            bv_id=self.vlan10,
            mac_address=self.customer1_mac,
            switch_id=self.switch_id)
        sai_thrift_create_fdb_entry(self.client,
                                    self.customer1_fdb_entry,
                                    type=SAI_FDB_ENTRY_TYPE_DYNAMIC,
                                    bridge_port_id=self.oport1_bp)

        self.customer1_nbor = sai_thrift_neighbor_entry_t(
            ip_address=sai_ipaddress(self.customer1_ip),
            rif_id=self.vlan10_rif,
            switch_id=self.switch_id)
        sai_thrift_create_neighbor_entry(self.client,
                                         self.customer1_nbor,
                                         dst_mac_address=self.customer1_mac)

        self.customer1_nhop = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_IP,
            ip=sai_ipaddress(self.customer1_ip),
            router_interface_id=self.vlan10_rif)

    def runTest(self):
        self.vxLanL3EvpnPrefixTest()

    def tearDown(self):
        sai_thrift_flush_fdb_entries(
            self.client, entry_type=SAI_FDB_FLUSH_ENTRY_TYPE_ALL)

        sai_thrift_remove_next_hop(self.client, self.customer1_nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.customer1_nbor)
        sai_thrift_remove_route_entry(self.client, self.vlan10_prefix_route)
        sai_thrift_remove_neighbor_entry(self.client, self.vlan10_nbor_dir_br)
        sai_thrift_remove_route_entry(self.client, self.vlan10_my_route)
        sai_thrift_remove_router_interface(self.client, self.vlan10_rif)
        sai_thrift_remove_route_entry(self.client, self.vlan20_prefix_route)
        sai_thrift_remove_neighbor_entry(self.client, self.vlan20_nbor_dir_br)
        sai_thrift_remove_route_entry(self.client, self.vlan20_my_route)
        sai_thrift_remove_router_interface(self.client, self.vlan20_rif)
        sai_thrift_remove_virtual_router(self.client, self.ovrf)
        sai_thrift_remove_next_hop(self.client, self.unhop)
        sai_thrift_remove_neighbor_entry(self.client, self.unbor)
        sai_thrift_remove_route_entry(self.client, self.uport1_prefix_route)
        sai_thrift_remove_route_entry(self.client, self.uport1_my_route)
        sai_thrift_remove_router_interface(self.client, self.urif_lpb)

        super(VxLanEvpnTest, self).tearDown()

    def vxLanL3EvpnPrefixTest(self):
        '''
        This test Verify that packets are properly encapsulated and
        decapsulated after SAI API calls emulating SONiC L3 EVPN operation,
        specifically after receiving EVPN Type 5 (IP prefix) routes.
        '''
        print("\nvxLanL3EvpnPrefixTest()")

        tunnel_type = SAI_TUNNEL_TYPE_VXLAN
        peer_mode = SAI_TUNNEL_PEER_MODE_P2MP
        term_type = SAI_TUNNEL_TERM_TABLE_ENTRY_TYPE_P2MP

        try:
            # create dummy vlan for vrf
            dummy_vlan = sai_thrift_create_vlan(self.client,
                                                vlan_id=self.dummy_vlan_id)

            # create rif for dummy vlan
            dummy_vlan_rif = sai_thrift_create_router_interface(
                self.client,
                virtual_router_id=self.ovrf,
                src_mac_address=ROUTER_MAC,
                type=SAI_ROUTER_INTERFACE_TYPE_VLAN,
                vlan_id=dummy_vlan,
                mtu=9100,
                nat_zone_id=0)

            # create tunnel maps
            decap_tunnel_map_vlan = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VLAN_ID)

            encap_tunnel_map_vlan = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VLAN_ID_TO_VNI)

            decap_tunnel_map_vrf = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID)

            encap_tunnel_map_vrf = sai_thrift_create_tunnel_map(
                self.client, type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI)

            # create tunnel
            decap_maps = sai_thrift_object_list_t(
                count=2,
                idlist=[decap_tunnel_map_vlan,
                        decap_tunnel_map_vrf])
            encap_maps = sai_thrift_object_list_t(
                count=2,
                idlist=[encap_tunnel_map_vlan,
                        encap_tunnel_map_vrf])
            tunnel0 = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                underlay_interface=self.urif_lpb,
                decap_mappers=decap_maps,
                encap_mappers=encap_maps,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                peer_mode=peer_mode)

            tunnel_term = sai_thrift_create_tunnel_term_table_entry(
                self.client,
                type=term_type,
                vr_id=self.default_vrf,
                dst_ip=sai_ipaddress(self.lpb_ip),
                tunnel_type=tunnel_type,
                action_tunnel_id=tunnel0)

            # create tunnel map entries for vrf and dummy vlan
            decap_tunnel_map_entry_vlan = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VLAN_ID,
                tunnel_map=decap_tunnel_map_vlan,
                vlan_id_value=self.dummy_vlan_id,
                vni_id_key=self.vni_for_ovrf)

            encap_tunnel_map_entry_vrf = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VIRTUAL_ROUTER_ID_TO_VNI,
                tunnel_map=encap_tunnel_map_vrf,
                virtual_router_id_key=self.ovrf,
                vni_id_value=self.vni_for_ovrf)

            decap_tunnel_map_entry_vrf = sai_thrift_create_tunnel_map_entry(
                self.client,
                tunnel_map_type=SAI_TUNNEL_MAP_TYPE_VNI_TO_VIRTUAL_ROUTER_ID,
                tunnel_map=decap_tunnel_map_vrf,
                virtual_router_id_value=self.ovrf,
                vni_id_key=self.vni_for_ovrf)

            # when first route comes down for a remote vtep,
            # p2p tunnel comes down first
            tunnel1 = sai_thrift_create_tunnel(
                self.client,
                type=tunnel_type,
                underlay_interface=self.urif_lpb,
                decap_mappers=decap_maps,
                encap_mappers=encap_maps,
                encap_src_ip=sai_ipaddress(self.lpb_ip),
                peer_mode=SAI_TUNNEL_PEER_MODE_P2P,
                encap_dst_ip=sai_ipaddress(self.tun1_ip))

            # verify p2p tunnel creation with peer_mode P2P
            attr = sai_thrift_get_tunnel_attribute(
                self.client, tunnel1, peer_mode=True, encap_dst_ip=True)
            self.assertEqual(attr['peer_mode'],
                             SAI_TUNNEL_PEER_MODE_P2P,
                             "p2p tunnel peer mode is not correct")
            self.assertEqual(attr['encap_dst_ip'].addr.ip4,
                             sai_ipaddress(self.tun1_ip).addr.ip4,
                             "p2p tunnel dst ip is not correct")

            # bridge port is created on p2p tunnel
            tun1_bp = sai_thrift_create_bridge_port(
                self.client,
                type=SAI_BRIDGE_PORT_TYPE_TUNNEL,
                tunnel_id=tunnel1,
                bridge_id=self.default_1q_bridge,
                admin_state=True,
                fdb_learning_mode=SAI_BRIDGE_PORT_FDB_LEARNING_MODE_DISABLE)

            # verify bridge port on p2p tunnel
            attr = sai_thrift_get_bridge_port_attribute(
                self.client, tun1_bp, tunnel_id=True, fdb_learning_mode=True)
            self.assertEqual(attr['tunnel_id'],
                             tunnel1,
                             "bridge port tunnel_id is not correct")
            self.assertEqual(attr['fdb_learning_mode'],
                             SAI_BRIDGE_PORT_FDB_LEARNING_MODE_DISABLE,
                             "bridge port fdb learning mode is not correct")

            # vlan_member is created using tunnel bridge_port
            tun1_vlan_member = sai_thrift_create_vlan_member(
                self.client,
                vlan_id=self.vlan10,
                bridge_port_id=tun1_bp,
                vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)

            # verify vlan member on p2p tunnel
            attr = sai_thrift_get_vlan_member_attribute(
                self.client, tun1_vlan_member, bridge_port_id=True)
            self.assertEqual(attr['bridge_port_id'],
                             tun1_bp,
                             "vlan member bridge_port_id is not correct")

            # Next hop for symmetric operation
            tunnel_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP,
                ip=sai_ipaddress(self.tun1_ip),
                tunnel_id=tunnel0,
                tunnel_vni=self.vni_for_ovrf,
                tunnel_mac=self.inner_dmac)

            customer2_prefix_route = sai_thrift_route_entry_t(
                destination=sai_ipprefix(self.customer2_ip + '/24'),
                switch_id=self.switch_id,
                vr_id=self.ovrf)
            sai_thrift_create_route_entry(self.client,
                                          customer2_prefix_route,
                                          next_hop_id=tunnel_nhop)

            pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.customer1_mac,
                                    ip_dst=self.customer2_ip,
                                    ip_src=self.customer1_ip,
                                    ip_id=108,
                                    ip_ttl=64)
            inner_pkt = simple_udp_packet(eth_dst=self.inner_dmac,
                                          eth_src=ROUTER_MAC,
                                          ip_dst=self.customer2_ip,
                                          ip_src=self.customer1_ip,
                                          ip_id=108,
                                          ip_ttl=63)
            vxlan_pkt = Mask(
                simple_vxlan_packet(eth_dst=self.unbor1_mac,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.tun1_ip,
                                    ip_src=self.lpb_ip,
                                    ip_id=0,
                                    ip_ttl=63,
                                    ip_flags=0x2,
                                    with_udp_chksum=False,
                                    vxlan_vni=self.vni_for_ovrf,
                                    inner_frame=inner_pkt))
            vxlan_pkt.set_do_not_care_scapy(UDP, 'sport')

            print("Sending packet from port %d -> VNI %d" %
                  (self.oport1_dev, self.vni_for_ovrf))
            send_packet(self, self.oport1_dev, pkt)
            verify_packet(self, vxlan_pkt, self.uport1_dev)

            pkt_2 = simple_udp_packet(eth_dst=self.customer1_mac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.customer1_ip,
                                      ip_src=self.customer2_ip,
                                      ip_id=108,
                                      ip_ttl=63)
            inner_pkt_2 = simple_udp_packet(eth_dst=ROUTER_MAC,
                                            eth_src=self.inner_dmac,
                                            ip_dst=self.customer1_ip,
                                            ip_src=self.customer2_ip,
                                            ip_id=108,
                                            ip_ttl=64)
            vxlan_pkt_2 = simple_vxlan_packet(eth_dst=ROUTER_MAC,
                                              eth_src=self.unbor1_mac,
                                              ip_dst=self.lpb_ip,
                                              ip_src=self.tun1_ip,
                                              ip_id=0,
                                              ip_ttl=64,
                                              ip_flags=0x2,
                                              with_udp_chksum=False,
                                              vxlan_vni=self.vni_for_ovrf,
                                              inner_frame=inner_pkt_2)

            print("Sending packet from VNI %d -> port %d" %
                  (self.vni_for_ovrf, self.oport1_dev))
            send_packet(self, self.uport1_dev, vxlan_pkt_2)
            verify_packet(self, pkt_2, self.oport1_dev)

        finally:
            sai_thrift_remove_route_entry(self.client,
                                          customer2_prefix_route)
            sai_thrift_remove_next_hop(self.client, tunnel_nhop)
            if 'tun1_vlan_member' in locals() and tun1_vlan_member:
                sai_thrift_remove_vlan_member(self.client, tun1_vlan_member)
            if 'tun1_bp' in locals() and tun1_bp:
                sai_thrift_remove_bridge_port(self.client, tun1_bp)
            if 'tunnel1' in locals() and tunnel1:
                sai_thrift_remove_tunnel(self.client, tunnel1)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               decap_tunnel_map_entry_vrf)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               encap_tunnel_map_entry_vrf)
            sai_thrift_remove_tunnel_map_entry(self.client,
                                               decap_tunnel_map_entry_vlan)
            sai_thrift_remove_tunnel_term_table_entry(self.client, tunnel_term)
            sai_thrift_remove_tunnel(self.client, tunnel0)
            sai_thrift_remove_tunnel_map(self.client, encap_tunnel_map_vrf)
            sai_thrift_remove_tunnel_map(self.client, decap_tunnel_map_vrf)
            sai_thrift_remove_tunnel_map(self.client, encap_tunnel_map_vlan)
            sai_thrift_remove_tunnel_map(self.client, decap_tunnel_map_vlan)
            sai_thrift_remove_router_interface(self.client, dummy_vlan_rif)
            sai_thrift_remove_vlan(self.client, dummy_vlan)
